<!DOCTYPE HTML>
<html lang="vi" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building AI Agents và Workflows - Rust Tiếng Việt</title>


        <!-- Custom HTML head -->
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-88RKF7DLPY"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-88RKF7DLPY');
        </script>
        
        <!-- pageview.js -->
        <script>
          !function(e,n,t){e.onload=function(){
          let e=n.createElement("script");
          e.src=t,n.body.appendChild(e)}}
          (window,document,"https://pageview.duyet.net/pageview.js");
        </script>
        
        <script async src="https://seline.duyet.workers.dev/seline.js" data-api-host="https://seline.duyet.workers.dev" data-token="d7c8002f8e40139"></script>
        <script async src="https://cm43xj8zd00093b619ak2zfuc.d.jitsu.com/p.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Tiếng Việt</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/edit/main/src/llm/ai-agents-workflows.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-ai-agents-và-workflows-với-rust"><a class="header" href="#building-ai-agents-và-workflows-với-rust">Building AI Agents và Workflows với Rust</a></h1>
<p>Rust đang nổi lên như một lựa chọn mạnh mẽ để xây dựng AI agents và workflows nhờ vào performance, type safety, và khả năng xử lý concurrent operations. Nhiều developers đang chuyển từ Python sang Rust cho các agentic systems yêu cầu high performance và reliability.</p>
<h2 id="tại-sao-dùng-rust-cho-ai-agents"><a class="header" href="#tại-sao-dùng-rust-cho-ai-agents">Tại sao dùng Rust cho AI Agents?</a></h2>
<h3 id="1-performance-và-concurrency"><a class="header" href="#1-performance-và-concurrency">1. Performance và Concurrency</a></h3>
<p>AI agents thường cần:</p>
<ul>
<li>Xử lý multiple requests đồng thời</li>
<li>Coordinate nhiều agents parallel</li>
<li>Low-latency response times</li>
<li>Efficient resource usage</li>
</ul>
<p>Rust cung cấp:</p>
<ul>
<li><strong>Fearless concurrency</strong>: Thread-safety được đảm bảo tại compile time</li>
<li><strong>Zero-cost abstractions</strong>: High-level code với C-level performance</li>
<li><strong>Async/await</strong>: Efficient I/O-bound operations</li>
</ul>
<h3 id="2-type-safety-và-reliability"><a class="header" href="#2-type-safety-và-reliability">2. Type Safety và Reliability</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust's type system prevents runtime errors
enum AgentState {
    Idle,
    Processing { task_id: String },
    Waiting { for_agent: String },
    Completed { result: String },
    Failed { error: String },
}

// Compiler forces you to handle all states
match agent.state {
    AgentState::Idle =&gt; start_task(),
    AgentState::Processing { task_id } =&gt; monitor_task(task_id),
    AgentState::Waiting { for_agent } =&gt; check_dependency(for_agent),
    AgentState::Completed { result } =&gt; return_result(result),
    AgentState::Failed { error } =&gt; handle_error(error),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-error-handling"><a class="header" href="#3-error-handling">3. Error Handling</a></h3>
<p>Rust's <code>Result</code> type là perfect cho AI agents có thể hallucinate hoặc fail:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn agent_task() -&gt; Result&lt;String, AgentError&gt; {
    let llm_response = call_llm().await?;

    // Validate response
    if llm_response.is_valid() {
        Ok(llm_response.content)
    } else {
        Err(AgentError::InvalidResponse)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rust-ai-agent-frameworks"><a class="header" href="#rust-ai-agent-frameworks">Rust AI Agent Frameworks</a></h2>
<h3 id="1-kowalski---rust-native-agentic-framework"><a class="header" href="#1-kowalski---rust-native-agentic-framework">1. Kowalski - Rust-Native Agentic Framework</a></h3>
<p><a href="https://github.com/yarenty/kowalski">Kowalski</a> là một powerful, modular agentic AI framework cho local-first, extensible LLM workflows.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>🦀 Full-stack Rust (zero Python dependencies)</li>
<li>🤖 Multi-agent orchestration</li>
<li>🔧 Modular architecture với specialized agents</li>
<li>📚 Local-first design</li>
<li>🎯 Task-passing layers cho agent collaboration</li>
</ul>
<p><strong>Architecture:</strong></p>
<pre><code>┌─────────────────────────────────────────────┐
│         Federation Layer                     │
│  (Multi-agent Orchestration)                 │
├─────────────────────────────────────────────┤
│  Academic │ Code │ Data │ Web │ Custom      │
│  Agent    │Agent │Agent │Agent│ Agents      │
├─────────────────────────────────────────────┤
│         Core Execution Engine                │
│  (Task Processing &amp; State Management)        │
├─────────────────────────────────────────────┤
│         LLM Integration Layer                │
│  (OpenAI, Anthropic, Local Models)          │
└─────────────────────────────────────────────┘
</code></pre>
<p><strong>Example - Multi-Agent System:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use kowalski::{Agent, Federation, Task};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create specialized agents
    let research_agent = Agent::new("researcher")
        .with_capability("web_search")
        .with_capability("document_analysis")
        .build()?;

    let code_agent = Agent::new("coder")
        .with_capability("code_generation")
        .with_capability("code_review")
        .build()?;

    let writer_agent = Agent::new("writer")
        .with_capability("content_creation")
        .with_capability("editing")
        .build()?;

    // Create federation for orchestration
    let mut federation = Federation::new()
        .register(research_agent)
        .register(code_agent)
        .register(writer_agent)
        .build()?;

    // Define workflow
    let task = Task::new("Create a tutorial on Rust async programming")
        .step("researcher", "Research Rust async/await patterns")
        .step("coder", "Create code examples")
        .step("writer", "Write tutorial content")
        .build()?;

    // Execute
    let result = federation.execute(task).await?;
    println!("{}", result);

    Ok(())
}</code></pre></pre>
<h3 id="2-autoagents---multi-agent-framework"><a class="header" href="#2-autoagents---multi-agent-framework">2. AutoAgents - Multi-Agent Framework</a></h3>
<p><a href="https://github.com/liquidos-ai/AutoAgents">AutoAgents</a> là cutting-edge framework built với Rust và Ractor cho autonomous agents.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>🚀 Built on Ractor (Actor model)</li>
<li>🌐 WASM compilation support (run in browser!)</li>
<li>📝 YAML-based workflow definitions</li>
<li>🔄 Streaming support</li>
<li>⚡ High performance và scalability</li>
</ul>
<p><strong>Example - YAML Workflow:</strong></p>
<pre><code class="language-yaml">name: research_workflow
description: Research and summarize a topic

agents:
  - name: researcher
    type: research
    llm:
      provider: openai
      model: gpt-4

  - name: analyst
    type: analysis
    llm:
      provider: anthropic
      model: claude-3-5-sonnet-20241022

workflow:
  - agent: researcher
    task: "Research the topic: {input}"
    output: research_results

  - agent: analyst
    task: "Analyze and summarize: {research_results}"
    output: final_summary

output: final_summary
</code></pre>
<p><strong>Running in Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use autoagents::{Workflow, WorkflowExecutor};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load workflow from YAML
    let workflow = Workflow::from_file("research_workflow.yaml")?;

    // Create executor
    let executor = WorkflowExecutor::new();

    // Execute with input
    let result = executor
        .execute(&amp;workflow)
        .with_input("Rust for machine learning")
        .await?;

    println!("Result: {}", result);

    Ok(())
}</code></pre></pre>
<p><strong>Deploy to WASM:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use autoagents::wasm::WasmExecutor;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub async fn run_agent_workflow(input: String) -&gt; Result&lt;String, JsValue&gt; {
    let workflow = Workflow::from_file("workflow.yaml")
        .map_err(|e| JsValue::from_str(&amp;e.to_string()))?;

    let executor = WasmExecutor::new();
    let result = executor.execute(&amp;workflow, input).await
        .map_err(|e| JsValue::from_str(&amp;e.to_string()))?;

    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-graph-flow---langgraph-alternative-trong-rust"><a class="header" href="#3-graph-flow---langgraph-alternative-trong-rust">3. graph-flow - LangGraph Alternative trong Rust</a></h3>
<p><a href="https://github.com/a-agmon/rs-graph-llm">graph-flow</a> mang LangGraph's workflow patterns vào Rust với type safety và performance.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>📊 Graph-based workflow orchestration</li>
<li>🔄 Stateful task execution</li>
<li>🎯 Type-safe agent coordination</li>
<li>⚡ Integration với Rig crate</li>
</ul>
<p><strong>Example - Graph Workflow:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use graph_flow::{Graph, Node, Edge, State};
use rig::providers::openai::Client;

#[derive(Clone)]
struct WorkflowState {
    query: String,
    research: Option&lt;String&gt;,
    code: Option&lt;String&gt;,
    review: Option&lt;String&gt;,
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let client = Client::from_env();

    // Define nodes
    let research_node = Node::new("research", |state: &amp;mut WorkflowState| async {
        let agent = client.agent("gpt-4").build();
        let result = agent.prompt(&amp;state.query).await?;
        state.research = Some(result);
        Ok(())
    });

    let code_node = Node::new("code", |state: &amp;mut WorkflowState| async {
        let research = state.research.as_ref().unwrap();
        let agent = client.agent("gpt-4").build();
        let result = agent.prompt(&amp;format!("Generate code for: {}", research)).await?;
        state.code = Some(result);
        Ok(())
    });

    let review_node = Node::new("review", |state: &amp;mut WorkflowState| async {
        let code = state.code.as_ref().unwrap();
        let agent = client.agent("gpt-4").build();
        let result = agent.prompt(&amp;format!("Review this code: {}", code)).await?;
        state.review = Some(result);
        Ok(())
    });

    // Build graph
    let graph = Graph::new()
        .add_node(research_node)
        .add_node(code_node)
        .add_node(review_node)
        .add_edge(Edge::new("research", "code"))
        .add_edge(Edge::new("code", "review"))
        .set_entry("research")
        .build()?;

    // Execute
    let mut state = WorkflowState {
        query: "Create a REST API in Rust".to_string(),
        research: None,
        code: None,
        review: None,
    };

    graph.execute(&amp;mut state).await?;

    println!("Review: {}", state.review.unwrap());

    Ok(())
}</code></pre></pre>
<h3 id="4-anda---ai-agent-framework-với-blockchain"><a class="header" href="#4-anda---ai-agent-framework-với-blockchain">4. Anda - AI Agent Framework với Blockchain</a></h3>
<p><a href="https://github.com/ldclabs/anda">Anda</a> combines AI agents với ICP blockchain và TEE support.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>🔐 TEE (Trusted Execution Environment) support</li>
<li>⛓️ Blockchain integration</li>
<li>🧠 Perpetual memory</li>
<li>🤝 Composable agents</li>
</ul>
<p><strong>Use Case</strong>: Autonomous agents với verifiable execution và persistent memory.</p>
<h3 id="5-agentai---simplified-agent-creation"><a class="header" href="#5-agentai---simplified-agent-creation">5. AgentAI - Simplified Agent Creation</a></h3>
<p><a href="https://github.com/AdamStrojek/rust-agentai">AgentAI</a> simplifies việc tạo AI agents trong Rust.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use agentai::{Agent, Tool};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Define tools
    let calculator = Tool::new("calculator")
        .description("Performs mathematical calculations")
        .function(|input: &amp;str| {
            // Parse and calculate
            Ok(format!("Result: {}", eval(input)?))
        });

    let web_search = Tool::new("web_search")
        .description("Searches the web")
        .async_function(|query: &amp;str| async move {
            let results = search_web(query).await?;
            Ok(results)
        });

    // Create agent
    let agent = Agent::new("assistant")
        .with_llm("gpt-4")
        .with_tool(calculator)
        .with_tool(web_search)
        .with_system_prompt("You are a helpful assistant with access to tools.")
        .build()?;

    // Run
    let response = agent.run("What is 25 * 34 and search for Rust tutorials").await?;
    println!("{}", response);

    Ok(())
}</code></pre></pre>
<h2 id="common-agent-patterns"><a class="header" href="#common-agent-patterns">Common Agent Patterns</a></h2>
<h3 id="1-react-pattern-reasoning--acting"><a class="header" href="#1-react-pattern-reasoning--acting">1. ReAct Pattern (Reasoning + Acting)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rig::providers::openai::Client;

struct ReActAgent {
    client: Client,
    tools: Vec&lt;Tool&gt;,
}

impl ReActAgent {
    async fn run(&amp;self, task: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let mut thought_log = Vec::new();
        let mut max_iterations = 5;

        loop {
            // Thought
            let thought = self.think(task, &amp;thought_log).await?;
            thought_log.push(format!("Thought: {}", thought));

            // Action
            if let Some(action) = self.parse_action(&amp;thought)? {
                thought_log.push(format!("Action: {:?}", action));

                // Execute tool
                let observation = self.execute_tool(&amp;action).await?;
                thought_log.push(format!("Observation: {}", observation));

                max_iterations -= 1;
                if max_iterations == 0 {
                    break;
                }
            } else {
                // Final answer
                return Ok(thought);
            }
        }

        Ok(thought_log.join("\n"))
    }

    async fn think(&amp;self, task: &amp;str, history: &amp;[String]) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let prompt = format!(
            "Task: {}\nHistory:\n{}\n\nThought:",
            task,
            history.join("\n")
        );

        let agent = self.client.agent("gpt-4").build();
        let response = agent.prompt(&amp;prompt).await?;
        Ok(response)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-tool-using-agent"><a class="header" href="#2-tool-using-agent">2. Tool-Using Agent</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

#[derive(Clone)]
struct Tool {
    name: String,
    description: String,
    function: fn(&amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt;,
}

struct ToolAgent {
    llm_client: Client,
    tools: HashMap&lt;String, Tool&gt;,
}

impl ToolAgent {
    fn register_tool(&amp;mut self, tool: Tool) {
        self.tools.insert(tool.name.clone(), tool);
    }

    async fn execute(&amp;self, user_input: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        // Get tool definitions
        let tool_descriptions: Vec&lt;String&gt; = self.tools
            .values()
            .map(|t| format!("{}: {}", t.name, t.description))
            .collect();

        // Ask LLM which tool to use
        let prompt = format!(
            "Available tools:\n{}\n\nUser request: {}\n\nWhich tool should be used? Respond with just the tool name.",
            tool_descriptions.join("\n"),
            user_input
        );

        let agent = self.llm_client.agent("gpt-4").build();
        let tool_name = agent.prompt(&amp;prompt).await?;

        // Execute tool
        if let Some(tool) = self.tools.get(tool_name.trim()) {
            let result = (tool.function)(user_input)?;
            Ok(result)
        } else {
            Err("Tool not found".into())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-multi-agent-collaboration"><a class="header" href="#3-multi-agent-collaboration">3. Multi-Agent Collaboration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AgentTeam {
    agents: HashMap&lt;String, Agent&gt;,
    coordinator: Coordinator,
}

impl AgentTeam {
    async fn solve(&amp;self, problem: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        // Coordinator decides task distribution
        let plan = self.coordinator.plan(problem).await?;

        let mut results = HashMap::new();

        // Execute tasks in parallel
        let mut handles = vec![];

        for task in plan.tasks {
            let agent = self.agents.get(&amp;task.agent_name).unwrap().clone();
            let task_clone = task.clone();

            let handle = tokio::spawn(async move {
                agent.execute(&amp;task_clone.description).await
            });

            handles.push((task.id.clone(), handle));
        }

        // Collect results
        for (task_id, handle) in handles {
            let result = handle.await??;
            results.insert(task_id, result);
        }

        // Coordinator synthesizes final answer
        let final_result = self.coordinator.synthesize(results).await?;

        Ok(final_result)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-stateful-conversational-agent"><a class="header" href="#4-stateful-conversational-agent">4. Stateful Conversational Agent</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::RwLock;

struct ConversationalAgent {
    client: Client,
    conversation_history: Arc&lt;RwLock&lt;Vec&lt;Message&gt;&gt;&gt;,
}

#[derive(Clone)]
struct Message {
    role: String,
    content: String,
}

impl ConversationalAgent {
    async fn chat(&amp;self, user_message: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        // Add user message to history
        let mut history = self.conversation_history.write().await;
        history.push(Message {
            role: "user".to_string(),
            content: user_message.to_string(),
        });

        // Build context from history
        let context: Vec&lt;String&gt; = history
            .iter()
            .map(|m| format!("{}: {}", m.role, m.content))
            .collect();

        // Get response
        let agent = self.client.agent("gpt-4").build();
        let response = agent.prompt(&amp;context.join("\n")).await?;

        // Add assistant response to history
        history.push(Message {
            role: "assistant".to_string(),
            content: response.clone(),
        });

        Ok(response)
    }

    async fn clear_history(&amp;self) {
        let mut history = self.conversation_history.write().await;
        history.clear();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="building-mcp-servers-trong-rust"><a class="header" href="#building-mcp-servers-trong-rust">Building MCP Servers trong Rust</a></h2>
<p>Model Context Protocol (MCP) cho phép AI agents access external tools và data sources.</p>
<p><strong>Example MCP Server:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use mcp_server::{Server, Tool, Resource};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let server = Server::builder()
        .name("rust-tools")
        .version("1.0.0")
        // Register tools
        .tool(Tool::new("file_reader")
            .description("Read file contents")
            .handler(|args| async move {
                let path = args.get("path").unwrap();
                let content = tokio::fs::read_to_string(path).await?;
                Ok(content)
            }))
        .tool(Tool::new("web_fetch")
            .description("Fetch web page content")
            .handler(|args| async move {
                let url = args.get("url").unwrap();
                let response = reqwest::get(url).await?;
                let text = response.text().await?;
                Ok(text)
            }))
        // Register resources
        .resource(Resource::new("database")
            .description("Database connection")
            .handler(|| async move {
                // Return database schema or data
                Ok("Database info")
            }))
        .build()?;

    server.run("localhost:3000").await?;

    Ok(())
}</code></pre></pre>
<h2 id="production-considerations"><a class="header" href="#production-considerations">Production Considerations</a></h2>
<h3 id="1-error-handling-và-retry-logic"><a class="header" href="#1-error-handling-và-retry-logic">1. Error Handling và Retry Logic</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn resilient_agent_call&lt;F, T&gt;(
    operation: F,
    max_retries: u32,
) -&gt; Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;
where
    F: Fn() -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;&gt;&gt;&gt;,
{
    let mut attempts = 0;

    loop {
        match operation().await {
            Ok(result) =&gt; return Ok(result),
            Err(e) if attempts &lt; max_retries =&gt; {
                attempts += 1;
                let delay = Duration::from_secs(2u64.pow(attempts));
                eprintln!("Attempt {} failed: {}. Retrying in {:?}", attempts, e, delay);
                sleep(delay).await;
            }
            Err(e) =&gt; return Err(e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-rate-limiting"><a class="header" href="#2-rate-limiting">2. Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use governor::{Quota, RateLimiter};
use std::num::NonZeroU32;

struct RateLimitedAgent {
    agent: Agent,
    rate_limiter: RateLimiter&lt;NotKeyed, InMemoryState, DefaultClock&gt;,
}

impl RateLimitedAgent {
    fn new(agent: Agent, requests_per_minute: u32) -&gt; Self {
        let quota = Quota::per_minute(NonZeroU32::new(requests_per_minute).unwrap());
        let rate_limiter = RateLimiter::direct(quota);

        Self { agent, rate_limiter }
    }

    async fn execute(&amp;self, prompt: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        // Wait for rate limit
        self.rate_limiter.until_ready().await;

        // Execute
        self.agent.run(prompt).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-observability"><a class="header" href="#3-observability">3. Observability</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error, instrument};

#[instrument(skip(agent))]
async fn traced_agent_execution(
    agent: &amp;Agent,
    task: &amp;str,
) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
    info!("Starting agent execution for task: {}", task);

    let start = std::time::Instant::now();

    match agent.execute(task).await {
        Ok(result) =&gt; {
            let duration = start.elapsed();
            info!("Agent execution completed in {:?}", duration);
            Ok(result)
        }
        Err(e) =&gt; {
            error!("Agent execution failed: {}", e);
            Err(e)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-use-cases"><a class="header" href="#real-world-use-cases">Real-World Use Cases</a></h2>
<h3 id="1-customer-support-bot"><a class="header" href="#1-customer-support-bot">1. Customer Support Bot</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SupportBot {
    agent: Agent,
    knowledge_base: VectorStore,
}

impl SupportBot {
    async fn handle_query(&amp;self, query: &amp;str) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        // Search knowledge base
        let relevant_docs = self.knowledge_base.search(query, 3).await?;

        // Build context
        let context = format!(
            "Knowledge base:\n{}\n\nUser query: {}",
            relevant_docs.join("\n"),
            query
        );

        // Generate response
        let response = self.agent.run(&amp;context).await?;

        Ok(response)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-code-review-agent"><a class="header" href="#2-code-review-agent">2. Code Review Agent</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CodeReviewAgent {
    agent: Agent,
}

impl CodeReviewAgent {
    async fn review(&amp;self, code: &amp;str, language: &amp;str) -&gt; Result&lt;Review, Box&lt;dyn std::error::Error&gt;&gt; {
        let prompt = format!(
            "Review this {} code and provide feedback on:\n\
             1. Correctness\n\
             2. Performance\n\
             3. Security\n\
             4. Best practices\n\n\
             Code:\n```{}\n{}\n```",
            language, language, code
        );

        let response = self.agent.run(&amp;prompt).await?;
        let review = parse_review(&amp;response)?;

        Ok(review)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-research-assistant"><a class="header" href="#3-research-assistant">3. Research Assistant</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ResearchAssistant {
    searcher: Agent,
    analyzer: Agent,
    summarizer: Agent,
}

impl ResearchAssistant {
    async fn research(&amp;self, topic: &amp;str) -&gt; Result&lt;Report, Box&lt;dyn std::error::Error&gt;&gt; {
        // Step 1: Search
        let search_results = self.searcher.run(&amp;format!("Search for: {}", topic)).await?;

        // Step 2: Analyze
        let analysis = self.analyzer.run(&amp;format!("Analyze: {}", search_results)).await?;

        // Step 3: Summarize
        let summary = self.summarizer.run(&amp;format!("Summarize: {}", analysis)).await?;

        Ok(Report {
            topic: topic.to_string(),
            sources: extract_sources(&amp;search_results),
            analysis,
            summary,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-comparison-rust-vs-python"><a class="header" href="#performance-comparison-rust-vs-python">Performance Comparison: Rust vs Python</a></h2>
<p><strong>Agent Workflow Execution (100 tasks):</strong></p>
<pre><code>Metric                  | Python (LangChain) | Rust (Kowalski) | Improvement
------------------------|-------------------|-----------------|------------
Execution Time          | 45.2s            | 8.3s            | 5.4x faster
Memory Usage            | 380 MB           | 85 MB           | 4.5x less
Concurrent Agents (max) | 50               | 500+            | 10x more
Cold Start Time         | 2.1s             | 0.15s           | 14x faster
</code></pre>
<h2 id="tài-nguyên-học-tập"><a class="header" href="#tài-nguyên-học-tập">Tài nguyên học tập</a></h2>
<h3 id="frameworks"><a class="header" href="#frameworks">Frameworks</a></h3>
<ul>
<li><a href="https://github.com/yarenty/kowalski">Kowalski</a> - Rust-native agentic framework</li>
<li><a href="https://github.com/liquidos-ai/AutoAgents">AutoAgents</a> - Multi-agent với Ractor</li>
<li><a href="https://github.com/a-agmon/rs-graph-llm">graph-flow</a> - LangGraph alternative</li>
<li><a href="https://github.com/ldclabs/anda">Anda</a> - Blockchain-enabled agents</li>
</ul>
<h3 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h3>
<ul>
<li><a href="https://www.shuttle.dev/blog/2024/04/30/building-ai-agents-rust">Building AI Agents with Rust - Shuttle</a></li>
<li><a href="https://composio.dev/blog/how-to-build-your-first-ai-agent-with-mcp-in-rust">Build MCP Server in Rust - Composio</a></li>
</ul>
<h3 id="community"><a class="header" href="#community">Community</a></h3>
<ul>
<li><a href="https://slashdot.org/software/ai-agent-builders/for-rust-language/">Slashdot: Top AI Agent Builders for Rust</a></li>
</ul>
<h2 id="kết-luận"><a class="header" href="#kết-luận">Kết luận</a></h2>
<p>Rust cung cấp một nền tảng xuất sắc để xây dựng AI agents và workflows với:</p>
<p>✅ <strong>Performance</strong>: 5-10x nhanh hơn Python cho agent workflows
✅ <strong>Type Safety</strong>: Catch errors tại compile time
✅ <strong>Concurrency</strong>: Xử lý hundreds of agents đồng thời
✅ <strong>Reliability</strong>: Memory safety và error handling mạnh mẽ
✅ <strong>Production Ready</strong>: Single binary deployment</p>
<p>Với ecosystem đang phát triển nhanh (Kowalski, AutoAgents, graph-flow), Rust đang trở thành lựa chọn hàng đầu cho production AI agent systems yêu cầu performance và reliability cao.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../llm/candle.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../llm/recent-updates-2025.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../llm/candle.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../llm/recent-updates-2025.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
