<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Tiếng Việt</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-88RKF7DLPY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-88RKF7DLPY');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="who-is-using.html"><strong aria-hidden="true">2.</strong> Who is using?</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cơ bản</li><li class="chapter-item expanded "><a href="basic/variables/index.html"><strong aria-hidden="true">3.</strong> Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/variables/mut.html"><strong aria-hidden="true">3.1.</strong> mut</a></li><li class="chapter-item expanded "><a href="basic/variables/uninitialized.html"><strong aria-hidden="true">3.2.</strong> uninitialized variable</a></li></ol></li><li class="chapter-item expanded "><a href="basic/closure.html"><strong aria-hidden="true">4.</strong> Closure</a></li><li class="chapter-item expanded "><a href="basic/cargo/index.html"><strong aria-hidden="true">5.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="basic/package-crate/index.html"><strong aria-hidden="true">6.</strong> Packages và Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/package-crate/package-layout.html"><strong aria-hidden="true">6.1.</strong> Package layout</a></li><li class="chapter-item expanded "><a href="basic/package-crate/crate.html"><strong aria-hidden="true">6.2.</strong> Crate</a></li><li class="chapter-item expanded "><a href="basic/package-crate/use-crate/index.html"><strong aria-hidden="true">6.3.</strong> use crate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/package-crate/use-crate/self-super.html"><strong aria-hidden="true">6.3.1.</strong> use self, use super</a></li><li class="chapter-item expanded "><a href="basic/package-crate/use-crate/pub-use.html"><strong aria-hidden="true">6.3.2.</strong> pub use</a></li></ol></li><li class="chapter-item expanded "><a href="basic/package-crate/preludes.html"><strong aria-hidden="true">6.4.</strong> Preludes</a></li></ol></li><li class="chapter-item expanded "><a href="basic/ownership.html"><strong aria-hidden="true">7.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="basic/struct.html"><strong aria-hidden="true">8.</strong> Struct</a></li><li class="chapter-item expanded "><a href="basic/trait/index.html"><strong aria-hidden="true">9.</strong> Trait</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/trait/supertraits.html"><strong aria-hidden="true">9.1.</strong> Supertraits</a></li><li class="chapter-item expanded "><a href="basic/trait/copy-clone.html"><strong aria-hidden="true">9.2.</strong> Copy, Clone</a></li><li class="chapter-item expanded "><a href="basic/trait/string-str.html"><strong aria-hidden="true">9.3.</strong> String và &str</a></li><li class="chapter-item expanded "><a href="basic/trait/fromstr.html"><strong aria-hidden="true">9.4.</strong> FromStr</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Display</div></li></ol></li><li class="chapter-item expanded "><a href="basic/enum/index.html"><strong aria-hidden="true">10.</strong> Enum</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/enum/match.html"><strong aria-hidden="true">10.1.</strong> match Enum</a></li><li class="chapter-item expanded "><a href="basic/enum/use-variants.html"><strong aria-hidden="true">10.2.</strong> Mang Variants ra ngoài scope của Enum</a></li><li class="chapter-item expanded "><a href="basic/enum/impl.html"><strong aria-hidden="true">10.3.</strong> impl Enum</a></li><li class="chapter-item expanded "><a href="basic/enum/option/index.html"><strong aria-hidden="true">10.4.</strong> Option&lt;T&gt;</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/enum/option/unwrap.html"><strong aria-hidden="true">10.4.1.</strong> unwrap()</a></li><li class="chapter-item expanded "><a href="basic/enum/option/expect.html"><strong aria-hidden="true">10.4.2.</strong> expect()</a></li><li class="chapter-item expanded "><a href="basic/enum/option/unwrap_or_default.html"><strong aria-hidden="true">10.4.3.</strong> unwrap_or_default()</a></li><li class="chapter-item expanded "><a href="basic/enum/option/if_let_some.html"><strong aria-hidden="true">10.4.4.</strong> if let Some(x) = x</a></li></ol></li><li class="chapter-item expanded "><a href="basic/enum/result/index.html"><strong aria-hidden="true">10.5.</strong> Result&lt;T, E&gt;</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/enum/result/result-to-option.html"><strong aria-hidden="true">10.5.1.</strong> Convert Result sang Option</a></li><li class="chapter-item expanded "><a href="basic/enum/result/question-mark.html"><strong aria-hidden="true">10.5.2.</strong> Toán tử ?</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="basic/generics/index.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/generics/functions.html"><strong aria-hidden="true">11.1.</strong> Generic Functions</a></li><li class="chapter-item expanded "><a href="basic/generics/struct.html"><strong aria-hidden="true">11.2.</strong> Generic Struct</a></li><li class="chapter-item expanded "><a href="basic/generics/enum.html"><strong aria-hidden="true">11.3.</strong> Generic Enum</a></li><li class="chapter-item expanded "><a href="basic/generics/impl.html"><strong aria-hidden="true">11.4.</strong> Generic Implementation</a></li><li class="chapter-item expanded "><a href="basic/generics/trait.html"><strong aria-hidden="true">11.5.</strong> Generic Trait</a></li><li class="chapter-item expanded "><a href="basic/generics/bounds.html"><strong aria-hidden="true">11.6.</strong> Bounds</a></li><li class="chapter-item expanded "><a href="basic/generics/where.html"><strong aria-hidden="true">11.7.</strong> where</a></li></ol></li><li class="chapter-item expanded "><a href="basic/vec/INDEX.html"><strong aria-hidden="true">12.</strong> Vec</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Iter</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Sử dụng Enum để chứa nhiều loại dữ liệu</div></li></ol></li><li class="chapter-item expanded "><a href="basic/box.html"><strong aria-hidden="true">13.</strong> Box</a></li><li class="chapter-item expanded "><a href="basic/cow.html"><strong aria-hidden="true">14.</strong> Cow</a></li><li class="chapter-item expanded "><a href="basic/code-comment/index.html"><strong aria-hidden="true">15.</strong> /// Viết code comment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/code-comment/doc-comment.html"><strong aria-hidden="true">15.1.</strong> Doc comments</a></li></ol></li><li class="chapter-item expanded "><a href="basic/turbofish.html"><strong aria-hidden="true">16.</strong> Turbofish ::&lt;&gt;</a></li><li class="chapter-item expanded "><a href="basic/macro/index.html"><strong aria-hidden="true">17.</strong> macros!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/macro/standard-macros.html"><strong aria-hidden="true">17.1.</strong> Macros mặc định</a></li><li class="chapter-item expanded "><a href="basic/macro/println.html"><strong aria-hidden="true">17.2.</strong> println!</a></li><li class="chapter-item expanded "><a href="basic/macro/format.html"><strong aria-hidden="true">17.3.</strong> format!</a></li><li class="chapter-item expanded "><a href="basic/macro/todo.html"><strong aria-hidden="true">17.4.</strong> todo!</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.5.</strong> macro_rules!</div></li></ol></li><li class="chapter-item expanded "><a href="basic/match/index.html"><strong aria-hidden="true">18.</strong> match</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/match/literals.html"><strong aria-hidden="true">18.1.</strong> Matching giá trị</a></li><li class="chapter-item expanded "><a href="basic/match/named-vars.html"><strong aria-hidden="true">18.2.</strong> Matching Named Variables</a></li><li class="chapter-item expanded "><a href="basic/match/multiple.html"><strong aria-hidden="true">18.3.</strong> Matching Multiple</a></li></ol></li><li class="chapter-item expanded "><a href="basic/attr.html"><strong aria-hidden="true">19.</strong> #[attributes]</a></li><li class="chapter-item expanded "><a href="basic/error-handling/index.html"><strong aria-hidden="true">20.</strong> Xử lý lỗi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/error-handling/panic.html"><strong aria-hidden="true">20.1.</strong> panic</a></li><li class="chapter-item expanded "><a href="basic/error-handling/option.html"><strong aria-hidden="true">20.2.</strong> Option</a></li><li class="chapter-item expanded "><a href="basic/error-handling/result.html"><strong aria-hidden="true">20.3.</strong> Result</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/error-handling/result-map.html"><strong aria-hidden="true">20.3.1.</strong> Result map</a></li><li class="chapter-item expanded "><a href="basic/error-handling/result-alias.html"><strong aria-hidden="true">20.3.2.</strong> Result alias</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.4.</strong> Custom error</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.5.</strong> Boxing error</div></li></ol></li><li class="chapter-item expanded "><a href="basic/testing/index.html"><strong aria-hidden="true">21.</strong> Viết Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/testing/test-organization.html"><strong aria-hidden="true">21.1.</strong> Tổ chức Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/testing/unit-tests.html"><strong aria-hidden="true">21.1.1.</strong> Unit Tests</a></li><li class="chapter-item expanded "><a href="basic/testing/integration-tests.html"><strong aria-hidden="true">21.1.2.</strong> Integration Tests</a></li><li class="chapter-item expanded "><a href="basic/testing/doc-tests.html"><strong aria-hidden="true">21.1.3.</strong> Doc Tests</a></li></ol></li><li class="chapter-item expanded "><a href="basic/testing/env-conflict.html"><strong aria-hidden="true">21.2.</strong> Xung đột biến môi trường</a></li></ol></li><li class="chapter-item expanded "><a href="basic/rustdoc/index.html"><strong aria-hidden="true">22.</strong> Viết Docs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/code-comment/doc-comment.html"><strong aria-hidden="true">22.1.</strong> Doc comments</a></li><li class="chapter-item expanded "><a href="basic/rustdoc/doc-README.html"><strong aria-hidden="true">22.2.</strong> Sử dụng README.md làm crate document</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Smart Pointers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> Box</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> Rc, Reference Counted</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Design patterns</li><li class="chapter-item expanded "><a href="design-pattern/behavioural/index.html"><strong aria-hidden="true">24.</strong> Behavioural Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-pattern/behavioural/strategy.html"><strong aria-hidden="true">24.1.</strong> Strategy Pattern</a></li><li class="chapter-item expanded "><a href="design-pattern/behavioural/command.html"><strong aria-hidden="true">24.2.</strong> Command Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="design-pattern/creational/index.html"><strong aria-hidden="true">25.</strong> Creational Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-pattern/creational/builder.html"><strong aria-hidden="true">25.1.</strong> Builder Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="design-pattern/structural/index.html"><strong aria-hidden="true">26.</strong> Structural Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-pattern/structural/small-rates.html"><strong aria-hidden="true">26.1.</strong> Prefer Small Crates</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Crates hay dùng</li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> tokio</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> actix-web</div></li><li class="chapter-item expanded "><a href="crates/anyhow.html"><strong aria-hidden="true">29.</strong> anyhow</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> serde</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">30.1.</strong> serde_json</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> clap</div></li><li class="chapter-item expanded "><a href="crates/log/index.html"><strong aria-hidden="true">32.</strong> log</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates/log/env_logger.html"><strong aria-hidden="true">32.1.</strong> env_logger</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> config</div></li><li class="chapter-item expanded "><a href="crates/async_trait.html"><strong aria-hidden="true">34.</strong> async_trait</a></li><li class="chapter-item expanded "><a href="crates/lazy_static.html"><strong aria-hidden="true">35.</strong> lazy_static</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">36.</strong> indoc</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Rust Idioms</li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.</strong> Functional programming</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">38.</strong> Use borrowed types for arguments</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">39.</strong> Concatenating strings with format!</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">40.</strong> Constructor</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">41.</strong> The Default Trait</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">42.</strong> Finalisation in destructors</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">43.</strong> Temporary mutability</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Tiếng Việt</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-tiếng-việt"><a class="header" href="#rust-tiếng-việt">Rust Tiếng Việt</a></h1>
<p><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/actions/workflows/deploy.yml"><img src="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/actions/workflows/deploy.yml/badge.svg" alt="Deploy Book" /></a></p>
<blockquote>
<p>The book is published at <a href="https://rust-tieng-viet.github.io">https://rust-tieng-viet.github.io</a>.</p>
</blockquote>
<pre><code>    _~^~^~_
\) /  o o  \ (/
  '_   _   _'
  / '-----' \
</code></pre>
<p>Rust là một ngôn ngữ nhanh, an toàn và được bình chọn là 
ngôn ngữ được ưa thích nhất trong nhiều năm liền theo <a href="https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages.">Stack Overflow Survey</a>.
Rust có một hệ thống tài liệu và sách đồ sộ, chi tiết.
Nhưng đôi khi nó sẽ khó tiếp cận với một số người bởi đa số tài liệu là Tiếng Anh.
Với những ghi chép trong sách này, hy vọng có thể giúp cho mọi người
(cũng như các thành viên trong team mình <a href="https://blog.duyet.net/2021/11/rust-data-engineering.html">tại Fossil</a>) có thể tiếp cận với
ngôn ngữ này một cách nhanh chóng và dễ dàng hơn.
Cũng như truyền cảm hứng và mở rộng cộng đồng sử dụng Rust tại Việt Nam.</p>
<p>Mục tiêu của sách này không phải là dịch từ các sách tiếng Anh.
Mà sẽ là những ghi chép, những lưu ý cho một người mới bắt đầu học Rust
cho đến lúc thành thạo, từ lúc <code>hello world</code> cho đến các dự án thực tế.
Bao gồm những khó khăn mà bạn sẽ phải gặp, những thuật ngữ, concepts mới, 
những thói quen lập trình mới mà bạn sẽ phải làm quen.</p>
<p>Mình vẫn luôn prefer đọc sách tiếng Anh nếu bạn có thể. 
Vui lòng xem mục <strong>references</strong> ở cuối các trang nếu bạn muốn đào sâu hơn.</p>
<h3 id="links"><a class="header" href="#links">Links</a></h3>
<ul>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io">Mã nguồn sách này</a></li>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io#contribution">Đóng góp, chỉnh sửa</a></li>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/issues/new?assignees=duyet%2Cduyetbot&amp;labels=request%2Ccontent&amp;template=request_content.yml&amp;title=%5BY%C3%AAu+c%E1%BA%A7u+n%E1%BB%99i+dung%5D">Yêu cầu thêm nội dung</a></li>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/blob/main/LICENCE">License</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="who-is-using-rust"><a class="header" href="#who-is-using-rust">Who is using Rust?</a></h1>
<p>Công ty sử dụng Rust tại Việt Nam.</p>
<div class="table-wrapper"><table><thead><tr><th>Organization</th><th>Contact (GitHub User Name)</th><th>Environment</th><th>Description of Use</th></tr></thead><tbody>
<tr><td>Fossil Vietnam</td><td><a href="https://github.com/duyet">@duyet</a></td><td>Staging</td><td>Data Platform</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables trong Rust có kiểu dữ liệu tĩnh. 
Ta khai báo kiểu dữ liệu trong lúc khai báo biến. 
Trong đa số các trường hợp compiler có thể đoán được kiểu dữ liệu
nên đôi khi ta có thể bỏ qua.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let an_integer = 1u32;
let a_boolean = true;
let unit = ();

// copy `an_integer` into `copied_integer`
let copied_integer = an_integer;
<span class="boring">}
</span></code></pre></pre>
<p>Mọi biến đều phải được sử dụng, nếu không, compiler sẽ warning.
Để skip warning, thêm dấu underscore ở đầu tên biến.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>// The compiler warns about unused variable bindings; these warnings can
// be silenced by prefixing the variable name with an underscore
let _unused_variable = 3u32;

// Skip the result of function
let _ = check_error();
<span class="boring">}
</span></code></pre></pre>
<h2 id="mut"><a class="header" href="#mut"><code>mut</code></a></h2>
<p>Mọi biến trong Rust mặc định là immutable, có nghĩa là không thể thay đổi, 
không thể gán bằng một giá trị khác. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let a = 1;
a = 2;
<span class="boring">}
</span>
// error[E0384]: cannot assign twice to immutable variable `a`
//  --&gt; src/main.rs:4:1
//   |
// 3 | let a = 1;
//   |     -
//   |     |
//   |     first assignment to `a`
//   |     help: consider making this binding mutable: `mut a`
// 4 | a = 2;
//   | ^^^^^ cannot assign twice to immutable variable
</code></pre></pre>
<p>Để có thể thay đổi giá trị của biến, ta thêm từ khóa <code>mut</code> sau <code>let</code>. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a = 1;
a = 2;

println!(&quot;a = {}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<p>Ta cũng có thể khai báo lại biến đó để assign lại giá trị mới:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let a = 1;
let a = a + 1;
<span class="boring">}
</span></code></pre></pre>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>Giá trị của variables có thể được xác định tùy theo scope.
Scope là một tập hợp các dòng code nằm trong <code>{}</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let a = 1;

{
    let a = 2;
    println!(&quot;inner: a = {}&quot;, a); // 2
}

println!(&quot;outer: a = {}&quot;, a); // 1
</code></pre></pre>
<h2 id="return-trong-scope"><a class="header" href="#return-trong-scope">Return trong scope</a></h2>
<p>Ta cũng có thể return giá trị trong một scope cho một variable.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let a = {
    let y = 10;
    let z = 100;

    y + z
};

println!(&quot;a = {}&quot;, a);
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mut-1"><a class="header" href="#mut-1"><code>mut</code></a></h2>
<p>Mọi biến trong Rust mặc định là immutable, có nghĩa là không thể thay đổi, 
không thể gán bằng một giá trị khác. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let a = 1;
a = 2;
<span class="boring">}
</span>
// error[E0384]: cannot assign twice to immutable variable `a`
//  --&gt; src/main.rs:4:1
//   |
// 3 | let a = 1;
//   |     -
//   |     |
//   |     first assignment to `a`
//   |     help: consider making this binding mutable: `mut a`
// 4 | a = 2;
//   | ^^^^^ cannot assign twice to immutable variable
</code></pre></pre>
<p>Để có thể thay đổi giá trị của biến, ta thêm từ khóa <code>mut</code> sau <code>let</code>. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a = 1;
a = 2;

println!(&quot;a = {}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<p>Ta cũng có thể khai báo lại biến đó để assign lại giá trị mới:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let a = 1;
let a = a + 1;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uninitialized-variable"><a class="header" href="#uninitialized-variable">uninitialized variable</a></h1>
<p>Variable mà chưa được gán giá trị được gọi là uninitialized variable.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
  let my_variable; // ⚠️
}
</code></pre></pre>
<p>Rust sẽ không compile và bạn sẽ không thể sử dụng cho đến khi <code>my_variable</code> được gán giá trị nào đó. Ta có thể lợi dụng điều này:</p>
<ul>
<li>Khai báo uninitialized variable.</li>
<li>Gán giá trị cho nó trong 1 scope khác</li>
<li>Vẫn giữ được giá trị của của variable đó khi ra khỏi scope.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
  let my_number;
  {
    my_number = 100;
  }

  println!(&quot;{}&quot;, my_number);
}
</code></pre></pre>
<p>Hoặc phức tạp hơn</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn loop_then_return(mut counter: i32) -&gt; i32 {
  loop {
    counter += 1;
    if counter % 50 == 0 {
      break;
    }
  }

  counter
}

fn main() {
  let my_number;

  {
    // Pretend we need to have this code block
    let number = {
      // Pretend there is code here to make a number
      // Lots of code, and finally:
      57
    };

    my_number = loop_then_return(number);
  }

  println!(&quot;{}&quot;, my_number); // 100
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>Hay còn được gọi là <strong>anonymous functions</strong> hay <strong>lambda functions</strong>.
Khác với function bình thường, kiểu dữ liệu của tham số đầu vào 
và kiểu dữ liệu trả ra là không bắt buộc.</p>
<p>Function bình thường:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_square_value(i: i32) -&gt; i32 {
  i * i
}

fn main() {
  let x = 2;
  println!(&quot;{}&quot;, get_square_value(x));
}
</code></pre></pre>
<p>Closure:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = 2;

  let square = |i: i32| -&gt; i32 {
      i * i
  };

  println!(&quot;{}&quot;, square(x));
}
</code></pre></pre>
<h3 id="closure-không-cần-data-type"><a class="header" href="#closure-không-cần-data-type">Closure không cần data type</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = 2;

  let square = |i| {
    i * i
  };

  println!(&quot;{}&quot;, square(x));
}
</code></pre></pre>
<p>Tham số của của closure được đặt giữa 2 dấu: <code>|</code> và <code>|</code>. </p>
<h3 id="closure-không-có-tham-số"><a class="header" href="#closure-không-có-tham-số">Closure không có tham số</a></h3>
<p>Với closure không có tham số, ta viết như sau: </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func = || { 1 + 1 };
<span class="boring">}
</span></code></pre></pre>
<h3 id="closure-chỉ-có-một-mệnh-đề"><a class="header" href="#closure-chỉ-có-một-mệnh-đề">Closure chỉ có một mệnh đề</a></h3>
<p>Dấu ngoặc <code>{}</code> cũng không bắt buộc nếu nội dung của closure chỉ có một mệnh đề.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func = || 1 + 1;
<span class="boring">}
</span></code></pre></pre>
<h3 id="vừa-định-nghĩa-vừa-thực-thi"><a class="header" href="#vừa-định-nghĩa-vừa-thực-thi">Vừa định nghĩa, vừa thực thi</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = 2;

  let square = |i| -&gt; i32 { // ⭐️ nhưng bắt buộc khai báo return type
    i * i
  }(x);

  println!(&quot;{}&quot;, square);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code> là package management tool official của Rust.</p>
<p><code>cargo</code> có rất nhiều tính năng hữu ích để improve code quality và nâng cao tốc độ của lập trình viên. 
<code>cargo</code> có hẳn một quyển sách riêng: <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a></p>
<p>Những tính năng phổ biến mà bạn sẽ phải dùng hằng ngày:</p>
<ul>
<li><code>cargo add &lt;crate&gt;</code>: cài đặt crate mới từ <a href="https://crates.io">https://crates.io</a>, crate sẽ được thêm vào <code>Cargo.toml</code>.</li>
<li><code>cargo t</code> hoặc <code>cargo test</code>: run mọi tests (unit tests, doc tests, integration tests).</li>
<li><code>cargo fmt</code>: format code.</li>
<li><code>cargo clippy</code>: lint để bắt các lỗi phổ biến trong lập trình, code đẹp hơn, chạy nhanh hơn, etc. <a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-và-crates"><a class="header" href="#packages-và-crates">Packages và Crates</a></h1>
<p><strong>Package</strong> là một hoặc nhiều crates. Một package gồm một file <code>Cargo.toml</code> mô tả cách để build các crates đó.</p>
<p><strong>Crate</strong> có thể là một binary crate hoặc library crate.</p>
<ul>
<li><strong>binary crate</strong> có thể được compile thành binary và có thể thực thi được, ví dụ như một command-line hoặc server. Một binary crate bắt buộc phải có một hàm <code>main()</code></li>
<li><strong>library crate</strong> không cần hàm <code>main()</code>. Library crate dùng để share các tính năng cho các project khác. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-layout"><a class="header" href="#package-layout">Package layout</a></h1>
<p>Được mô tả trong <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">Cargo book</a>, 
một crate trong Rust sẽ có layout như sau:</p>
<pre><code>.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   ├── helper.rs
│   ├── utils/
│   │   ├── mod.rs
│   │   └── math.rs
│   └── bin/
│       ├── named-executable.rs
│       └── another-executable.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench.rs
├── examples/
│   ├── simple.rs
│   └── complex.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code> và <code>Cargo.lock</code> dược đặt ở thư mục gốc của package. Thường để sử dụng các library nào đó, người ta sẽ hướng dẫn bạn thêm một dòng ví dụ <code>log = &quot;0.6&quot;</code> bên dưới section <code>[dependencies]</code> hoặc <code>[dev-dependencies]</code>. Không nên đụng đến file <code>Cargo.lock</code> do nó được generate tự động.</li>
<li>Source code được đặt trong thư mục <code>src</code>.</li>
<li>File chính của library crate là <code>src/lib.rs</code>.</li>
<li>File chính của binary crate là <code>src/main.rs</code>.</li>
<li>Benchmark code được đặt trong thư mục <code>benches</code>.</li>
<li>Code ví dụ (examples) được đặt trong thư mục <code>examples</code>.</li>
<li>Integration tests được đặt trong thư mục <code>tests</code>.</li>
<li><code>helper.rs</code> và <code>utils/</code> được gọi là các module. Nếu module là một thư mục gồm nhiều file khác, file <code>mod.rs</code> được coi như là file index của module đó. Xem thêm về modules <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">tại đây</a>. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate"><a class="header" href="#crate">Crate</a></h1>
<p><strong>Crate</strong> có thể là một binary crate hoặc library crate.</p>
<ul>
<li><strong>binary crate</strong> có thể được compile thành binary và có thể thực thi được, ví dụ như một command-line hoặc server. Một binary crate bắt buộc phải có một hàm <code>main()</code></li>
<li><strong>library crate</strong> không cần hàm <code>main()</code>. Library crate dùng để share các tính năng cho các project khác. </li>
</ul>
<p>Crate được publish trên <a href="https://crates.io">https://crates.io</a>.</p>
<h2 id="init-crate"><a class="header" href="#init-crate">Init crate</a></h2>
<p>Để tạo một crate mới ta sử dụng cargo:</p>
<ul>
<li><code>cargo new crate_name</code>: binary crate.</li>
<li><code>cargo new crate_name --lib</code>: library crate.</li>
</ul>
<h2 id="layout-của-binary-crate-và-library-crate"><a class="header" href="#layout-của-binary-crate-và-library-crate">Layout của <strong>binary crate</strong> và <strong>library crate</strong></a></h2>
<pre><code>// Binary crate

├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<pre><code>// Library crate

├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<p>Một crate có thể vừa có <code>lib.rs</code> và <code>main.rs</code>.</p>
<p>Binary crate khi <code>cargo build</code> hoặc <code>cargo run</code> sẽ build ra một file binary bỏ trong <code>./target/debug/&lt;crate_name&gt;</code>. </p>
<p>Khi build cho môi trường production, ta thêm <code>--release</code> lúc này cargo sẽ build thành binary bỏ trong <code>./target/release/&lt;crate_name&gt;</code>. </p>
<p><code>debug</code> hay <code>release</code> được gọi là các build target. Build trong <code>release</code> sẽ được apply nhiều optimization hơn, kích thước nhỏ hơn, chạy nhanh hơn nhưng compile lâu hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-crate"><a class="header" href="#use-crate">use crate</a></h1>
<p>Để sử dụng (import) một crate từ <a href="https://crates.io">https://crates.io</a>, ví dụ <a href="https://crates.io/crates/log">https://crates.io/crates/log</a>.</p>
<h3 id="1-thêm-crate-vào-cargotoml"><a class="header" href="#1-thêm-crate-vào-cargotoml">1. Thêm crate vào <code>Cargo.toml</code></a></h3>
<p>Có 2 cách</p>
<p><strong>Cách 1:</strong> Edit trực tiếp file <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;
</code></pre>
<p><strong>Cách 2:</strong> Sử dụng <code>cargo add</code>, cargo sẽ tự động update file <code>Cargo.toml</code> cho bạn</p>
<pre><code class="language-bash">cargo add log
</code></pre>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4.17&quot;
</code></pre>
<p>Để thêm crate vào dev dependencies (dùng cho tests), ta thêm <code>--dev</code> vào lệnh:</p>
<pre><code class="language-bash">cargo add --dev log
</code></pre>
<pre><code class="language-toml">[dev-dependencies]
log = &quot;0.4.17&quot;
</code></pre>
<h3 id="2-sử-dụng-crate-trong-code"><a class="header" href="#2-sử-dụng-crate-trong-code">2. Sử dụng crate trong code</a></h3>
<pre><pre class="playground"><code class="language-rust no_run edition2021">fn main() {
    log::info!(&quot;hello&quot;);
    log::error!(&quot;oops&quot;);
}
</code></pre></pre>
<p>Sử dụng keyword <code>use</code>. Chức năng chính của <code>use</code> là bind lại full path 
của element vào một tên mới, để chúng ta không cần phải lặp lại một tên dài mỗi lần sử dụng.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use log::info;
use log::error;

fn main() {
    info!(&quot;hello&quot;);
    error!(&quot;oops&quot;);
}
</code></pre></pre>
<p>Nhóm các import lại với nhau:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use log::{info, error};

fn main() {
    info!(&quot;hello&quot;);
    error!(&quot;oops&quot;);
}
</code></pre></pre>
<p>Import mọi thứ được public trong crate/module. Cách này thường hay tránh bởi 
sẽ khó biết được function, struct, ... nào đó đang thuộc crate nào, ngoại trừ các <code>prelude::*</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use log::*;

fn main() {
    info!(&quot;hello&quot;);
    error!(&quot;oops&quot;);
}
</code></pre></pre>
<h3 id="use-trong-scope"><a class="header" href="#use-trong-scope"><code>use</code> trong scope</a></h3>
<p><code>use</code> cũng thường được sử dụng import element vào trong scope hiện tại.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello() -&gt; String {
  &quot;Hello, world!&quot;.to_string()
}

#[cfg(test)]
mod tests {
  use super::hello; // Import the `hello()` function into the scope
    
  #[test]
  fn test_hello() {
    assert_eq!(&quot;Hello, world!&quot;, hello()); // If not using the above `use` statement, we can run same via `super::hello()`
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Bạn sẽ sẽ hay gặp:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

#[cfg(test)]
mod tests {
  use super::*;
  use log::info;
    
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="self-super"><a class="header" href="#self-super"><code>self::</code>, <code>super::</code></a></h3>
<p>Mặc định thì <code>use</code> sẽ import đường dẫn tuyệt đối, bắt đầu từ crate root.
<code>self</code> và <code>super</code> thường dùng để import mod theo vị trí tương đối.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/level_1/level_2/mod.rs

use self::hello_1;
use super::super::level3::hello_2;
<span class="boring">}
</span></code></pre></pre>
<h3 id="re-export"><a class="header" href="#re-export">Re-export</a></h3>
<p>Một trường hợp đặt biệt là sử dụng <code>pub use</code> là re-exporting, 
khi bạn thiết kế một module bạn có thể export một số thứ từ module khác (*) từ module của bạn. 
Do đó người sử dụng có thể sử dụng các module khác đó ngay từ module của bạn.</p>
<p>Module khác (*) đó có thể là một internal module, internal crate hoặc external crate.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/utils.rs
pub use log::*;

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2021">// src/main.rs
use crate::utils::info;

fn main() {
    info!(&quot;...&quot;);
}
</code></pre></pre>
<p>Pattern này được sử dụng khá nhiều ở các thư viện lớn. 
Nó giúp ẩn đi các internal module phức tạp của library đối với user.
Bởi vì user sẽ không cần quan tâm đến cấu trúc directory phức tạp khi sử dụng một library nào đó.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="self-super-1"><a class="header" href="#self-super-1"><code>self::</code>, <code>super::</code></a></h3>
<p>Mặc định thì <code>use</code> sẽ import đường dẫn tuyệt đối, bắt đầu từ crate root.
<code>self</code> và <code>super</code> thường dùng để import mod theo vị trí tương đối.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/level_1/level_2/mod.rs

use self::hello_1;
use super::super::level3::hello_2;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="re-export-1"><a class="header" href="#re-export-1">Re-export</a></h3>
<p>Một trường hợp đặt biệt là sử dụng <code>pub use</code> là re-exporting, 
khi bạn thiết kế một module bạn có thể export một số thứ từ module khác (*) từ module của bạn. 
Do đó người sử dụng có thể sử dụng các module khác đó ngay từ module của bạn.</p>
<p>Module khác (*) đó có thể là một internal module, internal crate hoặc external crate.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/utils.rs
pub use log::*;

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run edition2021">// src/main.rs
use crate::utils::info;

fn main() {
    info!(&quot;...&quot;);
}
</code></pre></pre>
<p>Pattern này được sử dụng khá nhiều ở các thư viện lớn. 
Nó giúp ẩn đi các internal module phức tạp của library đối với user.
Bởi vì user sẽ không cần quan tâm đến cấu trúc directory phức tạp khi sử dụng một library nào đó.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preludes"><a class="header" href="#preludes"><a href="https://doc.rust-lang.org/std/prelude/">Preludes</a></a></h1>
<p><a href="https://doc.rust-lang.org/std/prelude/">Preludes</a> là những thứ được định nghĩa trong <a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a>,
và được import sẵn, vì chúng thường sẽ phải được dùng trong mọi chương trình Rust. đư
Bạn có thể sử dụng mà không cần phải import, ví dụ như: [<code>Option</code>], 
[<code>Result</code>], [<code>Ok</code>], [<code>Err</code>], ...</p>
<p>Mặc dù <a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a> của Rust có rất nhiều module và tính năng, nhưng không phải mọi thứ đều được preludes.</p>
<p>Đây là danh sách những thứ được preludes: <a href="https://doc.rust-lang.org/std/prelude/#prelude-contents">https://doc.rust-lang.org/std/prelude/#prelude-contents</a></p>
<hr />
<ul>
<li><code>[std::marker]::{[Copy], [Send], [Sized], [Sync], [Unpin]}</code>,
marker traits that indicate fundamental properties of types.</li>
<li><code>[std::ops]::{[Drop], [Fn], [FnMut], [FnOnce]}</code>, various
operations for both destructors and overloading <code>()</code>.</li>
<li><code>[std::mem]::[drop][mem::drop]</code>, a convenience function for explicitly
dropping a value.</li>
<li><code>[std::boxed]::[Box]</code>, a way to allocate values on the heap.</li>
<li><code>[std::borrow]::[ToOwned]</code>, the conversion trait that defines
[<code>to_owned</code>], the generic method for creating an owned type from a
borrowed type.</li>
<li><code>[std::clone]::[Clone]</code>, the ubiquitous trait that defines
[<code>clone</code>][Clone::clone], the method for producing a copy of a value.</li>
<li><code>[std::cmp]::{[PartialEq], [PartialOrd], [Eq], [Ord]}</code>, the
comparison traits, which implement the comparison operators and are often
seen in trait bounds.</li>
<li><code>[std::convert]::{[AsRef], [AsMut], [Into], [From]}</code>, generic
conversions, used by savvy API authors to create overloaded methods.</li>
<li><code>[std::default]::[Default]</code>, types that have default values.</li>
<li><code>[std::iter]::{[Iterator], [Extend], [IntoIterator], [DoubleEndedIterator], [ExactSizeIterator]}</code>,
iterators of various
kinds.</li>
<li><code>[std::option]::[Option]::{[self][Option], [Some], [None]}</code>, a
type which expresses the presence or absence of a value. This type is so
commonly used, its variants are also exported.</li>
<li><code>[std::result]::[Result]::{[self][Result], [Ok], [Err]}</code>, a type
for functions that may succeed or fail. Like [<code>Option</code>], its variants are
exported as well.</li>
<li><code>[std::string]::{[String], [ToString]}</code>, heap-allocated strings.</li>
<li><code>[std::vec]::[Vec]</code>, a growable, heap-allocated vector.</li>
</ul>
<p>The prelude used in Rust 2021, [<code>std::prelude::rust_2021</code>], includes all of the above,
and in addition re-exports:</p>
<ul>
<li><code>[std::convert]::{[TryFrom], [TryInto]}</code>,</li>
<li><code>[std::iter]::[FromIterator]</code>.</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, 
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, 
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>,
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>, ...
[mem::drop]: https://doc.rust-lang.org/std/mem/fn.drop.html
[std::borrow]: https://doc.rust-lang.org/std/borrow
[std::boxed]: https://doc.rust-lang.org/std/boxed
[std::clone]: https://doc.rust-lang.org/std/clone
[std::cmp]: https://doc.rust-lang.org/std/cmp
[std::convert]: https://doc.rust-lang.org/std/convert
[std::default]: https://doc.rust-lang.org/std/default
[std::iter]: https://doc.rust-lang.org/std/iter
[std::marker]: https://doc.rust-lang.org/std/marker
[std::mem]: https://doc.rust-lang.org/std/mem
[std::ops]: https://doc.rust-lang.org/std/ops
[std::option]: https://doc.rust-lang.org/std/option
[std::result]: https://doc.rust-lang.org/std/result
[std::slice]: https://doc.rust-lang.org/std/slice
[std::string]: https://doc.rust-lang.org/std/string
[std::vec]: https://doc.rust-lang.org/std/vec
[TryFrom]: https://doc.rust-lang.org/std/convert/trait.TryFrom.html
[TryInto]: https://doc.rust-lang.org/std/convert/trait.TryInto.html
[FromIterator]: https://doc.rust-lang.org/std/iter/trait.FromIterator.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p><em>Ownership</em> là một trong những tính năng đặc trưng của Rust, đây là cách giúp Rust đảm bảo memory safety mà không cần đến garbage collector.</p>
<h1 id="ownership-là-gì"><a class="header" href="#ownership-là-gì">Ownership là gì?</a></h1>
<p>Ownership là một concept mới. Tất cả programs đều cần phải quản lý
memory mà nó sử dụng trong lúc thực thi. Một vài ngôn ngữ sử dụng
garbage collection để tìm và giải phóng bộ nhớ lúc runtime, một số
ngôn ngữ khác thì lập trình viên phải tự chi định (allocate) và giải
phóng (free) bộ nhớ. Rust đi theo một hướng khác, memory được quản lý
bởi một ownership system gồm tập rules được compiler sử dụng để kiểm
tra (check) lúc compile. Bằng cách này thì Rust ép chúng ta viết code theo một
cách an toàn memory-safe, Rust sẽ bắt lỗi ở lúc complie.
Càng hiểu được concept của ownership, thì dần
dần chúng ta có thể viết được code an toàn và hiệu quả hơn.</p>
<p>Để tìm hiểu kỹ hơn về Ownership, bạn có thể đọc Rust Book tại
đây cực kỳ chi tiết:
<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-rules">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<p>Nói đơn giản về <em>ownership rules</em> thì có một số điều cơ bản sau:</p>
<ul>
<li>Mỗi giá trị trong Rust đều có một biến gọi là owner của nó.</li>
<li>Chỉ có một owner tại một thời điểm.</li>
<li>Khi owner ra khỏi scope, giá trị sẽ bị hủy.</li>
</ul>
<h3 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow checker</a></h3>
<p>Bằng cách theo dõi data sử dụng thông qua bộ rules,
borrow checker có thể xác định khi nào data cần được khởi tạo
(initialized) và khi nào cần được giải phóng (freed, or dropped).<br />
Thực tế sẽ có một trong ba trường hợp sau khi bạn sử dụng variable:
tự move data và bỏ ownership; copy data sang một variable khác;
hoặc sử dụng reference (con trỏ) đến data và vẫn giữ ownership,
cho mượn (borrow) nó một thời gian.</p>
<p>Chỉ cần nhớ hai quy tắc quan trọng:</p>
<ol>
<li>Khi truyền một variable (thay vì reference tới variable) cho một function khác, ta sẽ mất quyền ownership. Function đó sẽ là owner của variable này và bạn không thể sử dụng lại được nữa ở context cũ.</li>
<li>Khi truyền một reference tới variable, bạn có thể <strong>immutable</strong> borrow không giới hạn; hoặc <strong>mutable</strong> borrow một lần.</li>
</ol>
<p>Ví dụ: đoạn chương trình sau sẽ không compile được</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail should_panic edition2021">fn hold_my_vec&lt;T&gt;(_: Vec&lt;T&gt;) {}

fn main() {
  let x = vec![1, 2, 3];
  hold_my_vec(x);

  let z = x.get(0);
  println!(&quot;Got: {:?}&quot;, z);
}
</code></pre></pre>
<p>Compiler sẽ báo lỗi như sau: <code>rustc main.rs</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">error[E0382]: borrow of moved value: `x`
    --&gt; main.rs:7:13
  |
4 |  let x = vec![1, 2, 3];
  |      - move occurs because `x` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5 |  hold_my_vec(x);
  |              - value moved here
6 |
7 |  let z = x.get(0);
  |          ^^^^^^^^ value borrowed here after move
  |
  = note: borrow occurs due to deref coercion to `[i32]`
</code></pre></pre>
<p>Lỗi nói rằng <code>Vec&lt;i32&gt;</code> không implement
<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy trait</a>,
vì thế data sẽ được di chuyển (move) hoặc mượn (borrow) vào function
<code>hold_my_vec()</code>. Do đó dòng 7 không thể thực hiện được do <code>x</code> được
được move vào trong function kia.</p>
<p>Mặc dùng không thể implement <code>Copy</code> trait, <code>Vec</code> vẫn có
<a href="https://doc.rust-lang.org/core/clone/trait.Clone.html">Clone trait</a>.
Chỉ để cho code chạy được thì đây là một cách nhanh để compiler ngưng báo lỗi.
Lưu ý thì việc clone thường sẽ tốn khá nhiều chi phí, nhất là đối với những object lớn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn hold_my_vec&lt;T&gt;(_: Vec&lt;T&gt;) {}

fn main() {
  let x = vec![1, 2, 3];
  hold_my_vec(x.clone()); // &lt;-- x.clone()

  let z = x.get(0);
  println!(&quot;Got: {:?}&quot;, z);
}
</code></pre></pre>
<p>Trong trường hợp này thì function <code>hold_my_vec</code> không làm gì ngoài
việc take ownership. Có một cách tốt hơn là <strong>references.</strong> Thay vì
để function take ownership, ta có thể cho nó mượn giá trị.
Chúng ta sẽ truyền vào một reference — a borrowed value.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn hold_my_vec&lt;T&gt;(_: &amp;Vec&lt;T&gt;) {}

fn main() {
  let x = vec![1, 2, 3];
  hold_my_vec(&amp;x); // &lt;--- &amp;x

  let z = x.get(0);
  println!(&quot;Got: {:?}&quot;, z);
}
</code></pre></pre>
<p>Với cách này thì chúng ta sẽ để function mượn trong khi
vẫn có thể tiếp tục sử sử dụng trong chương trình.</p>
<p>Bạn có thể đọc thêm về <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a>,
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing">References and Borrowing</a> và
<a href="https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type">The Slice Type</a> tại the Rust Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<p>Struct được sử dụng trong Rust rất nhiều, hầu như là mọi lúc. Với struct ta có thể định nghĩa một kiểu dữ liệu riêng.</p>
<p>Tên của struct thường là <code>UpperCamelCase</code>. Nếu bạn định nghĩa tên struct là lowercase, compiler sẽ nhắc nhở ngay.</p>
<pre><code class="language-bash">warning: type `duyet_struct` should have an upper camel case name
 --&gt; src/main.rs:1:8
  |
1 | struct duyet_struct;
  |        ^^^^^^^^^^^^ help: convert the identifier to upper camel case: `DuyetStruct`
  |
  = note: `#[warn(non_camel_case_types)]` on by default
</code></pre>
<p>Có 3 loại struct:</p>
<h1 id="unit-struct"><a class="header" href="#unit-struct">Unit struct</a></h1>
<p>Unit struct là một struct mà không có gì cả:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct FileDirectory;
fn main() {} 
</code></pre></pre>
<h1 id="tuple-struct"><a class="header" href="#tuple-struct">Tuple struct</a></h1>
<p>Tuple struct hay còn gọi là Unnamed struct. Bạn chỉ cần định nghĩa kiểu dữ liệu, không cần định tên field name.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Colour(u8, u8, u8);

fn main() {
  let my_colour = Colour(50, 0, 50); // Make a colour out of RGB (red, green, blue)

  println!(&quot;The first part of the colour is: {}&quot;, my_colour.0);
  println!(&quot;The second part of the colour is: {}&quot;, my_colour.1);
}

// The first part of the colour is: 50
// The second part of the colour is: 0
</code></pre></pre>
<h1 id="named-struct"><a class="header" href="#named-struct">Named struct</a></h1>
<p>Phổ biến nhất, bạn sẽ phải định nghĩa field name trong block <code>{}</code> </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
  size: u32,
  colour: Colour, // And we put it in our new named struct
		  // The last comma is optional, but recommended
}

fn main() {
  let colour = Colour(50, 0, 50);

  let size_and_colour = SizeAndColour {
    size: 150,
    colour: colour
  };
}
</code></pre></pre>
<p><code>colour: colour</code> có thể được viết gọn lại thành:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let size_and_colour = SizeAndColour {
  size: 150,
  colour
};
</code></pre></pre>
<p>Xem về <a href="basic/./trait.html">Trait</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p>Rust có nhiều loại data types như primitives (<code>i8</code>, <code>i32</code>, <code>str</code>, ...), struct, enum và các loại kết hợp (aggregate) như tuples và array. Mọi types không có mối liên hệ nào với nhau. Các data types có các phương thức (methods) để tính toán hay convert từ loại này sang loại khác, nhưng chỉ để cho tiện lợi hơn, method chỉ là các function. Bạn sẽ làm gì nếu một tham số là nhiều loại kiểu dữ liệu? Một số ngôn ngữ như Typescript hay Python sẽ có cách sử dụng Union type như thế này:</p>
<pre><code class="language-typescript">function notify(data: string | number) {
  if (typeof data == &quot;number&quot;) {
    // ...
  } else if (typeof data == &quot;number&quot;) {
    // ...
  }
}
</code></pre>
<p>Còn trong Rust thì sao?</p>
<p><img src="https://i.imgur.com/ZKHSRQK.png" alt="Trait implementations for Display" /></p>
<h1 id="trait-là-gì"><a class="header" href="#trait-là-gì">Trait là gì?</a></h1>
<p>Có thể bạn đã thấy qua trait rồi: <code>Debug</code>, <code>Copy</code>, <code>Clone</code>, ... là các trait.</p>
<p>Trait là một cơ chế abstract để thêm các tính năng (functionality) hay hành vi (behavior) 
khác nhau vào các kiểu dữ liệu (types) và tạo nên các mối quan hệ giữa chúng.</p>
<p>Trait thường đóng 2 vai trò:</p>
<ol>
<li>Giống như là interfaces trong Java hay C# (fun fact: lần đầu tiên nó được gọi là <code>interface</code>). Ta có thể kế thừa (inheritance) interface, nhưng không kế thừa được implementation của interface*.* Cái này giúp Rust có thể hỗ trợ <a href="https://stevedonovan.github.io/rust-gentle-intro/object-orientation.html">OOP</a>. Nhưng có một chút khác biệt, nó không hẳn là interface.</li>
<li>Vai trò này phổ biến hơn, trait đóng vai trò là generic constraints. Dễ hiểu hơn, ví dụ, bạn định nghĩa một function, tham số là một <em>kiểu dữ liệu bất kỳ</em> nào đó, không quan tâm, miễn sau kiểu dữ liệu đó phải có phương thức <code>method_this()</code>, <code>method_that()</code> nào đó cho tui. <em>Kiểu dữ liệu nào đó</em> gọi là <em>genetic type</em>. Function có chứa tham số generic type đó được gọi là <em>generic function</em>. Và việc ràng buộc phải có <code>method_this()</code>, <code>method_that()</code> , ... gọi là <em>generic constraints</em>. Mình sẽ giải thích rõ cùng với các ví dụ sau dưới đây.</li>
</ol>
<p>Để gắn một trait vào một type, bạn cần implement nó. 
Bởi vì <code>Debug</code> hay <code>Copy</code> quá phổ biến, nên Rust có attribute để tự động implement:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct MyStruct {
  number: usize,
}
</code></pre></pre>
<p>Nhưng một số trait phức tạp hơn bạn cần định nghĩa cụ thể 
bằng cách <code>impl</code> nó. Ví dụ bạn có trait <code>Add</code> 
(<a href="https://doc.rust-lang.org/std/ops/trait.Add.html#implementors">std::ops::Add</a>) 
để add 2 type lại với nhau. Nhưng Rust sẽ không biết cách bạn add 2 
type đó lại như thế nào, bạn cần phải tự định nghĩa:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::Add;

struct MyStruct {
  number: usize,
}

impl Add for MyStruct {    // &lt;-- here
  type Output = Self;
  fn add(self, other: Self) -&gt; Self {
    Self { number: self.number + other.number }
  }
}

fn main() {
  let a1 = MyStruct { number: 1 };
  let a2 = MyStruct { number: 2 };
  let a3 = MyStruct { number: 3 };

  assert_eq!(a1 + a2, a3);
}
</code></pre></pre>
<p>Note: Mình sẽ gọi <strong>Define Trait</strong> là việc định nghĩa, 
khai báo một trait mới trong Rust (<code>trait Add</code>). 
<strong>Implement Trait</strong> là việc khai báo nội dung của function được 
liệu kê trong Trait cho một kiểu dữ liệu cụ thể nào đó (<code>impl Add for MyStruct</code>).</p>
<h1 id="Định-nghĩa-một-trait"><a class="header" href="#Định-nghĩa-một-trait">Định nghĩa một Trait</a></h1>
<p>Nhắc lại là Trait định nghĩa các hành vi (behavior). 
Các types khác nhau có thể chia sẻ cùng cá hành vi. 
Định nghĩa một trait giúp <strong>nhóm</strong> các hành vi để làm một việc gì đó.</p>
<p>Theo ví dụ của Rust Book, ví dụ ta các struct chứa nhiều loại text:</p>
<ul>
<li><code>NewsArticle</code> struct chứa news story, và</li>
<li><code>Tweet</code> struct có thể chứa tối đa 280 characters cùng với metadata.</li>
</ul>
<p>Bây giờ chúng ta cần viết 1 crate name có tên là <code>aggregator</code> 
có thể hiển thị summaries của data có thể store trên <code>NewsArticle</code> 
hoặc <code>Tweet</code> instance. Chúng ta cần định nghĩa method <code>summarize</code> 
trên mỗi instance. Để định nghĩa một trait, ta dùng <code>trait</code> theo sau 
là trait name; dùng keyword <code>pub</code> nếu định nghĩa một public trait.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String;
}
</code></pre></pre>
<p>Trong ngoặc, ta định nghĩa các method signatures để định nghĩa hành vi: 
<code>fn summarize(&amp;self) -&gt; String</code>. Ta có thể định nghĩa nội dung của function. 
Hoặc không, ta dùng <code>;</code> kết thúc method signature, để bắt buộc type nào 
implement <code>trait Summary</code> đều phải định nghĩa riêng cho nó, 
bởi vì mỗi type (<code>NewsArticle</code> hay <code>Tweet</code>) đều có cách riêng để <code>summarize</code>. Mỗi trait có thể có nhiều method.</p>
<h1 id="implement-trait-cho-một-type"><a class="header" href="#implement-trait-cho-một-type">Implement Trait cho một Type</a></h1>
<p>Bây giờ ta định implement các method của trait Summary cho từng type. 
Ví dụ dưới đây ta có <code>struct NewsArticle</code> và <code>struct Tweet</code>, 
và ta định nghĩa <code>summarize</code> cho 2 struct này.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
  pub headline: String,
  pub location: String,
  pub author: String,
  pub content: String,
}

impl Summary for NewsArticle {
  fn summarize(&amp;self) -&gt; String {
    format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
  }
}

pub struct Tweet {
  pub username: String,
  pub content: String,
  pub reply: bool,
  pub retweet: bool,
}

impl Summary for Tweet {
  fn summarize(&amp;self) -&gt; String {
    format!(&quot;{}: {}&quot;, self.username, self.content)
  }
}
</code></pre></pre>
<p>Implement trait cho type giống như <code>impl</code> bình thường, 
chỉ có khác là ta thêm <strong>trait name</strong> và keyword <code>for</code> sau <code>impl</code>. 
Bây giờ Summary đã được implement cho <code>NewsArticle</code> và <code>Tweet</code>, 
người sử dụng crate đã có thể sử dụng các phương thức của trait như các method function bình thường. 
Chỉ một điều khác biệt là bạn cần mang trait đó vào cùng scope hiện tại cùng với type để có thể sử dụng. 
Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use aggregator::{Summary, Tweet}; // &lt;-- same scope

fn main() {
  let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
  };
  
  println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
  // 1 new tweet: horse_ebooks: of course, as you probably already know, people
}
</code></pre></pre>
<p>Rust Playground: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dc563051aecebae4344776c06fb1b49d">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dc563051aecebae4344776c06fb1b49d</a></p>
<p>Chúng ta có thể implement trait cho mọi type khác bất kỳ, ví dụ implement <code>Summary</code> cho <code>Vec&lt;T&gt;</code> trong scope của crate hiện tại.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String;
}

impl&lt;T&gt; Summary for Vec&lt;T&gt; {    // &lt;-- local scope
  fn summarize(&amp;self) -&gt; String {
    format!(&quot;There are {} items in vec&quot;, self.len())
  }
}

fn main() {
  let vec = vec![1i32, 2i32];
  println!(&quot;{}&quot;, vec.summarize());
  // There are 2 items in vec
}
</code></pre></pre>
<p>Rust Playground: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dcaa812fab222ec0c713a38b066bda20">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dcaa812fab222ec0c713a38b066bda20</a></p>
<p>Bạn sẽ không thể implement external traits trên external types. 
Ví dụ ta không thể implement <code>Display</code> cho <code>Vec&lt;T&gt;</code> bởi vì 
<code>Display</code> và <code>Vec&lt;T&gt;</code> được định nghĩa trong standard library, 
trong trong crate hiện tại. Rule này giúp tránh chống chéo và chắc chắn 
rằng không ai có thể break code của người khác và ngược lại.</p>
<h1 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h1>
<p>Đôi khi bạn cần có default behavior mà không cần phải implement content cho từng type mỗi khi cần sử dụng:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String {
    String::from(&quot;(Read more...)&quot;)
  }
}

pub struct NewsArticle {
  pub headline: String,
  pub location: String,
  pub author: String,
  pub content: String,
}

impl Summary for NewsArticle {}; // &lt;-- sử dụng {}

fn main() {
  let article = NewsArticle { ... };
  println!(&quot;New article: {}&quot;, article.summarize());
  // New article: (Read more...)
}
</code></pre></pre>
<h1 id="traits-as-parameters"><a class="header" href="#traits-as-parameters">Traits as Parameters</a></h1>
<p>Trở lại ví dụ Typescript ở đầu tiên, với Trait bạn đã có thể define 
một function chấp nhận tham số là nhiều kiểu dữ liệu khác nhau. 
Nói theo một cách khác, bạn không cần biết kiểu dữ liệu, 
bạn cần biết kiểu dữ liệu đó mang các behavior nào thì đúng hơn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn notify(data: &amp;impl Summary) {
  println!(&quot;News: {}&quot;, data.summarize());
}

fn main() {
  let news = NewsArticle {};
  notify(news);
}
</code></pre></pre>
<p>Ở đây, thay vì cần biết <code>data</code> là type nào (<code>NewsArticle</code> hay <code>Tweet</code>?), 
ta chỉ cần cho Rust compiler biết là <code>notify</code> sẽ chấp nhận mọi 
<strong>type có implement</strong> <code>trait Summary</code>, mà trait Summary có behavior <code>.summarize()</code>, 
do đó ta có thể sử dụng method <code>.summary()</code> bên trong function.</p>
<h1 id="trait-bound"><a class="header" href="#trait-bound">Trait Bound</a></h1>
<p>Một syntax sugar khác mà ta có thể sử dụng thay cho <code>&amp;impl Summary</code> ở trên, 
gọi là <em>trait bound</em>, bạn sẽ bắt gặp nhiều trong Rust document:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
  println!(&quot;News: {}&quot;, item.summarize());
}
</code></pre></pre>
<p>Đầu tiên chúng ta định nghĩa trait bound bằng cách định nghĩa 
một generic type parameter trước, sau đó là <code>:</code> trong ngoặc <code>&lt;</code> và <code>&gt;</code>. 
Ta có thể đọc là: <code>item</code> có kiểu generic là <code>T</code> và <code>T</code> phải được <code>impl Summary</code>.</p>
<ul>
<li><code>notify&lt;T&gt;(</code> khai báo generic type <code>T</code></li>
<li><code>notify&lt;T: Summary&gt;(</code> generic type được implement <code>trait Summary</code></li>
</ul>
<p>Cú pháp này có thể dài hơn và không dễ đọc như <code>&amp;impl Summary</code>, nhưng hãy xem ví dụ dưới đây:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {}  // (1)
pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {}            // (2)
</code></pre></pre>
<p>Dùng <em>trait bound</em> giúp ta tái sử dụng lại <code>T</code>, 
mà còn giúp force <code>item1</code> và <code>item2</code> có cùng kiểu dữ liệu, 
đây là cách duy nhất (cả 2 đều là <code>NewsArticle</code> hoặc cả 2 đều là <code>Tweet</code>) mà (1) không thể.</p>
<h1 id="specifying-multiple-trait-bounds-with-the--syntax"><a class="header" href="#specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the + Syntax</a></h1>
<p>Ta có cú pháp <code>+</code> nếu muốn generic <code>T</code> có được impl nhiều trait khác nhau. 
Ví dụ ta muốn <code>item</code> phải có cả <code>Summary</code> lẫn <code>Display</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn notify(item: &amp;(impl Summary + Display)) {}
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}
</code></pre></pre>
<h1 id="where-clauses"><a class="header" href="#where-clauses"><code>where</code> Clauses</a></h1>
<p>Đôi khi bạn sẽ có nhiều genenic type, mỗi generic type lại có nhiều trait bound,
khiến code khó đọc. Rust có một cú pháp <code>where</code> cho phép định nghĩa trait bound 
phía sau function signature. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre></pre>
<p>Với <code>where</code> clause:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
	  U: Clone + Debug,
{
</code></pre></pre>
<h1 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></h1>
<p>Chúng ta cũng có thể sử dụng <code>impl Trait</code> cho giá trị được trả về của function.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;ahihi&quot;),
        reply: false,
        retweet: false,
    }
}
</code></pre></pre>
<p>Được đọc là: function <code>returns_summarizable()</code> trả về bất kỳ kiểu dữ liệu nào có <code>impl Summary</code>. 
Tuy nhiên bạn chỉ có thể return về hoặc <code>Tweet</code> 
hoặc <code>NewsArticle</code> do cách implement của compiler. Code sau sẽ có lỗi:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch { NewsArticle {} }
		else { Tweet {} }
}
</code></pre></pre>
<p>Rust Book có một chương riêng để xử lý vấn đề này: <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">Chapter 17: Using Trait Objects That Allow for Values of Different Types</a></p>
<h1 id="using-trait-bounds-to-conditionally-implement-methods"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></h1>
<p>Ta có thể implement 1 method có điều kiện cho bất kỳ type nào 
có implement một trait khác cụ thể. Ví dụ để dễ hiểu hơn dưới đây:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

struct Pair&lt;T&gt; {
  x: T,
  y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
  fn new(x: T, y: T) -&gt; Self {
    Self { x, y }
  }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
  fn cmp_display(&amp;self) {
    if self.x &gt;= self.y {
      println!(&quot;The largest member is x = {}&quot;, self.x);
    } else {
      println!(&quot;The largest member is y = {}&quot;, self.y);
    }
  }
}
</code></pre></pre>
<p><code>impl&lt;T&gt; Pair&lt;T&gt;</code> implement function <code>new</code> trả về kiểu dữ liệu <code>Pair&lt;T&gt;</code> với <code>T</code> là generic (bất kỳ kiểu dữ liệu nào.</p>
<p><code>impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt;</code> implement function <code>cmp_display</code> 
cho mọi generic <code>T</code> với <code>T</code> đã được implement <code>Display + PartialOrd</code> 
trước đó rồi (do đó mới có thể sử dụng các behavior của 
<code>Display</code> (<code>println!(&quot;{}&quot;)</code>) và <code>PartialOrd</code> (<code>&gt;</code>, <code>&lt;</code>, ...) được.</p>
<h1 id="blanket-implementations"><a class="header" href="#blanket-implementations">Blanket implementations</a></h1>
<p>Ta cũng có thể implement 1 trait có điều kiện cho bất kỳ kiểu dữ liệu 
nào có implement một trait khác rồi. Implementation của một trait cho 
1 kiểu dữ liệu khác thỏa mãn trait bound được gọi là <em>blanket implementations</em> 
và được sử dụng rộng rãi trong Rust standard library. 
Hơi xoắn não nhưng hãy xem ví dụ dưới đây.</p>
<p>Ví dụ: <code>ToString</code> trait trong 
<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#2390">Rust standard library</a>, 
nó được implement cho mọi kiểu dữ liệu nào có được implement <code>Display</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl&lt;T: Display&gt; ToString for T {
  // --snip--
}
</code></pre></pre>
<p>Có nghĩa là, với mọi type có <code>impl Display</code>, ta có hiển nhiên thể sử dụng được các thuộc tính của <code>trait ToString</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let s = 3.to_string(); // do 3 thoaỏa manãn Display
</code></pre></pre>
<p>Do <code>3</code> thỏa mãn điều kiện là đã được <code>impl Display for i32</code>. 
(<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html#impl-Display-11">https://doc.rust-lang.org/std/fmt/trait.Display.html#impl-Display-11</a>)</p>
<h1 id="trait-inheritance"><a class="header" href="#trait-inheritance">Trait Inheritance</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait B: A {}
</code></pre></pre>
<p>Cái này không hẳn gọi là <em>Trait Inheritance</em>, cái này đúng hơn gọi là &quot;cái nào implement cái <code>B</code> thì cũng nên implement cái <code>A</code>&quot;. <code>A</code> và <code>B</code> vẫn là 2 trait độc lập nên vẫn phải implemenet cả 2.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl B for Z {}
impl A for Z {}
</code></pre></pre>
<p>Inheritance thì không được khuyến khích sử dụng.</p>
<h1 id="kết"><a class="header" href="#kết">Kết</a></h1>
<p>Compiler sử dụng trait bound để kiểm tra các kiểu dữ liệu được sử dụng trong code có đúng behavior không. 
Trong Python hay các ngôn ngữ dynamic typed khác, ta sẽ gặp lỗi lúc runtime nếu chúng ta gọi các method mà 
kiểu dữ liệu đó không có hoặc không được định nghĩa.</p>
<p>Bạn có chắc chắn là <code>a</code> dưới đây có method <code>summarize()</code> hay không? 
Nhớ rằng typing hint của Python3 chỉ có tác dụng là nhắc nhở cho lập trình viên thôi.</p>
<pre><code class="language-python"># Python
func print_it(a: Union[NewsArticle, Tweet]):
  print(a.summarize())

print_it(1)
print_it(&quot;what&quot;)
</code></pre>
<p>Do đó Rust bắt được mọi lỗi lúc compile time và force chúng ta phải fix hết trước khi chương trình chạy. 
Do đó chúng ta không cần phải viết thêm code để kiểm tra behavior (hay sự tồn tại của method) 
trước khi sử dụng lúc runtime nữa, tăng cường được performance mà không phải từ bỏ tính flexibility của generics.</p>
<p>Xem về <a href="basic/trait/./struct.html">Struct</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h1>
<p>Rust không có khái niệm &quot;kế thừa&quot; như trong OOP. 
Nhưng bạn có thể định nghĩa một trait là một tập hợp của các trait khác.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Person {
  fn name(&amp;self) -&gt; String;
}

// Person là một supertrait của Student.
// Implement Student yêu cầu bạn phải cũng phải impl Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) là một subtrait 
// của cả Programmer và Student. 
//
// Implement CompSciStudent yêu cầu bạn phải impl tất cả supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-clone"><a class="header" href="#copy-clone">Copy, Clone</a></h1>
<p>Có một số kiểu dữ liệu trong Rust rất đơn giản (simple types),
bao gồm integers, floats, booleans (<code>true</code> và <code>false</code>), và <code>char</code>.
Các simple types này nằm trên stack bởi vì complier biết chính xác size của nó.
Chúng được gọi là <strong>copy types</strong>. Bởi vì nó simple và nhỏ gọn nên dễ dàng để copy,
do đó compiler luôn copy nếu bạn bỏ nó vào function.</p>
<p>Làm sao để biết đọc một kiểu dữ liệu có được <strong>implement Copy</strong> hay không.
Bạn có thể xem trong Rust document. Ví dụ <code>char</code>:
<a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>Nếu bạn thấy:</p>
<ul>
<li><strong>Copy</strong>: có thể được copy nếu bạn bỏ nó vào function.</li>
<li><strong>Display:</strong> bạn có thể sử dụng <code>{}</code> để print.</li>
<li><strong>Debug:</strong> bạn có thể sử dụng <code>{:?}</code> để print.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_number(number: i32) {
  println!(&quot;{}&quot;, number);
}

fn main() {
  let my_number = 8;
  prints_number(my_number); // Prints 8. prints_number gets a copy of my_number
  prints_number(my_number); // Prints 8 again.
                            // No problem, because my_number is copy type!
}
</code></pre></pre>
<p>Do <code>i32</code> được Copy nên chúng ta có thể sử dụng <code>my_number</code> nhiều lần mà không cần borrow <code>&amp;</code> như struct.</p>
<h1 id="clone-trait"><a class="header" href="#clone-trait">Clone trait</a></h1>
<p>Nếu bạn đọc document của String: <a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p><img src="basic/trait//media/2022/02/duyet-clone-trait.png" alt="" /></p>
<p>String không được implement <strong>Copy</strong>, thay vào đó là <strong>Clone</strong>. Clone cũng giúp copy giá trị nhưng sẽ cần rất nhiều memory, và ta phải tự gọi method <code>.clone()</code> chứ Rust sẽ không tự Clone.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: String) {
  println!(&quot;{}&quot;, country_name);
}

fn main() {
  let country = String::from(&quot;Duyet&quot;);
  prints_country(country);
  prints_country(country); // ⚠️
}
</code></pre></pre>
<p>Sẽ báo lỗi, theo như compiler giải thích rằng <code>country</code> là <code>String</code> và không được implement <code>Copy</code> nên country bị move vào trong function. Do đó ta không thể sử dụng <code>country</code> được nữa.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">error[E0382]: use of moved value: `country`
 --&gt; src/main.rs:8:20
  |
6 | let country = String::from(&quot;Duyet&quot;);
  |     ------- move occurs because `country` has type `String`, which does not implement the `Copy` trait
7 | prints_country(country);
  |                ------- value moved here
8 | prints_country(country); // ⚠️
  |                ^^^^^^^ value used here after move

For more information about this error, try `rustc --explain E0382`.
</code></pre></pre>
<p>Có hai cách:</p>
<h3 id="1-sử-dụng-clone"><a class="header" href="#1-sử-dụng-clone">(1) Sử dụng <code>.clone()</code></a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: String) {
  println!(&quot;{}&quot;, country_name);
}

fn main() {
  let country = String::from(&quot;Duyet&quot;);
  prints_country(country.clone()); // &lt;-- clone
  prints_country(country);
}
</code></pre></pre>
<p>String rất lớn, do đó <code>.copy()</code> sẽ tốn rất nhiều bộ nhớ. Sử dụng <code>&amp;</code> để reference sẽ nhanh hơn, nếu có thể.</p>
<h3 id="2-sử-dụng--reference"><a class="header" href="#2-sử-dụng--reference">(2) Sử dụng <code>&amp;</code> reference</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: &amp;String) {
  println!(&quot;{}&quot;, country_name);
}

fn main() {
  let country = String::from(&quot;Duyet&quot;);
  prints_country(&amp;country);
  prints_country(&amp;country);
}
</code></pre></pre>
<h1 id="bonus-string-và-str"><a class="header" href="#bonus-string-và-str">Bonus: <code>String</code> và <code>&amp;str</code></a></h1>
<p>Nếu bạn có một <code>String</code> và <code>&amp;</code> reference, Rust sẽ convert nó thành <code>&amp;str</code> khi bạn cần.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: &amp;str) {
  println!(&quot;{}&quot;, country_name);
}

fn main() {
  let country = String::from(&quot;Duyet&quot;);
  prints_country(&amp;country);
  prints_country(&amp;country);
}
</code></pre></pre>
<p><code>&amp;str</code> là một kiểu hơi phức tạp. </p>
<ul>
<li>Nó có thể vừa là String literals <code>let s = &quot;I am &amp;str&quot;;</code>. Trường hợp này <code>s</code> có kiểu <code>&amp;'static</code> bởi vì nó được ghi trực tiếp vào binary. </li>
<li><code>&amp;str</code> cũng có thể là borrowed của <code>str</code> hoặc <code>String</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bonus-string-và-str-1"><a class="header" href="#bonus-string-và-str-1">Bonus: <code>String</code> và <code>&amp;str</code></a></h1>
<p>Nếu bạn có một <code>String</code> và <code>&amp;</code> reference, Rust sẽ convert nó thành <code>&amp;str</code> khi bạn cần.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: &amp;str) {
  println!(&quot;{}&quot;, country_name);
}

fn main() {
  let country = String::from(&quot;Duyet&quot;);
  prints_country(&amp;country);
  prints_country(&amp;country);
}
</code></pre></pre>
<p><code>&amp;str</code> là một kiểu hơi phức tạp. </p>
<ul>
<li>Nó có thể vừa là String literals <code>let s = &quot;I am &amp;str&quot;;</code>. Trường hợp này <code>s</code> có kiểu <code>&amp;'static</code> bởi vì nó được ghi trực tiếp vào binary. </li>
<li><code>&amp;str</code> cũng có thể là borrowed của <code>str</code> hoặc <code>String</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromstr"><a class="header" href="#fromstr"><code>FromStr</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">FromStr</a> 
là một trait để khởi tạo instance từ string trong Rust, 
nó tương đương abstract class nếu bạn có background OOP.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait FromStr {
  type Err;
  fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
</code></pre></pre>
<p>Thường phương thức <code>from_str</code> của <code>FromStr</code> thường được ngầm định 
sử dụng thông qua phương thức 
<a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.parse">parse</a> 
của <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Thay vì
let one = u32::from_str(&quot;1&quot;);

// thì sử dụng phương thức parse
let one: u32 = &quot;1&quot;.parse().unwrap();
assert_eq!(1, one);

// parse() sử dụng turbofish ::&lt;&gt;
let two = &quot;2&quot;.parse::&lt;u32&gt;(); 
assert_eq!(Ok(2), two);

let nope = &quot;j&quot;.parse::&lt;u32&gt;();
assert!(nope.is_err());
</code></pre></pre>
<p><code>parse</code> là một phương thức general nên thường được sử dụng với kiểu dữ liệu
như trên hoặc sử dụng <a href="basic/trait/./turbofish.html">turbofish</a> <code>::&lt;&gt;</code> để thuật toán inference
có thể hiểu để parse thành đúng kiểu bạn cần.</p>
<h1 id="parse-str-to-struct"><a class="header" href="#parse-str-to-struct">Parse <code>str</code> to <code>Struct</code></a></h1>
<p>Bạn có 1 struct và muốn parse 1 str thành struct đó, bạn sẽ cần impl trait <code>FromStr</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;
use std::num::ParseIntError;

#[derive(Debug, PartialEq)]
struct Point {
  x: i32,
  y: i32
}

impl FromStr for Point {
  type Err = ParseIntError;

  fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
    let coords: Vec&lt;&amp;str&gt; = s.trim_matches(|p| p == '(' || p == ')' )
                               .split(',')
                               .collect();

    let x_fromstr = coords[0].parse::&lt;i32&gt;()?;
    let y_fromstr = coords[1].parse::&lt;i32&gt;()?;

    Ok(Point { x: x_fromstr, y: y_fromstr })
  }
}

// Có nhiều cách
let p: Point = &quot;(1,2)&quot;.parse();
let p = &quot;(1,2)&quot;.parse::&lt;Point&gt;();
let p = Point::from_str(&quot;(1,2)&quot;);

assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )
</code></pre></pre>
<h1 id="parse-str-to-enum"><a class="header" href="#parse-str-to-enum">Parse <code>str</code> to <code>Enum</code></a></h1>
<p>Một điều mình nhận thấy để code dễ đọc, dễ maintain hơn là 
ta nên sử dụng Enum thay cho string để so sánh giá trị. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn print(color: &amp;str, text: &amp;str) { ... }
print(&quot;Foobar&quot;, &quot;blue&quot;);
</code></pre></pre>
<p>Thay vì đó mà hãy sử dụng enum:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Color { Red, Green, CornflowerBlue }

fn print(color: Color, text: &amp;str) { ... }
print(Green, &quot;duyet&quot;);
</code></pre></pre>
<p>Cũng nên hạn chế sử dụng quá nhiều Boolean, thực tế Boolean cũng chỉ là 1 enum</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum bool { true, false }
</code></pre></pre>
<p>Thay vào đó hãy tự định nghĩa enum cho các ngữ cảnh khác nhau để code dễ đọc hơn:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum EnvVars { Clear, Inherit }
enum DisplayStyle { Color, Monochrome } 
</code></pre></pre>
<p>Chúng ta implement <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">std::str::FromStr</a> trait như sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;

#[derive(Debug, PartialEq)]
enum Color {
  Red,
  Green,
  Blue
}

impl FromStr for Color {
  type Err = ();

  fn from_str(input: &amp;str) -&gt; Result&lt;Color, Self::Err&gt; {
    match input {
      &quot;red&quot;   =&gt; Ok(Color::Red),
      &quot;green&quot; =&gt; Ok(Color::Green),
      &quot;blue&quot;  =&gt; Ok(Color::Blue),
      _       =&gt; Err(()),
    }
  }
}

let c: Color = &quot;red&quot;.parse().unwrap();
assert_eq!(c, Color::Red);
</code></pre></pre>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<ul>
<li><a href="basic/trait/./trait.html">Trait</a></li>
<li><a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.parse">https://doc.rust-lang.org/nightly/std/primitive.str.html#method.parse</a></li>
<li><a href="https://doc.rust-lang.org/nightly/std/str/trait.FromStr.html">https://doc.rust-lang.org/nightly/std/str/trait.FromStr.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Giống như các ngôn ngữ khác, Enum là một kiểu giá trị đơn, chứa các biến thể (variants).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}

let today = Day::Sunday;
<span class="boring">}
</span></code></pre></pre>
<p>Enum variant có thể là</p>
<ul>
<li>unit variant</li>
<li>tuple variant</li>
<li>struct variant</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FlashMessage {
  Success, // unit variant
  Error(String), // tuple variant
  Warning { category: i32, message: String }, // struct variant
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="match-enum"><a class="header" href="#match-enum">match Enum</a></h1>
<p><code>match</code> cực kỳ mạnh và được dùng trong Rust phổ biến.</p>
<p>Ví dụ sau là cách để kiểm tra một giá trị enum là variant nào.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Coin::Penny =&gt; 1,
    Coin::Nickel =&gt; 5,
    Coin::Dime =&gt; 10,
    Coin::Quarter =&gt; 25,
  }
}

fn main() {}
</code></pre></pre>
<p><code>match</code> còn có thể trích xuất các giá trị từ tuple variant hoặc struct variant.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FlashMessage {
  Success, // unit variant
  Error(String), // tuple variant
  Warning { category: i32, message: String }, // struct variant
}

fn format_message(message: FlashMessage) -&gt; String {
  match message {
    FlashMessage::Success =&gt; &quot;success&quot;.to_string(),
    FlashMessage::Error(err) =&gt; format!(&quot;My error: {}&quot;, err),
    FlashMessage::Warning{ category, message } =&gt; format!(&quot;Warn: {} (category: {})&quot;, message, category),
  }
}

let m = format_message(FlashMessage::Error(&quot;something went wrong&quot;.to_string()));
println!(&quot;{m}&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-02-match.html">https://doc.rust-lang.org/book/ch06-02-match.html</a></li>
<li><a href="https://blog.logrocket.com/rust-enums-and-pattern-matching/">https://blog.logrocket.com/rust-enums-and-pattern-matching/</a></li>
</ul>
<h1 id="use-enumvariants"><a class="header" href="#use-enumvariants">use Enum::{Variants}</a></h1>
<p>Ta có thể mang variants ra ngoài scope của enum bằng <code>use</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

// hoặc
// use self::Coin::{Penny, Nickel, Dime, Quarter};
use Coin::*;

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Penny =&gt; 1,
    Nickel =&gt; 5,
    Dime =&gt; 10,
    Quarter =&gt; 25,
  }
}

fn main() {
  assert_eq!(value_in_cents(Penny), 1);
  assert_eq!(value_in_cents(Coin::Penny), 1);
}
</code></pre></pre>
<h1 id="impl-enum"><a class="header" href="#impl-enum">impl Enum</a></h1>
<p>Ta cũng có thể <code>impl</code> cho <code>enum</code> giống như <code>struct</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}

// impl enum
impl Day {
  fn today(self) -&gt; Self {
    self
  }
}

// Trait
trait DayOff {
  fn day_off(self);
}

// impl trait for enum
impl DayOff for Day {
  fn day_off(self) {
    match self.today() {
      Self::Sunday | Self::Saturday =&gt; println!(&quot;day off&quot;),
      _ =&gt; println!(&quot;noooo&quot;),
    }
  }
}

let today = Day::Sunday;
today.day_off();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-enum-1"><a class="header" href="#match-enum-1">match Enum</a></h1>
<p><code>match</code> cực kỳ mạnh và được dùng trong Rust phổ biến.</p>
<p>Ví dụ sau là cách để kiểm tra một giá trị enum là variant nào.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Coin::Penny =&gt; 1,
    Coin::Nickel =&gt; 5,
    Coin::Dime =&gt; 10,
    Coin::Quarter =&gt; 25,
  }
}

fn main() {}
</code></pre></pre>
<p><code>match</code> còn có thể trích xuất các giá trị từ tuple variant hoặc struct variant.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FlashMessage {
  Success, // unit variant
  Error(String), // tuple variant
  Warning { category: i32, message: String }, // struct variant
}

fn format_message(message: FlashMessage) -&gt; String {
  match message {
    FlashMessage::Success =&gt; &quot;success&quot;.to_string(),
    FlashMessage::Error(err) =&gt; format!(&quot;My error: {}&quot;, err),
    FlashMessage::Warning{ category, message } =&gt; format!(&quot;Warn: {} (category: {})&quot;, message, category),
  }
}

let m = format_message(FlashMessage::Error(&quot;something went wrong&quot;.to_string()));
println!(&quot;{m}&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-02-match.html">https://doc.rust-lang.org/book/ch06-02-match.html</a></li>
<li><a href="https://blog.logrocket.com/rust-enums-and-pattern-matching/">https://blog.logrocket.com/rust-enums-and-pattern-matching/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-enumvariants-1"><a class="header" href="#use-enumvariants-1">use Enum::{Variants}</a></h1>
<p>Ta có thể mang variants ra ngoài scope của enum bằng <code>use</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

// hoặc
// use self::Coin::{Penny, Nickel, Dime, Quarter};
use Coin::*;

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Penny =&gt; 1,
    Nickel =&gt; 5,
    Dime =&gt; 10,
    Quarter =&gt; 25,
  }
}

fn main() {
  assert_eq!(value_in_cents(Penny), 1);
  assert_eq!(value_in_cents(Coin::Penny), 1);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-enum-1"><a class="header" href="#impl-enum-1">impl Enum</a></h1>
<p>Ta cũng có thể <code>impl</code> cho <code>enum</code> giống như <code>struct</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}

// impl enum
impl Day {
  fn today(self) -&gt; Self {
    self
  }
}

// Trait
trait DayOff {
  fn day_off(self);
}

// impl trait for enum
impl DayOff for Day {
  fn day_off(self) {
    match self.today() {
      Self::Sunday | Self::Saturday =&gt; println!(&quot;day off&quot;),
      _ =&gt; println!(&quot;noooo&quot;),
    }
  }
}

let today = Day::Sunday;
today.day_off();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option"><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a></a></h1>
<p>Nhiều ngôn ngữ sử dụng kiểu dữ liệu <code>null</code> hoặc <code>nil</code> hoặc <code>undefined</code> 
để đại diện cho các giá trị rỗng hoặc không tồn tại, và sử dụng <code>Exception</code> 
để xử lý lỗi. Rust bỏ qua hai khái niệm này, để tránh gặp phải các lỗi phổ biến 
như <strong>null pointer exceptions,</strong> hay <strong>lộ thông tin nhạy cảm thông qua exceptions,</strong> ... 
Thay vào đó, Rust giới thiệu hai generic enums <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> 
và <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> để giải quyết các vấn đề trên.</p>
<hr />
<p>Trong hầu hết các ngôn ngữ họ C (C, C#, Java, ...), để xác định một cái gì đó failed 
hay không tìm được giá trị thỏa mãn, chúng ta thường trả về một giá trị <em>&quot;đặc biệt&quot;</em> nào đó.
Ví dụ <code>indexOf()</code> của Javascript scan một phần tử trong mảng, 
trả về vị trí của phần tử đó trong mảng. Và trả về <code>-1</code> nếu không tìm thấy. </p>
<p>Dẫn đến, ta sẽ thường thấy một số đoạn code như sau đây:</p>
<pre><code class="language-typescript">// Typescript

let sentence = &quot;The fox jumps over the dog&quot;;
let index = sentence.indexOf(&quot;fox&quot;);

if (index &gt; -1) {
  let result = sentence.substr(index);
  console.log(result);
}
</code></pre>
<p>Như bạn thấy <code>-1</code> là một trường hợp đặc biệt cần xử lý. 
Có khi nào bạn đã từng mắc lỗi ngớ ngẫn vì tưởng giá trị đặc biệt đó là <code>0</code> chưa?</p>
<pre><code class="language-typescript">// Typescript

if (index &gt; 0) {
  // 3000 days of debugging
}
</code></pre>
<p><code>&quot;&quot;</code> hay <code>null</code> hay <code>None</code> cũng là một trong những trường hợp đặc biệt đó. 
Bạn đã từng nghe đến <strong><strong><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a></strong></strong>?</p>
<p>Lý do cơ bản là không có gì chắc chắn và có thể ngăn bạn lại việc ... <strong>quên</strong> 
xử lý mọi trường hợp giá trị đặc biệt, hoặc do chương trình trả về các giá trị đặc biệt không như mong đợi.
Có nghĩa là ta có thể <em>vô tình</em> làm crash chương trình với một lỗi nhỏ ở bất kỳ đâu, ở bất kỳ thời điểm nào.</p>
<p>Rust làm điều này tốt hơn, chỉ với <code>Option</code>. </p>
<p>Một giá trị optional có thể mang một giá trị nào đó <strong>Some(something)</strong> hoặc không mang giá trị nào cả (<strong>None</strong>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An output can have either Some value or no value/ None.
enum Option&lt;T&gt; { // T is a generic and it can contain any type of value.
  Some(T),
  None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Theo thiết kế, mặc định bạn sẽ không bao giờ lấy được giá trị bạn cần nếu không xử lý 
các trường hợp có thể xảy ra với <code>Option</code>, là <code>None</code> chẳng hạn. 
Điều này được bắt buộc bởi compiler lúc compile code, 
có nghĩa là nếu bạn quên check, code sẽ không bao giờ được compile.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sentence = &quot;The fox jumps over the dog&quot;;
let index = sentence.find(&quot;fox&quot;);

if let Some(fox) = index {
  let words_after_fox = &amp;sentence[fox..];
  println!(&quot;{}&quot;, words_after_fox);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="cách-sử-dụng-option"><a class="header" href="#cách-sử-dụng-option"><strong>Cách sử dụng Option</strong></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> là standard library, do đã được 
<a href="https://learning-rust.github.io/docs/d7.std_primitives_and_preludes.html#Preludes">preludes</a> 
nên chúng ta không cần khai báo trước khi sử dụng. Ngoài enum 
<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> thì các variant của nó cũng đã được preludes 
sẵn như <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some">Some</a> 
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None">None</a>.</p>
<p>Ví dụ, ta có một function tính giá trị chia hai số, 
đôi khi sẽ không tìm ra được kết quả, ta sử dụng Some như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Option&lt;i32&gt; {
    if !name.starts_with('d') {
        return None;
    }

    Some(123)
}

fn main() {
    let name = &quot;duyet&quot;;

    match get_id_from_name(name) {
        Some(id) =&gt; println!(&quot;User = {}&quot;, id),
        _ =&gt; println!(&quot;Not found&quot;),
    }
}
</code></pre></pre>
<p>Ta thường sử dụng <code>match</code> để bắt giá trị trả về (<code>Some</code> hoặc <code>None</code>). </p>
<p>Bạn sẽ bắt gặp rất nhiều method khác nhau để xử lý giá trị của <code>Option</code></p>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> method overview: <a href="https://doc.rust-lang.org/std/option/#method-overview">https://doc.rust-lang.org/std/option/#method-overview</a></p>
<h3 id="unwrap"><a class="header" href="#unwrap"><code>.unwrap()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some(T)</code>. Nếu giá trị là <code>None</code> thì panic chương trình. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(&quot;air&quot;);
assert_eq!(x.unwrap(), &quot;air&quot;);

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), &quot;air&quot;); // panic!
<span class="boring">}
</span></code></pre></pre>
<h3 id="expect"><a class="header" href="#expect"><code>.expect()</code></a></h3>
<p>Giống <code>.unwrap()</code>, nhưng khi panic thì Rust sẽ kèm theo message</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;&amp;str&gt; = None;
x.expect(&quot;fruits are healthy&quot;); // panics: `fruits are healthy`
<span class="boring">}
</span></code></pre></pre>
<h3 id="unwrap_or"><a class="header" href="#unwrap_or"><code>.unwrap_or()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá trị nằm trong <code>or</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some(&quot;car&quot;).unwrap_or(&quot;bike&quot;), &quot;car&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="unwrap_or_default"><a class="header" href="#unwrap_or_default"><code>.unwrap_or_default()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_year_from_input = &quot;1909&quot;;
let bad_year_from_input = &quot;190blarg&quot;;
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
<span class="boring">}
</span></code></pre></pre>
<h3 id="ok_or"><a class="header" href="#ok_or"><code>.ok_or()</code></a></h3>
<p>Convert <code>Option&lt;T&gt;</code> sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>, 
mapping <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some"><code>Some(v)</code></a> 
thành <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok(v)</code></a> 
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None"><code>None</code></a> 
sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err(err)</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(&quot;foo&quot;);
assert_eq!(x.ok_or(0), Ok(&quot;foo&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="match"><a class="header" href="#match"><code>match</code></a></h3>
<p>Chúng ta có thể sử dụng pattern matching để code dễ đọc hơn</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_name(who: Option&lt;String&gt;) -&gt; String {
  match who {
    Some(name) =&gt; format!(&quot;Hello {}&quot;, name),
    None       =&gt; &quot;Who are you?&quot;.to_string(), 
  }
}

get_name(Some(&quot;duyet&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="if-let-somex--x"><a class="header" href="#if-let-somex--x">if let Some(x) = x</a></h3>
<p>Có thể bạn sẽ gặp pattern này nhiều khi đọc code Rust.
Nếu giá trị của <code>x</code> là <code>Some</code> thì sẽ destruct 
giá trị đó bỏ vào biến <code>x</code> nằm trong scope của <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; Option&lt;String&gt; {
    Some(&quot;ok&quot;.to_string())
}

if let Some(data) = get_data() {
    println!(&quot;data = {}&quot;, data);
} else {
    println!(&quot;no data&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unwrap-1"><a class="header" href="#unwrap-1"><code>.unwrap()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some(T)</code>. Nếu giá trị là <code>None</code> thì panic chương trình. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(&quot;air&quot;);
assert_eq!(x.unwrap(), &quot;air&quot;);

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), &quot;air&quot;); // panic!
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="expect-1"><a class="header" href="#expect-1"><code>.expect()</code></a></h3>
<p>Giống <code>.unwrap()</code>, nhưng khi panic thì Rust sẽ kèm theo message</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;&amp;str&gt; = None;
x.expect(&quot;fruits are healthy&quot;); // panics: `fruits are healthy`
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unwrap_or_default-1"><a class="header" href="#unwrap_or_default-1"><code>.unwrap_or_default()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_year_from_input = &quot;1909&quot;;
let bad_year_from_input = &quot;190blarg&quot;;
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="if-let-somex--x-1"><a class="header" href="#if-let-somex--x-1">if let Some(x) = x</a></h3>
<p>Có thể bạn sẽ gặp pattern này nhiều khi đọc code Rust.
Nếu giá trị của <code>x</code> là <code>Some</code> thì sẽ destruct 
giá trị đó bỏ vào biến <code>x</code> nằm trong scope của <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; Option&lt;String&gt; {
    Some(&quot;ok&quot;.to_string())
}

if let Some(data) = get_data() {
    println!(&quot;data = {}&quot;, data);
} else {
    println!(&quot;no data&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result"><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a></a></h1>
<p>Tương tự như <a href="basic/enum/result/./option.html"><code>Option</code></a>. 
Một kết quả trả về (<a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a>)
của một function thường sẽ có hai trường hợp:</p>
<ul>
<li>thành công (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>) và trả về kết quả</li>
<li>hoặc lỗi (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>) và trả về thông tin lỗi.</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a> là một phiên bản cao cấp hơn của <a href="basic/enum/result/../option/README.html"><code>Option</code></a>.
Nó mô tả <em>lỗi gì</em> đang xảy ra thay vì khả năng <em>tồn tại</em> giá trị hay không.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Ví dụ</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; {
    if !name.starts_with('d') {
        return Err(&quot;not found&quot;);
    }

    Ok(123)
}

fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    let name = &quot;duyet&quot;;

    match get_id_from_name(name) {
        Ok(id) =&gt; println!(&quot;User = {}&quot;, id),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    };

    Ok(())
}
</code></pre></pre>
<p>Như bạn thấy thì <code>main()</code> cũng có thể return về <code>Result&lt;(), &amp;'static str&gt;</code></p>
<h3 id="unwrap-2"><a class="header" href="#unwrap-2"><code>.unwrap()</code></a></h3>
<p>Ví dụ trên nhưng sử dụng <code>.unwrap()</code> , chủ động panic (crash) dừng chương trình nếu gặp lỗi.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = &quot;duyet&quot;;
  let age = get_age(who).unwrap();
  println!(&quot;{} is {}&quot;, who, age);

  Ok(())
}
</code></pre></pre>
<h3 id="expect-2"><a class="header" href="#expect-2"><code>.expect()</code></a></h3>
<p>Giống như <code>unwrap()</code>: chủ động panic (crash) dừng chương trình nếu gặp lỗi và kèm theo message. Sẽ rất có ích, nhất là khi có quá nhiều unwrap, bạn sẽ không biết nó panic ở đâu.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = &quot;ngan&quot;;
  let age = get_age(who).expect(&quot;could not get age&quot;);
  println!(&quot;{} is {}&quot;, who, age);

  Ok(())
}
</code></pre></pre>
<p>Xem thêm mọi method khác của <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> <a href="https://doc.rust-lang.org/std/result/enum.Result.html">tại đây</a>.</p>
<h1 id="convert-result-sang-option"><a class="header" href="#convert-result-sang-option">Convert <code>Result</code> sang <code>Option</code></a></h1>
<p>Đôi khi bạn sẽ cần convert từ </p>
<ul>
<li><code>Ok(v)</code> sang <code>Some(v)</code>, hoặc</li>
<li><code>Err(e)</code> sang <code>Some(e)</code></li>
</ul>
<h2 id="ok"><a class="header" href="#ok"><code>.ok()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .ok(v) = Some(v)
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.ok(), Some(2));

let x: Result&lt;u32, &amp;str&gt; = Err(&quot;Nothing here&quot;);
assert_eq!(x.ok(), None);
</code></pre></pre>
<h2 id="err"><a class="header" href="#err"><code>.err()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .err()
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.err(), None);

let x: Result&lt;u32, &amp;str&gt; = Err(&quot;Nothing here&quot;);
assert_eq!(x.err(), Some(&quot;Nothing here&quot;));
</code></pre></pre>
<h1 id="toán-tử-"><a class="header" href="#toán-tử-">Toán tử <code>?</code></a></h1>
<p>Khi viết code mà có quá nhiều functions trả về <a href="basic/enum/result/./result.html"><code>Result</code></a>, việc handle Err sẽ khá nhàm chán. Toán tử chấm hỏi <a href="https://doc.rust-lang.org/std/ops/trait.Try.html">?</a> cho phép dừng function tại vị trí đó và return cho function cha nếu <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ở vị trí đó là Err.</p>
<p>Nó sẽ thay thế đoạn code sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  // Early return on error
  let mut file = match File::create(&quot;my_best_friends.txt&quot;) {
    Err(e) =&gt; return Err(e),
    Ok(f) =&gt; f,
  };
  if let Err(e) = file.write_all(format!(&quot;name: {}\n&quot;, info.name).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!(&quot;age: {}\n&quot;, info.age).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!(&quot;rating: {}\n&quot;, info.rating).as_bytes()) {
    return Err(e)
  }
  Ok(())
}
</code></pre></pre>
<p>thành</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  let mut file = File::create(&quot;my_best_friends.txt&quot;)?;
  // Early return on error
  file.write_all(format!(&quot;name: {}\n&quot;, info.name).as_bytes())?;
  file.write_all(format!(&quot;age: {}\n&quot;, info.age).as_bytes())?;
  file.write_all(format!(&quot;rating: {}\n&quot;, info.rating).as_bytes())?;
  Ok(())
}
</code></pre></pre>
<p>Gọn đẹp hơn rất nhiều.</p>
<p>Toán tử <code>?</code> sẽ unwrap giá trị <code>Ok</code>, hoặc return giá trị <code>Err</code> ở vị trí gần toán tử đó.</p>
<p><code>?</code> chỉ có thể được dùng trong function có kiểu dữ liệu trả về là <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert-result-sang-option-1"><a class="header" href="#convert-result-sang-option-1">Convert <code>Result</code> sang <code>Option</code></a></h1>
<p>Đôi khi bạn sẽ cần convert từ </p>
<ul>
<li><code>Ok(v)</code> sang <code>Some(v)</code>, hoặc</li>
<li><code>Err(e)</code> sang <code>Some(e)</code></li>
</ul>
<h2 id="ok-1"><a class="header" href="#ok-1"><code>.ok()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .ok(v) = Some(v)
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.ok(), Some(2));

let x: Result&lt;u32, &amp;str&gt; = Err(&quot;Nothing here&quot;);
assert_eq!(x.ok(), None);
</code></pre></pre>
<h2 id="err-1"><a class="header" href="#err-1"><code>.err()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .err()
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.err(), None);

let x: Result&lt;u32, &amp;str&gt; = Err(&quot;Nothing here&quot;);
assert_eq!(x.err(), Some(&quot;Nothing here&quot;));
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toán-tử--1"><a class="header" href="#toán-tử--1">Toán tử <code>?</code></a></h1>
<p>Khi viết code mà có quá nhiều functions trả về <a href="basic/enum/result/./result.html"><code>Result</code></a>, việc handle Err sẽ khá nhàm chán. Toán tử chấm hỏi <a href="https://doc.rust-lang.org/std/ops/trait.Try.html">?</a> cho phép dừng function tại vị trí đó và return cho function cha nếu <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ở vị trí đó là Err.</p>
<p>Nó sẽ thay thế đoạn code sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  // Early return on error
  let mut file = match File::create(&quot;my_best_friends.txt&quot;) {
    Err(e) =&gt; return Err(e),
    Ok(f) =&gt; f,
  };
  if let Err(e) = file.write_all(format!(&quot;name: {}\n&quot;, info.name).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!(&quot;age: {}\n&quot;, info.age).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!(&quot;rating: {}\n&quot;, info.rating).as_bytes()) {
    return Err(e)
  }
  Ok(())
}
</code></pre></pre>
<p>thành</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  let mut file = File::create(&quot;my_best_friends.txt&quot;)?;
  // Early return on error
  file.write_all(format!(&quot;name: {}\n&quot;, info.name).as_bytes())?;
  file.write_all(format!(&quot;age: {}\n&quot;, info.age).as_bytes())?;
  file.write_all(format!(&quot;rating: {}\n&quot;, info.rating).as_bytes())?;
  Ok(())
}
</code></pre></pre>
<p>Gọn đẹp hơn rất nhiều.</p>
<p>Toán tử <code>?</code> sẽ unwrap giá trị <code>Ok</code>, hoặc return giá trị <code>Err</code> ở vị trí gần toán tử đó.</p>
<p><code>?</code> chỉ có thể được dùng trong function có kiểu dữ liệu trả về là <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics là một khái niệm để tổng quát hóa các kiểu dữ liệu 
hoặc tính năng cho các trường hợp rộng hơn. Tổng quát hóa cực kỳ hữu ích
trong việc giảm số lượng code duplication. Một trong những ví dụ phổ
biến nhất của tổng quát hóa là tổng quát một function có thể input nhiều loại
kiểu dữ liệu khác nhau (type parameters).</p>
<p>Generic type parameters thường được biểu diễn dưới dạng <code>&lt;T&gt;</code>.</p>
<p>Ví dụ, định nghĩa một <em>generic function</em> <code>foo</code> nhận một tham số <code>T</code> của mọi kiểu dữ liệu.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(arg: T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>Xem các trang sau để biết chi tiết về generic type 
được ứng dụng trong các trường hợp khác nhau như thế nào.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h1>
<p>Định nghĩa một generic function bằng cách khai báo generic type <code>&lt;T&gt;</code> sau tên của function.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {} // x có kiểu T, T là generic type

fn bar&lt;T&gt;(x: T, y: T) {} // x và y đều có kiểu T

fn baz&lt;T, U&gt;(x: T, y: U) {} // sử dụng nhiều generic type
<span class="boring">}
</span></code></pre></pre>
<p>Gọi một generic function đôi khi yêu cầu chỉ định kiểu dữ liệu tường minh cho tham số đó.
Đôi khi là do function được gọi trả về kiểu dữ liệu là generic, hoặc compiler không có
đủ thông tin. Thực thi một function và chỉ định kiểu dữ liệu tường minh có cú pháp như sau:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>function_name::&lt;A, B&gt;()
<span class="boring">}
</span></code></pre></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn print_me&lt;T: ToString&gt;(content: T) {
    println!(&quot;{}&quot;, content.to_string());
}

fn main() {
    print_me::&lt;i32&gt;(100);
    print_me::&lt;u64&gt;(1_000_000);
}
</code></pre></pre>
<p>Cú pháp <code>&lt;T: ToString&gt;</code> có nghĩa là: function <code>print_me</code> chấp nhận mọi tham số có
kiểu <code>T</code>, miễn sau <code>T</code> được implement trait 
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html">ToString</a>.</p>
<p>Một ví dụ khác phức tạp hơn từ <a href="https://doc.rust-lang.org/rust-by-example/generics/gen_fn.html">Rust By Example</a></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct A;          // Type tường minh `A`.
struct S(A);       // Type tường minh `S`.
struct SGen&lt;T&gt;(T); // Type Generic `SGen`.

// Các function sau sẽ take ownership của variable
// sau đó thoát ra khỏi scope {}, sau đó giải phóng variable.

// Định nghĩa function `reg_fn` nhận tham số `_s` có kiểu `S`.
// Không có `&lt;T&gt;` vì vậy đây không phải là một generic function.
fn reg_fn(_s: S) {}

// Định nghĩa function `gen_spec_t` nhận tham số `_s` có kiểu `SGen&lt;T&gt;`.
// Ở đây tường minh kiểu `A` cho `S`, và bởi vì `A` không được khai báo 
// như là một generic type parameter cho `gen_spec_t`, 
// nên đây cũng không phải là một generic function.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Định nghĩa function `gen_spec_i32` nhận tham số `_s` có kiểu `SGen&lt;i32&gt;`.
// Giống như ở trên, ta khai báo tường minh `i32` cho `T`.
// Bởi vì `i32` không phải là một a generic type, nên function này cũng không
// phải là một genenic function.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Định nghĩa một `generic` function, nhận tham số `_s` có kiểu `SGen&lt;T&gt;`.
// Bởi vì `SGen&lt;T&gt;` được đứng trước bởi `&lt;T&gt;`, nên function này generic bởi `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Gọi non-generic functions
    reg_fn(S(A));          // Concrete type.
    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.

    // Chỉ định cụ thể parameter `char` cho `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Chỉ định cụ thể `char` to `generic()`.
    generic(SGen('c'));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-struct"><a class="header" href="#generic-struct">Generic Struct</a></h1>
<p>Giống như function, ta cũng có thể sử dụng generic type cho
Struct</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
  x: T,
  y: T,
}

fn main() {
  let point_a = Point { x: 0, y: 0 }; // T is a int type
  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-enum"><a class="header" href="#generic-enum">Generic Enum</a></h1>
<p><a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a> và <a href="https://doc.rust-lang.org/std/result/index.html"><code>Result</code></a> là 2 ví dụ của generic struct.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="sử-dụng-optiont"><a class="header" href="#sử-dụng-optiont">Sử dụng <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option&lt;T&gt;</code></a>:</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Option&lt;i32&gt; {
    if !name.starts_with('d') {
        return None;
    }

    Some(123)
}

fn main() {
    let name = &quot;duyet&quot;;

    match get_id_from_name(name) {
        Some(id) =&gt; println!(&quot;User = {}&quot;, id),
        _ =&gt; println!(&quot;Not found&quot;),
    }
}
</code></pre></pre>
<p>Xem thêm: <a href="basic/generics/../enum/option"><em>Enum &gt; Option<T></em></a></p>
<h4 id="sử-dụng-resultt-e"><a class="header" href="#sử-dụng-resultt-e">Sử dụng <a href="https://doc.rust-lang.org/std/result/index.html"><code>Result&lt;T, E&gt;</code></a>:</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; {
    if !name.starts_with('d') {
        return Err(&quot;not found&quot;);
    }

    Ok(123)
}

fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    let name = &quot;duyet&quot;;

    match get_id_from_name(name) {
        Ok(id) =&gt; println!(&quot;User = {}&quot;, id),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    };

    Ok(())
}
</code></pre></pre>
<p>Xem tưhêm: <a href="basic/generics/../enum/result"><em>Enum &gt; Result&lt;T, E&gt;</em></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-implementation"><a class="header" href="#generic-implementation">Generic Implementation</a></h1>
<p>Ta cũng có thể sử dụng generic type cho implementation.</p>
<p>Khai báo generic type sau từ khóa <code>impl</code>: <code>impl&lt;T, U&gt; ...</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct S; // Kiểu tường minh `S`
struct GenericVal&lt;T&gt;(T); // Generic type `GenericVal`

// impl cho GenericVal, chúng ta có thể chỉ định cụ thể kiểu dữ liệu cho type parameters:
impl GenericVal&lt;f32&gt; {} // `f32`
impl GenericVal&lt;S&gt; {} // `S` được định nghĩa ở trên

// cần khai báo `&lt;T&gt;` để duy trì tính tổng quát
impl&lt;T&gt; GenericVal&lt;T&gt; {}

fn main() {}
</code></pre></pre>
<p>Một ví dụ khác</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct GenVal&lt;T&gt; {
    gen_val: T,
}

// impl of GenVal for a generic type `T`
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = GenVal { gen_val: 3i32 };
    let y = GenVal::&lt;u32&gt; { gen_val: 6 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-trait"><a class="header" href="#generic-trait">Generic Trait</a></h1>
<p>Trait cũng có thể được tổng quát hóa.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">// Non-copyable types.
struct Empty;
struct Null;

// A trait generic over `T`.
trait DoubleDrop&lt;T&gt; {
    // Định nghĩa một method trên type hiện tại, method nhận
    // một giá trị khác cũng có kiểu `T` và không làm gì với nó.
    fn double_drop(self, _: T);
}

// Implement `DoubleDrop&lt;T&gt;` cho mọi generic parameter `T` và
// caller `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // Method này take ownership của cả 2 arguments,
    // sau đó giải phóng bộ nhớ cho cả 2, do ra khỏi scope {}
    // mà không làm gì cả.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    empty.double_drop(null);

    // TODO: uncomment
    // empty;
    // null;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounds"><a class="header" href="#bounds">Bounds</a></h1>
<p>Cái này rất khó giải thích bằng tiếng Việt bằng một từ đơn giản.
Khi sử dụng tổng quát hóa, type parameter thường phải sử dụng các trait
như các ràng buộc, giới hạn (bounds) để quy định chức năng (functionality) của kiểu
đang được implement.</p>
<p>Trong ví dụ sau sử dụng trait <code>Display</code> để in, vì thế ta cần <code>T</code> bị ràng buộc (bound)
bởi <code>Display</code>. Có nghĩa là, ta cần tham số có kiểu <code>T</code> 
và <code>T</code> <em>bắt buộc</em> phải đã được implement <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::fmt::Display;
</span>fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Bounding giới hạn lại generic type. </p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>// T phải được impl `Display`
struct S&lt;T: Display&gt;(T);

// error[E0277]: `Vec&lt;{integer}&gt;` doesn't implement `std::fmt::Display`
let s = S(vec![1]);
<span class="boring">}
</span></code></pre></pre>
<h2 id="t-display--debug"><a class="header" href="#t-display--debug"><code>T: Display + Debug</code></a></h2>
<p>Để bounding nhiều trait, ta sử dụng <code>+</code>. 
Ví dụ sau có nghĩa <code>T</code> phải được implement trait <code>Display</code> và <code>Debug</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use core::fmt::Debug;
</span>fn printer&lt;T: Display + Debug&gt;(t: T) {
    println!(&quot;{:?}&quot;, t);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mệnh-đề-where"><a class="header" href="#mệnh-đề-where">Mệnh đề <code>where</code></a></h1>
<p>Một bound có thể được chỉ dẫn sau mệnh đề <code>where</code> ngay trước <code>{</code> của function.</p>
<p><code>where</code> giúp cho việc định nghĩa các generic types và bounds một cách rõ ràng hơn.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use core::fmt::Debug;
</span>fn printer&lt;T&gt;(t: T) 
where
    T: Display + Debug
{
    println!(&quot;{:?}&quot;, t);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Vector có để được xem là re-sizable array nhưng mọi phần tử trong vec phải có cùng kiểu dữ liệu.</p>
<p>Vector là một generic type: <code>Vec&lt;T&gt;</code>, <code>T</code> có thể là bất kỳ kiểu dữ liệu nào. Ví dụ một vector chứa <code>i32</code> được viết là <code>Vec&lt;i32&gt;</code>.</p>
<h2 id="tạo-vector"><a class="header" href="#tạo-vector">Tạo vector</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a1: Vec&lt;i32&gt; = Vec::new();
let a2: Vec&lt;i32&gt; = vec![];

// Khai báo kiểu cho phần tử đầu tiên
let b2 = vec![1i32, 2, 3];

// Vec chứa mười số 0
let b3 = vec![0; 10];
<span class="boring">}
</span></code></pre></pre>
<h2 id="in-vector"><a class="header" href="#in-vector">In vector</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = vec![5, 4, 3, 2, 1];
println!(&quot;vec = {:?}&quot;, c);
<span class="boring">}
</span></code></pre></pre>
<h2 id="push-và-pop"><a class="header" href="#push-và-pop">Push và Pop</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut d: Vec&lt;i32&gt; = vec![];
d.push(1);
d.push(2);
d.pop();
<span class="boring">}
</span></code></pre></pre>
<h2 id="kiểm-tra-kích-thước-của-vector"><a class="header" href="#kiểm-tra-kích-thước-của-vector">Kiểm tra kích thước của vector</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let d = vec![0; 10];

println!(&quot;len = {}&quot;, d.len());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<p>Tất cả giá trị trên Rust mặc định đều được allocated trên stack. Giá trị có thể được <em>boxed</em>, allocated trên heap bằng cách sử dụng <code>Box&lt;T&gt;</code>. 
<code>Box&lt;T&gt;</code> là một smart pointer của Rust cho phép allocated trên heap giá trị có kiểu <code>T</code>, còn pointer trỏ đến giá trị đó sẽ nằm trên stack.
<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">Xem thêm về stack và heap tại đây</a>.</p>
<p>Khi một Box nằm ngoài scope, destructor sẽ được gọi để giải phóng bộ nhớ. 
Sử dụng Box không ảnh hưởng nhiều đến performance do Box không bổ sung thêm thông tin metadata nào khác. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
  let b = Box::new(5);
  println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p>Ở ví dụ trên, chúng ta định nghĩa <code>b</code> có giá trị của <code>Box</code> đang trỏ đến giá trị <code>5</code> và <code>5</code> đang được allocated trên heap. Chương trình sẽ in ra <code>b = 5</code> , cách truy cập giống hệt cách allocated trên stack. Giống như owned value, khi box out of scope, cuối hàm <code>main</code> sẽ được giải phóng. </p>
<p>Lưu một giá trị đơn giản trên Box không mang lại lợi ích gì cả. Chúng ta sẽ thường dùng Box trong các trường hợp sau:</p>
<ol>
<li>Khi bạn có một type mà không biết trước size ở compile time, và bạn cần sử dụng type đó trong một số ngữ cảnh cần biết trước chính xác data size (ví dụ như <em>recursive type)</em>.</li>
<li>Bạn cần xử lý các kiểu dữ liệu nhưng chỉ muốn quan tâm đến type đó được implement trait nào.</li>
<li>Khi bạn có một lượng lớn data cần transfer ownership nhưng muốn chắc là data sẽ không bị copy, sẽ ảnh hưởng đến hiệu năng và làm tăng bộ nhớ.</li>
</ol>
<p>Chúng ta sẽ làm rõ ngay sau đây.</p>
<h1 id="1-recursive-types-với-box"><a class="header" href="#1-recursive-types-với-box">1. Recursive types với <code>Box</code></a></h1>
<p>Tại compile time, Rust cần biết cần phải biết cần bao nhiêu bộ nhớ. Một trong những kiểu dữ liệu mà Rust không biết trước được size là <em>recursive type.</em> Giá trị có thể là một phần của giá trị khác có cùng một kiểu. Bởi vì nesting of values theo lý thuyết có thể kéo dài đến vô hạn. Trong trường hợp này ta có thể dùng <code>Box</code>.</p>
<p><a href="https://en.wikipedia.org/wiki/Cons">Cons list</a> là một kiểu dữ liệu phổ biến trong các ngôn ngữ functional programming, 
là một ví dụ của recursive type. Cons là viết tắt của <em>&quot;construct function&quot;</em>. 
Mỗi item trong cons list có 2 thành phần: giá trị của item hiện tại và next item. 
Item cuối cùng có giá trị Nil và không có next item. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
  Cons(i32, List),
  Nil,
}
<span class="boring">}
</span></code></pre></pre>
<p>Bây giờ hãy sử dụng <code>List</code> type để lưu list <code>1, 2, 3</code> như sau</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum List {
  Cons(i32, List),
  Nil,
}

use List::{Cons, Nil};

fn main() {
  let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre></pre>
<p>Nếu chúng ta compile đoạn code trên, compiler sẽ báo như sau:</p>
<pre><code class="language-bash">$ cargo run
   Compiling cons-list v0.1.0 (file:///duyet/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<p>Compiler nói rằng kiểu dữ liệu này <em>has infinite size.</em> Bởi vì <code>List</code> có variant là <code>List::Cons</code> chứa trực tiếp một <code>List</code> khác trong chính nó. Do đó Rust sẽ không biết được sẽ cần bao nhiêu bộ nhớ để lưu giá trị của <code>List</code>. </p>
<p>Dừng lại một chút để xem Rust tính toán bộ nhớ của một kiểu dữ liệu bình thường như thế nào:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<p>Để xác định bao nhiêu bộ nhớ cần để allocate cho <code>Message</code>, Rust sẽ kiểm tra từng variant (biến thể của enum) để xem variant nào cần bộ nhớ nhiều nhất. Rust thấy rằng <code>Message::Quit</code> không cần, <code>Message::Move</code> phải cần ít nhất bộ nhớ để lưu hai giá trị <code>i32</code>. Tương tự với các variant còn lại. Bởi vì một thời điểm cho có một variant được sử dụng, do đó bộ nhớ tối đa mà <code>Message</code> cần sẽ là một nhớ cần để lưu trữ variant lớn nhất. </p>
<p>Quay lại với Cons List, bộ nhớ mà Rust tính toán được có thể đến vô tận.</p>
<p><img src="basic//media/2022/03/cons.svg" alt="" /></p>
<p>Theo như gợi ý của compiler, chúng ta có thể sử dụng <code>Box&lt;T&gt;</code> để có một Recursive Type với một kích thước bộ nhớ xác định:</p>
<pre><code class="language-bash">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>Bởi vì <code>Box&lt;T&gt;</code> là một pointer, Rust luôn biết chính xác bao nhiêu bộ nhớ mà một <code>Box&lt;T&gt;</code> <strong>pointer</strong> cần.</p>
<p><img src="basic//media/2022/03/cons-box.png" alt="" /></p>
<p>Chương trình của chúng ta lúc này sẽ là:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum List {
  Cons(i32, Box&lt;List&gt;),
  Nil,
}

use List::{Cons, Nil};

fn main() {
  let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<h1 id="2-sử-dụng-trait-objects-cho-phép-sử-dụng-giá-trị-từ-nhiều-kiểu-dữ-liệu-khác-nhau"><a class="header" href="#2-sử-dụng-trait-objects-cho-phép-sử-dụng-giá-trị-từ-nhiều-kiểu-dữ-liệu-khác-nhau">2. Sử dụng <em>trait objects</em> cho phép sử dụng giá trị từ nhiều kiểu dữ liệu khác nhau</a></h1>
<p>Một giới hạn của <code>Vec</code> là chỉ có thể lưu trữ các thành phần có kiểu dữ liệu giống nhau mà thôi. Ta có thể lách luật trong một số trường hợp bằng cách sử dụng enum có nhiều variant giữ nhiều kiểu dữ liệu khác nhau</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Cell {
  Int(i32),
  Float(f64),
  Text(String),
}

let row = vec![
  Cell::Int(3),
  Cell::Text(String::from(&quot;blue&quot;)),
  Cell::Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<p>Tuy nhiên, trong một số trường hợp mong muốn thư viện của chúng ta có thể dễ dàng được mở rộng một số trường hợp khác. Chúng ta đã biết được định nghĩa Trait cho các Common Behavior. Trong Rust, trait định nghĩa các hành vi, và các hành vi này có thể được <code>impl</code> cho struct hoặc enum, để giúp một struct hoặc enum mang đặc tính các hành vi đó. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
  fn draw(&amp;self);
}

pub struct Screen {
  pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}

impl Screen {
  pub fn run(&amp;self) {
    for component in self.components.iter() {
      component.draw();
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Hãy xem ví dụ trên, ta có <code>components</code> có kiểu dữ liệu là <code>Vec&lt;T&gt;</code> với <code>&lt;T&gt;</code> là một <code>Box&lt;dyn Draw&gt;</code>. Chúng ta đã định nghĩa một vector chứa kiểu dữ liệu là một <em>trait object</em>. </p>
<p>Một <em>trait object</em> được định nghĩa bằng cách định nghĩa pointer, ví dụ như <code>&amp;dyn T</code>  hoặc <code>Box&lt;dyn T&gt;</code> smart pointer.</p>
<p>Một <em>trait object</em> sẽ trỏ đến:</p>
<ul>
<li>một instance của một kiểu dữ liệu có implement trait của chúng ta</li>
<li>và một bảng ghi look up đến các trait methods lúc runtime.</li>
</ul>
<p>Sử dụng trait object, Rust type system sẽ chắc chắn là tại thời điểm compile, tất cả các giá trị sử dụng tại ngữ cảnh đó đều phải được implement trai của <em>trait object</em> đó. Nói tóm lại, chúng ta sẽ không cần quan tâm đó là kiểu dữ liệu gì, chỉ cần biết kiểu dữ liệu đó phải được implement <em>trait</em> chúng ta cần là được.</p>
<p>Lý do cần sử dụng pointer reference <code>&amp;</code> hoặc smart pointer <code>Box&lt;T&gt;</code> bởi vì compiler không biết chính xác về kiểu dữ liệu, Rust sẽ dùng pointer của trait object để biết được method nào để cần được gọi. Xem thêm về <strong><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a>.</strong></p>
<h1 id="references-3"><a class="header" href="#references-3">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch15-01-box.html">Using Box<T> to Point to Data on the Heap</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/std/box.html#box-stack-and-heap">Box, stack and heap - Rust By Example</a></li>
<li><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">Using Trait Objects That Allow for Values of Different Types</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html">Advanced Types - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">The Stack and the Heap</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cow"><a class="header" href="#cow"><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a></a></h1>
<p><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> là một enum cực kỳ tiện dụng, được định nghĩa là &quot;clone on write&quot;.
Tức ra nó sẽ trả về <code>&amp;str</code> nếu bạn không cần một <code>String</code>, hoặc trả về một
<code>String</code> nếu bạn cần <code>String</code>. Tương tự với array <code>&amp;[]</code> và <code>Vec</code>, v.v.</p>
<p>Đây là định nghĩa của <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
 {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}
</span></code></pre></pre>
<p>Hãy phân tích <code>B</code>:</p>
<p><code>'a</code> có nghĩa là <code>Cow</code> làm việc được với references.</p>
<p>Trait <code>ToOwned</code> có nghĩa type này có thể convert thành owned type.
Ví dụ, <code>str</code> thường là một reference (<code>&amp;str</code>) hoặc bạn có thể convert nó thành owned <code>String</code>.</p>
<p><code>?Sized</code>, có nghĩa là có thể có <code>Sized</code> hoặc là không. 
Hầu hết mọi type trong Rust đều là <code>Sized</code>, nhưng type như là <code>str</code> thì không.
Vì thế chúng ta cần <code>&amp;</code> cho <code>str</code>, bởi vì compiler không biết kích thước của <code>str</code>.
Nếu bạn cần một trait có thể sử dụng giá trị nào tương tư như <code>str</code>, bạn thêm <code>?Sized</code>.</p>
<p>Tiếp theo là <code>enum</code> variant: một giá trị <code>Cow</code> có thể là <code>Borrowed</code> hoặc <code>Owned</code>.</p>
<p>Ví dụ bạn có một function trả về giá trị <code>Cow&lt;'static, str&gt;</code>. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_function() -&gt; Cow&lt;'static, str&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Nếu bạn yêu cầu function đó trả về <code>&quot;My message&quot;.into()</code>, 
nó sẽ xem <code>&quot;My message&quot;</code> là một <code>str</code>. Đây là một <code>Borrowed</code> type,
do đó variant sẽ là <code>Cow::Borrowed(&amp;'static str)</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_function() -&gt; Cow&lt;'static, str&gt; {
    &quot;My message&quot;.into()
}
<span class="boring">}
</span></code></pre></pre>
<p>Còn nếu bạn trả về</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_function() -&gt; Cow&lt;'static, str&gt; {
    format!(&quot;{}&quot;, &quot;My message&quot;).into()
}
<span class="boring">}
</span></code></pre></pre>
<p>lúc này kết quả trả về sẽ là <code>String</code>, bởi vì <code>format!()</code> trả về <code>String</code>. 
Variant sẽ là <code>Cow::Owned</code>.</p>
<h3 id="lợi-ích-của-cow"><a class="header" href="#lợi-ích-của-cow">Lợi ích của <code>Cow</code></a></h3>
<p><em>Copy on write</em> là một kỹ thuật giúp tối ưu hoá, nhất là trong các 
trường hợp reading nhiều hơn writing. Ý tưởng chính là không copy
object ngay lập tức, mà chỉ reference (borrow) đến object gốc, khi cần
một lượng lớn tác vụ reading. Và chỉ khi cần đến tác vụ writing (ít xảy ra hơn),
object mới được copy và thay đổi. Tác vụ để thay đổi giá trị object sẽ copy, di chuyển
object trong bộ nhớ là một tác vụ nặng, tốn kém. Do đó, ưu điểm của kỹ thuật này là
các tác vụ reading object rất nhanh do chỉ sử dụng reference (borrow) đến giá trị gốc.</p>
<h3 id="references-4"><a class="header" href="#references-4">References</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">https://doc.rust-lang.org/std/borrow/enum.Cow.html</a></li>
<li><a href="https://github.com/Dhghomon/easy_rust#cow">https://github.com/Dhghomon/easy_rust#cow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-code-comment-sao-cho-đúng"><a class="header" href="#-code-comment-sao-cho-đúng"><code>/// code comment</code> sao cho đúng</a></h1>
<p>Comment sao cho đúng để đồng đội bớt chửi.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<h2 id="regular-comments"><a class="header" href="#regular-comments">Regular comments</a></h2>
<p>Trong Rust comment bắt đầu bằng 2 slashes <code>//</code> được gọi là <em>Regular comments</em>,
chú thích cho một đoạn code hoặc biểu thức theo sau nó.
Compiler sẽ không quan tâm đến các Regular comments này.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  // I’m feeling lucky today
  let lucky_number = 7;
}
</code></pre></pre>
<p>Nếu comment có nhiều hơn một dòng,
hãy ngắt nó thành nhiều dòng -.-</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
<span class="boring">}
</span></code></pre></pre>
<p>Comment cũng có thể được đặt cuối dòng code, nếu nó ngắn gọn và đơn giản:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h2>
<p>Doc comments sẽ được Compiler parse thành <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">HTML documentation</a>
khi render document bằng <a href="basic/code-comment/./cargo-doc.html"><code>cargo doc</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Generate library docs for the following item.
//! Generate library docs for the enclosing item.
<span class="boring">}
</span></code></pre></pre>
<p>Doc comments sẽ cực kỳ hữu ích cho project lớn và cần một hệ thống document chính xác và up to date.</p>
<p><code>//!</code> sẽ generate doc cho crate/mod trong file hiện tại.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![crate_name = &quot;playground&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp;self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre></pre>
<p>Chúng ta có thể thậm chí comment lại example code hoặc cách sử dụng một function nào đó,
code này cũng sẽ được compile và test, đảm bảo được code và document 
luôn luôn chính xác với nhau, một giải pháp khá thông minh.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-comments-1"><a class="header" href="#doc-comments-1">Doc comments</a></h2>
<p>Doc comments sẽ được Compiler parse thành <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">HTML documentation</a>
khi render document bằng <a href="basic/code-comment/./cargo-doc.html"><code>cargo doc</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Generate library docs for the following item.
//! Generate library docs for the enclosing item.
<span class="boring">}
</span></code></pre></pre>
<p>Doc comments sẽ cực kỳ hữu ích cho project lớn và cần một hệ thống document chính xác và up to date.</p>
<p><code>//!</code> sẽ generate doc cho crate/mod trong file hiện tại.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![crate_name = &quot;playground&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp;self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre></pre>
<p>Chúng ta có thể thậm chí comment lại example code hoặc cách sử dụng một function nào đó,
code này cũng sẽ được compile và test, đảm bảo được code và document 
luôn luôn chính xác với nhau, một giải pháp khá thông minh.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turbofish-"><a class="header" href="#turbofish-">Turbofish ::&lt;&gt;</a></h1>
<p><img src="https://blog.duyet.net/static/a4e75d7d370caf2b035a94ab66138e47/3fe5e/rust-turbofish.webp" alt="Rust Turbofish" /></p>
<p>Trong trường hợp bạn cần chỉ định kiểu dữ liệu cho một generic function, method, struct, hoặc enum, 
Rust có một cú pháp đặc biệt để làm điều này gọi là turbofish. Quy tắc là khi nào bạn thấy</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">$ident&lt;T&gt;
</code></pre></pre>
<p>trong bất kỳ định nghĩa nào, thì bạn có thể sử dụng nó dưới dạng</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">$ident::&lt;T&gt;
</code></pre></pre>
<p>để chỉ định kiểu dữ liệu cho generic parameter. Sau đây là một số ví dụ để làm rõ hơn.</p>
<h1 id="generic-function"><a class="header" href="#generic-function">Generic Function</a></h1>
<p>Ví dụ function <code>std::mem::size_of()</code> có definition như sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn size_of&lt;T&gt;() -&gt; usize
</code></pre></pre>
<p>Khi gọi <code>size_of</code> với turbofish:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">std::mem::size_of::&lt;u32&gt;()
// 4
</code></pre></pre>
<p>sẽ cho ta biết size của u32 theo số bytes.</p>
<h1 id="generic-method"><a class="header" href="#generic-method">Generic Method</a></h1>
<p>Phương thức <code>parse()</code> của <code>str</code> bạn cũng sẽ hay gặp cách sử dụng với cú pháp turbofish:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt; where F: FromStr
</code></pre></pre>
<p>Chúng ta có thể sử dụng turbofish để mô tả kiểu dữ liệu sẽ được parsed từ <code>str</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">&quot;1234&quot;.parse::&lt;u32&gt;()
</code></pre></pre>
<p>Một ví dụ phổ biến nữa là <code>collect()</code> của <code>Iterator</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator&lt;Self::Item&gt; 
</code></pre></pre>
<p>Bởi vì compiler đã biết kiểu dữ liệu của <code>Self::Item</code> mà ta đang collect rồi, 
chúng ta thường không cần ghi ra. Thay vào đó là sử dụng <code>_</code> để compiler tự động infer ra. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let a = vec![1u8, 2, 3, 4];

a.iter().collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre></pre>
<p>Sẵn tiện nói về <code>Iterator</code> chúng ta cũng có thể sử dụng turbofish syntax với <code>sum()</code> và <code>product()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn sum&lt;S&gt;(self) -&gt; S where S: Sum&lt;Self::Item&gt;
fn product&lt;P&gt;(self) -&gt; P where P: Product&lt;Self::Item&gt;
</code></pre></pre>
<p>Cú pháp như sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">[1, 2, 3, 4].iter().sum::&lt;u32&gt;()
[1, 2, 3, 4].iter().product::&lt;u32&gt;()
</code></pre></pre>
<h1 id="generic-struct-1"><a class="header" href="#generic-struct-1">Generic Struct</a></h1>
<p>Trong trường hợp compiler không có đủ thông tin để infer khi tạo generic struct, 
chúng ta cũng có thể sử dụng turbofish syntax. Ví dụ struct <code>Vec</code> có định nghĩa như sau</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub struct Vec&lt;T&gt; { /* fields omitted */ }
</code></pre></pre>
<p>Ví dụ để khởi tạo <code>Vec</code> mới với <code>Vec::new()</code> ta có thể viết</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">Vec::&lt;u8&gt;::new()
</code></pre></pre>
<p>Nhớ là ta bỏ turbofish sau <code>Vec::</code> không phải sau method <code>new</code> 
bởi vì struct sử dụng generic type chứ không phải method <code>new</code>. 
Hơi bựa nhưng nó vẫn thỏa quy tắc của turbofish. Một ví dụ khác</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">std::collections::HashSet::&lt;u8&gt;::with_capacity(10) 
</code></pre></pre>
<p>Ta đang tạo một <code>Hashset</code> với 10 phần tử, bởi vì <code>Hashset</code> struct có định nghĩa như sau</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub struct HashSet&lt;T, S = RandomState&gt; { /* fields omitted */ } 
</code></pre></pre>
<p>Chúng ta có thể sử dụng cú pháp này với mọi Rust collections.</p>
<h1 id="generic-enum-1"><a class="header" href="#generic-enum-1">Generic Enum</a></h1>
<p>Tuy nhiên Enum lại không theo quy tắc trên, bởi vì enum trong Rust không được 
scoped tại enum name, do đó ta đặt turbofish sau enum variant. 
Ví dụ hãy xem enum <code>Result</code> được dùng rất nhiều trong Rust</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[must_use]
pub enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}
</code></pre></pre>
<p>Chúng ta sử dụng như thế này:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">Result::Ok::&lt;u8, ()&gt;(10)
Result::Err::&lt;u8, ()&gt;(())
</code></pre></pre>
<p>Và bởi vì <code>Result</code> thường được prelude (import sẵn)
trong Rust, thực tế mọi người sẽ viết như thế này:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">Ok::&lt;u8, ()&gt;(10)
Err::&lt;u8, ()&gt;(()) 
</code></pre></pre>
<h1 id="references-5"><a class="header" href="#references-5">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-00-generics.html#generic-types-traits-and-lifetimes">Generic Types, Traits, and Lifetimes</a></li>
<li><a href="https://doc.rust-lang.org/book/generics.html">Generics in the rust book</a></li>
<li><a href="https://doc.rust-lang.org/book/syntax-index.html">Rust syntax index</a></li>
<li><a href="https://matematikaadit.github.io/posts/rust-turbofish.html">https://matematikaadit.github.io/posts/rust-turbofish.html</a></li>
<li><a href="https://techblog.tonsser.com/posts/what-is-rusts-turbofish">https://techblog.tonsser.com/posts/what-is-rusts-turbofish</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">macros!</a></h1>
<p>Mới bắt đầu với Rust chúng ta thường sử dụng rất nhiều macro như <code>println!</code>.</p>
<p>Thực chất có 3 loại macro trong Rust.</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the derive attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<h1 id="sự-khác-nhau-giữa-macros-và-functions"><a class="header" href="#sự-khác-nhau-giữa-macros-và-functions">Sự khác nhau giữa Macros và Functions</a></h1>
<p>TODO</p>
<h1 id="macros-mặc-định"><a class="header" href="#macros-mặc-định">Macros mặc định</a></h1>
<p>Standard Macros được định nghĩa bởi compiler và <a href="https://doc.rust-lang.org/std">std</a>.</p>
<pre><code>print!, println!, eprint!, eprintln!
format!, format_args!
write!, writeln!

concat!, concat_idents!, stringify // concat_idents: nightly-only experimental API

include!, include_bytes!, include_str!

assert!, assert_eq!, assert_ne!
debug_assert!, debug_assert_eq!, debug_assert_ne!

try!, panic!, compile_error!, unreachable!, unimplemented!

file!, line!, column!, module_path!
env!, option_env!
cfg!

select!, thread_local! // select: nightly-only experimental API

vec!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros-mặc-định-1"><a class="header" href="#macros-mặc-định-1">Macros mặc định</a></h1>
<p>Standard Macros được định nghĩa bởi compiler và <a href="https://doc.rust-lang.org/std">std</a>.</p>
<pre><code>print!, println!, eprint!, eprintln!
format!, format_args!
write!, writeln!

concat!, concat_idents!, stringify // concat_idents: nightly-only experimental API

include!, include_bytes!, include_str!

assert!, assert_eq!, assert_ne!
debug_assert!, debug_assert_eq!, debug_assert_ne!

try!, panic!, compile_error!, unreachable!, unimplemented!

file!, line!, column!, module_path!
env!, option_env!
cfg!

select!, thread_local! // select: nightly-only experimental API

vec!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="println"><a class="header" href="#println"><code>println!</code></a></h1>
<p>Đây là một trong những macro được dùng nhiều nhất trong Rust.
Giúp in nội dung ra standard output, với một dấu newline xuống dòng.</p>
<p><code>println!</code> có cùng cú pháp với <a href="basic/macro/./format.html">format!</a>.</p>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">println!(); // prints just a newline
println!(&quot;hello there!&quot;);
println!(&quot;format {} arguments&quot;, &quot;some&quot;);
</code></pre></pre>
<h1 id="in-một-struct"><a class="header" href="#in-một-struct">In một Struct</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct MyStruct {
  item: String,
  n: i32,
}

let my_struct = MyStruct {
  item: &quot;duyet&quot;.to_string(),
  n: 99,
};

println!(&quot;my struct = {:?}&quot;, my_struct); // my struct = MyStruct { item: &quot;duyet&quot;, n: 99 }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format"><code>format!</code></a></h1>
<p>Đây là một trong những macro được dùng nhiều nhất trong Rust.</p>
<p><code>format!()</code> giúp khởi tạo một <code>String</code>. Tham số đầu tiên của <code>format!</code> là chuỗi định dạng. 
Sức mạnh của format string này ở trong các <code>{}</code>.</p>
<p>Xem các ví dụ sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021"><span class="boring">fn main() {
</span>format!(&quot;test&quot;);
format!(&quot;hello {}&quot;, &quot;world!&quot;);
format!(&quot;x = {}, y = {y}&quot;, 10, y = 30);

let z = 100;
format!(&quot;z = {z}&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="to_string-để-convert-một-giá-trị-thành-string"><a class="header" href="#to_string-để-convert-một-giá-trị-thành-string"><code>.to_string()</code> để convert một giá trị thành String</a></h2>
<p>Để convert một giá trị thành <code>String</code>, thay vì sử dụng <code>format!()</code> thì người ta hay sử dụng 
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html">to_string</a>. 
Method này sẽ sử dụng <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a> formatting trait.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021"><span class="boring">fn main() {
</span>// Thay vì
format!(&quot;single string&quot;);

// Sử dụng
&quot;single string&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<h1 id="references-6"><a class="header" href="#references-6">References</a></h1>
<ul>
<li>https://doc.rust-lang.org/std/macro.format.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo"><code>todo!</code></a></h1>
<p>Đôi khi bạn sẽ cần viết code một cách tổng quát, 
định nghĩa một loạt các function trước để hình dung ra flow của project,
liệt kê sẵn một loạt các function mà bạn dự định sẽ implementent và sử dụng sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Book {} // Okay, first I need a book struct.
               // Nothing in there yet - will add later

enum BookType { // A book can be hardcover or softcover, so add an enum
    HardCover,
    SoftCover,
}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {} // ⚠️ get_book should take a &amp;Book and return an Option&lt;String&gt;

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {} // delete_book should take a Book and return a Result...
                                                    // TODO: impl block and make these functions methods...
fn check_book_type(book_type: &amp;BookType) { // Let's make sure the match statement works
    match book_type {
        BookType::HardCover =&gt; println!(&quot;It's hardcover&quot;),
        BookType::SoftCover =&gt; println!(&quot;It's softcover&quot;),
    }
}

fn main() {
    let book_type = BookType::HardCover;
    check_book_type(&amp;book_type); // Okay, let's check this function!
}
</code></pre></pre>
<p>Chúng ta chưa dùng đến, nhưng compiler vẫn sẽ không happy với <code>get_book</code> và <code>delete_book</code>.</p>
<pre><code>error[E0308]: mismatched types
  --&gt; src\main.rs:32:29
   |
32 | fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {}
   |    --------                 ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::option::Option&lt;std::string::String&gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&gt; src\main.rs:34:31
   |
34 | fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {}
   |    -----------                ^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::result::Result&lt;(), std::string::String&gt;`
           found unit type `()`
</code></pre>
<p>Khi này chúng ta sử dụng <code>todo!()</code>, Rust sẽ compile và không complain gì về những function dang dở này nữa.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Book {}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {
    todo!() // todo means &quot;I will do it later, please be quiet&quot;
}

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {
    todo!()
}

fn main() {}
</code></pre></pre>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.todo.html">https://doc.rust-lang.org/std/macro.todo.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-1"><a class="header" href="#match-1">match</a></h1>
<p><code>match</code> được dùng khá phổ biến trong Rust (Pattern Syntax).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-giá-trị"><a class="header" href="#matching-giá-trị">Matching giá trị</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-multiple"><a class="header" href="#matching-multiple">Matching Multiple</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes"><code>#[attributes]</code></a></h1>
<p>Attribute là metadata được apply cho một số module, crate hoặc item.
Metadata này được dùng cho việc:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">conditional compilation of code</a>: compile code theo điều kiện, ví dụ một số code sẽ chỉ được compile cho tests, cho OS cụ thể, cho một số feature nào đó, etc.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// This function only gets compiled if the target OS is linux
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;);
}

// And this function only gets compiled if the target OS is *not* linux
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;);
}
</code></pre></pre>
</li>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/attribute/crate.html">set crate name, version and type (binary or library)</a></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// This crate is a library
#![crate_type = &quot;lib&quot;]
// The library is named &quot;rary&quot;
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}
</code></pre></pre>
</li>
<li>
<p>disable lints (warnings)</p>
</li>
<li>
<p>bật một số tính năng của compiler (macros, glob imports, etc.)</p>
</li>
<li>
<p>link đến foreign library</p>
</li>
<li>
<p>đánh dấu các function là unit tests</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[test]
fn test_hello() {
    assert!(&quot;hello&quot;);
}
</code></pre></pre>
</li>
<li>
<p>đánh dấu function là một phần của benchmark</p>
</li>
</ul>
<p>Khi một attributes được apply cho cả crate, cú pháp là <code>#![crate_attribute]</code>.
Khi apply cho một module hoặc item, cú pháp là <code>#[item_attribute]</code> (không có dấu <code>!</code>).</p>
<p>Attributes cũng có thể có tham số:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Attributes có thể có nhiều giá trị, có thể break thành nhiều dòng:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[attribute(value, value2)]

#[attribute(value, value2, value3,
            value4, value5)]
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xử-lý-lỗi"><a class="header" href="#xử-lý-lỗi">Xử lý lỗi</a></h1>
<p>Có rất nhiều cách để deal với error trong Rust. Bạn vui lòng xem trong các trang tiếp theo,
mặc dù có nhiều cách để xử lý tùy theo các trường hợp khác nhau, có một quy luật chung:</p>
<ul>
<li><code>panic</code> hầu hết hữu ích trong khi tests (panic khi test fail) hoặc đối mặt với các lỗi không thể xử lý được.</li>
<li><code>Option</code> khi một giá trị nào đó là không bắt buộc hoặc thiếu các giá trị này vẫn không gây lỗi cho chương trình. Chỉ sử dụng <code>unwrap()</code> khi prototyping hoặc các trường hợp chắc chắn luôn luôn có giá trị. Tuy nhiên <code>expect()</code> thì ổn hơn bởi nó giúp chúng ta bỏ thêm error message khi có biến. </li>
<li>Khi có khả năng một function nào đó có thể lỗi, và người gọi function bắt buộc phải xử lý lỗi đó, hãy sử dụng <code>Result</code>. Vui lòng chỉ sử dụng <code>unwrap()</code> và <code>expect()</code> trong khi test hoặc prototype.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic</a></h1>
<p>Cơ chế đơn giản nhất để xử lý lỗi là <code>panic!</code>. Panic sẽ in error message 
và thường sẽ thoát chương trình.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn drink(beverage: &amp;str) {
    if beverage == &quot;lemonade&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;Some refreshing {} is all I need.&quot;, beverage);
}

fn main() {
    drink(&quot;water&quot;);
    drink(&quot;lemonade&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-1"><a class="header" href="#option-1"><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a></a></h1>
<p>Nhiều ngôn ngữ sử dụng kiểu dữ liệu <code>null</code> hoặc <code>nil</code> hoặc <code>undefined</code> 
để đại diện cho các giá trị rỗng hoặc không tồn tại, và sử dụng <code>Exception</code> 
để xử lý lỗi. Rust bỏ qua hai khái niệm này, để tránh gặp phải các lỗi phổ biến 
như <strong>null pointer exceptions,</strong> hay <strong>lộ thông tin nhạy cảm thông qua exceptions,</strong> ... 
Thay vào đó, Rust giới thiệu hai generic enums <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> 
và <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> để giải quyết các vấn đề trên.</p>
<hr />
<p>Trong hầu hết các ngôn ngữ họ C (C, C#, Java, ...), để xác định một cái gì đó failed 
hay không tìm được giá trị thỏa mãn, chúng ta thường trả về một giá trị <em>&quot;đặc biệt&quot;</em> nào đó.
Ví dụ <code>indexOf()</code> của Javascript scan một phần tử trong mảng, 
trả về vị trí của phần tử đó trong mảng. Và trả về <code>-1</code> nếu không tìm thấy. </p>
<p>Dẫn đến, ta sẽ thường thấy một số đoạn code như sau đây:</p>
<pre><code class="language-typescript">// Typescript

let sentence = &quot;The fox jumps over the dog&quot;;
let index = sentence.indexOf(&quot;fox&quot;);

if (index &gt; -1) {
  let result = sentence.substr(index);
  console.log(result);
}
</code></pre>
<p>Như bạn thấy <code>-1</code> là một trường hợp đặc biệt cần xử lý. 
Có khi nào bạn đã từng mắc lỗi ngớ ngẫn vì tưởng giá trị đặc biệt đó là <code>0</code> chưa?</p>
<pre><code class="language-typescript">// Typescript

if (index &gt; 0) {
  // 3000 days of debugging
}
</code></pre>
<p><code>&quot;&quot;</code> hay <code>null</code> hay <code>None</code> cũng là một trong những trường hợp đặc biệt đó. 
Bạn đã từng nghe đến <strong><strong><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a></strong></strong>?</p>
<p>Lý do cơ bản là không có gì chắc chắn và có thể ngăn bạn lại việc ... <strong>quên</strong> 
xử lý mọi trường hợp giá trị đặc biệt, hoặc do chương trình trả về các giá trị đặc biệt không như mong đợi.
Có nghĩa là ta có thể <em>vô tình</em> làm crash chương trình với một lỗi nhỏ ở bất kỳ đâu, ở bất kỳ thời điểm nào.</p>
<p>Rust làm điều này tốt hơn, chỉ với <code>Option</code>. </p>
<p>Một giá trị optional có thể mang một giá trị nào đó <strong>Some(something)</strong> hoặc không mang giá trị nào cả (<strong>None</strong>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An output can have either Some value or no value/ None.
enum Option&lt;T&gt; { // T is a generic and it can contain any type of value.
  Some(T),
  None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Theo thiết kế, mặc định bạn sẽ không bao giờ lấy được giá trị bạn cần nếu không xử lý 
các trường hợp có thể xảy ra với <code>Option</code>, là <code>None</code> chẳng hạn. 
Điều này được bắt buộc bởi compiler lúc compile code, 
có nghĩa là nếu bạn quên check, code sẽ không bao giờ được compile.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sentence = &quot;The fox jumps over the dog&quot;;
let index = sentence.find(&quot;fox&quot;);

if let Some(fox) = index {
  let words_after_fox = &amp;sentence[fox..];
  println!(&quot;{}&quot;, words_after_fox);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="cách-sử-dụng-option-1"><a class="header" href="#cách-sử-dụng-option-1"><strong>Cách sử dụng Option</strong></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> là standard library, do đã được 
<a href="https://learning-rust.github.io/docs/d7.std_primitives_and_preludes.html#Preludes">preludes</a> 
nên chúng ta không cần khai báo trước khi sử dụng. Ngoài enum 
<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> thì các variant của nó cũng đã được preludes 
sẵn như <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some">Some</a> 
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None">None</a>.</p>
<p>Ví dụ, ta có một function tính giá trị chia hai số, 
đôi khi sẽ không tìm ra được kết quả, ta sử dụng Some như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Option&lt;i32&gt; {
    if !name.starts_with('d') {
        return None;
    }

    Some(123)
}

fn main() {
    let name = &quot;duyet&quot;;

    match get_id_from_name(name) {
        Some(id) =&gt; println!(&quot;User = {}&quot;, id),
        _ =&gt; println!(&quot;Not found&quot;),
    }
}
</code></pre></pre>
<p>Ta thường sử dụng <code>match</code> để bắt giá trị trả về (<code>Some</code> hoặc <code>None</code>). </p>
<p>Bạn sẽ bắt gặp rất nhiều method khác nhau để xử lý giá trị của <code>Option</code></p>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> method overview: <a href="https://doc.rust-lang.org/std/option/#method-overview">https://doc.rust-lang.org/std/option/#method-overview</a></p>
<h3 id="unwrap-3"><a class="header" href="#unwrap-3"><code>.unwrap()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some(T)</code>. Nếu giá trị là <code>None</code> thì panic chương trình. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(&quot;air&quot;);
assert_eq!(x.unwrap(), &quot;air&quot;);

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), &quot;air&quot;); // panic!
<span class="boring">}
</span></code></pre></pre>
<h3 id="expect-3"><a class="header" href="#expect-3"><code>.expect()</code></a></h3>
<p>Giống <code>.unwrap()</code>, nhưng khi panic thì Rust sẽ kèm theo message</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;&amp;str&gt; = None;
x.expect(&quot;fruits are healthy&quot;); // panics: `fruits are healthy`
<span class="boring">}
</span></code></pre></pre>
<h3 id="unwrap_or-1"><a class="header" href="#unwrap_or-1"><code>.unwrap_or()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá trị nằm trong <code>or</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some(&quot;car&quot;).unwrap_or(&quot;bike&quot;), &quot;car&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="unwrap_or_default-2"><a class="header" href="#unwrap_or_default-2"><code>.unwrap_or_default()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_year_from_input = &quot;1909&quot;;
let bad_year_from_input = &quot;190blarg&quot;;
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
<span class="boring">}
</span></code></pre></pre>
<h3 id="ok_or-1"><a class="header" href="#ok_or-1"><code>.ok_or()</code></a></h3>
<p>Convert <code>Option&lt;T&gt;</code> sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>, 
mapping <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some"><code>Some(v)</code></a> 
thành <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok(v)</code></a> 
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None"><code>None</code></a> 
sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err(err)</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(&quot;foo&quot;);
assert_eq!(x.ok_or(0), Ok(&quot;foo&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="match-2"><a class="header" href="#match-2"><code>match</code></a></h3>
<p>Chúng ta có thể sử dụng pattern matching để code dễ đọc hơn</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_name(who: Option&lt;String&gt;) -&gt; String {
  match who {
    Some(name) =&gt; format!(&quot;Hello {}&quot;, name),
    None       =&gt; &quot;Who are you?&quot;.to_string(), 
  }
}

get_name(Some(&quot;duyet&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="if-let-somex--x-2"><a class="header" href="#if-let-somex--x-2">if let Some(x) = x</a></h3>
<p>Có thể bạn sẽ gặp pattern này nhiều khi đọc code Rust.
Nếu giá trị của <code>x</code> là <code>Some</code> thì sẽ destruct 
giá trị đó bỏ vào biến <code>x</code> nằm trong scope của <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; Option&lt;String&gt; {
    Some(&quot;ok&quot;.to_string())
}

if let Some(data) = get_data() {
    println!(&quot;data = {}&quot;, data);
} else {
    println!(&quot;no data&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1"><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a></a></h1>
<p>Tương tự như <a href="basic/error-handling/./option.html"><code>Option</code></a>. 
Một kết quả trả về (<a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a>)
của một function thường sẽ có hai trường hợp:</p>
<ul>
<li>thành công (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>) và trả về kết quả</li>
<li>hoặc lỗi (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>) và trả về thông tin lỗi.</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a> là một phiên bản cao cấp hơn của <a href="basic/error-handling/../option/README.html"><code>Option</code></a>.
Nó mô tả <em>lỗi gì</em> đang xảy ra thay vì khả năng <em>tồn tại</em> giá trị hay không.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Ví dụ</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; {
    if !name.starts_with('d') {
        return Err(&quot;not found&quot;);
    }

    Ok(123)
}

fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    let name = &quot;duyet&quot;;

    match get_id_from_name(name) {
        Ok(id) =&gt; println!(&quot;User = {}&quot;, id),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    };

    Ok(())
}
</code></pre></pre>
<p>Như bạn thấy thì <code>main()</code> cũng có thể return về <code>Result&lt;(), &amp;'static str&gt;</code></p>
<h3 id="unwrap-4"><a class="header" href="#unwrap-4"><code>.unwrap()</code></a></h3>
<p>Ví dụ trên nhưng sử dụng <code>.unwrap()</code> , chủ động panic (crash) dừng chương trình nếu gặp lỗi.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = &quot;duyet&quot;;
  let age = get_age(who).unwrap();
  println!(&quot;{} is {}&quot;, who, age);

  Ok(())
}
</code></pre></pre>
<h3 id="expect-4"><a class="header" href="#expect-4"><code>.expect()</code></a></h3>
<p>Giống như <code>unwrap()</code>: chủ động panic (crash) dừng chương trình nếu gặp lỗi và kèm theo message. Sẽ rất có ích, nhất là khi có quá nhiều unwrap, bạn sẽ không biết nó panic ở đâu.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = &quot;ngan&quot;;
  let age = get_age(who).expect(&quot;could not get age&quot;);
  println!(&quot;{} is {}&quot;, who, age);

  Ok(())
}
</code></pre></pre>
<p>Xem thêm mọi method khác của <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> <a href="https://doc.rust-lang.org/std/result/enum.Result.html">tại đây</a>.</p>
<h1 id="convert-result-sang-option-2"><a class="header" href="#convert-result-sang-option-2">Convert <code>Result</code> sang <code>Option</code></a></h1>
<p>Đôi khi bạn sẽ cần convert từ </p>
<ul>
<li><code>Ok(v)</code> sang <code>Some(v)</code>, hoặc</li>
<li><code>Err(e)</code> sang <code>Some(e)</code></li>
</ul>
<h2 id="ok-2"><a class="header" href="#ok-2"><code>.ok()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .ok(v) = Some(v)
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.ok(), Some(2));

let x: Result&lt;u32, &amp;str&gt; = Err(&quot;Nothing here&quot;);
assert_eq!(x.ok(), None);
</code></pre></pre>
<h2 id="err-2"><a class="header" href="#err-2"><code>.err()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .err()
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.err(), None);

let x: Result&lt;u32, &amp;str&gt; = Err(&quot;Nothing here&quot;);
assert_eq!(x.err(), Some(&quot;Nothing here&quot;));
</code></pre></pre>
<h1 id="toán-tử--2"><a class="header" href="#toán-tử--2">Toán tử <code>?</code></a></h1>
<p>Khi viết code mà có quá nhiều functions trả về <a href="basic/error-handling/./result.html"><code>Result</code></a>, việc handle Err sẽ khá nhàm chán. Toán tử chấm hỏi <a href="https://doc.rust-lang.org/std/ops/trait.Try.html">?</a> cho phép dừng function tại vị trí đó và return cho function cha nếu <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ở vị trí đó là Err.</p>
<p>Nó sẽ thay thế đoạn code sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  // Early return on error
  let mut file = match File::create(&quot;my_best_friends.txt&quot;) {
    Err(e) =&gt; return Err(e),
    Ok(f) =&gt; f,
  };
  if let Err(e) = file.write_all(format!(&quot;name: {}\n&quot;, info.name).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!(&quot;age: {}\n&quot;, info.age).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!(&quot;rating: {}\n&quot;, info.rating).as_bytes()) {
    return Err(e)
  }
  Ok(())
}
</code></pre></pre>
<p>thành</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  let mut file = File::create(&quot;my_best_friends.txt&quot;)?;
  // Early return on error
  file.write_all(format!(&quot;name: {}\n&quot;, info.name).as_bytes())?;
  file.write_all(format!(&quot;age: {}\n&quot;, info.age).as_bytes())?;
  file.write_all(format!(&quot;rating: {}\n&quot;, info.rating).as_bytes())?;
  Ok(())
}
</code></pre></pre>
<p>Gọn đẹp hơn rất nhiều.</p>
<p>Toán tử <code>?</code> sẽ unwrap giá trị <code>Ok</code>, hoặc return giá trị <code>Err</code> ở vị trí gần toán tử đó.</p>
<p><code>?</code> chỉ có thể được dùng trong function có kiểu dữ liệu trả về là <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-map"><a class="header" href="#result-map">Result <code>map</code></a></h1>
<p>Ta có thể xử lý giá trị bên trong <code>Result</code> mà không cần xử lý <code>Err</code>, 
trong trường hợp bạn muốn trả <code>Err</code> cho hàm bên trên đó tự lý.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(a: &amp;str, b: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
  match a.parse::&lt;i32&gt;() {
    Ok(first) =&gt; {
      match b.parse::&lt;i32&gt;() {
        Ok(second) =&gt; Ok(first * second),
        Err(e) =&gt; Err(e),
      }
    },
    Err(e) =&gt; Err(e),
  }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
  match result {
    Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
    Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
  }
}

fn main() {
  let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
  print(twenty);

  let tt = multiply(&quot;t&quot;, &quot;2&quot;);
  print(tt);
}
</code></pre></pre>
<p>Thay vào đó ta sử dụng <code>.map()</code>, <code>.and_then()</code> để đoạn code trên hiệu quả và dễ đọc hơn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(a: &amp;str, b: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
  a.parse::&lt;i32&gt;().and_then(|first| {
    b.parse::&lt;i32&gt;().map(|second| first * second)
  })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
  match result {
    Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
    Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
  }
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-alias"><a class="header" href="#result-alias">Result alias</a></h1>
<p>Rust cho phép chúng ta tạo <a href="https://doc.rust-lang.org/rust-by-example/types/alias.html">alias</a>.
Việc alias <code>Result</code> sẽ tiết kiệm chúng ta rất nhiều thời gian, 
nhất là trong cùng một module và ta đang cố reuse <code>Result</code> nhiều lần.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// Define a generic alias for a `Result` with the error type `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Use the above alias to refer to our specific `Result` type.
fn multiply(a: &amp;str, b: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
  a.parse::&lt;i32&gt;().and_then(|first| {
    b.parse::&lt;i32&gt;().map(|second| first * second)
  })
}

fn print(result: AliasedResult&lt;i32&gt;) {
  match result {
    Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
    Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
  }
}

fn main() {
  print(multiply(&quot;10&quot;, &quot;2&quot;));
  print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viết-tests"><a class="header" href="#viết-tests">Viết Tests</a></h1>
<p>Rust được thiết kế để đưa tính đúng đắn của chương trình lên hàng đầu.
Như bạn đã thấy với những gì mà borrow checkers của compiler hay hệ thống type
đã làm. Nhưng tính đúng đắn thì cực kỳ phức tạp và Rust không thể đảm bảo hết điều này.</p>
<p>Tuy nhiên, testing lại là một kỹ năng phức tạp. Mục tiêu của 
phần này mình sẽ không bàn đến việc viết good tests như thế nào, 
chúng ta sẽ bàn về những gì mà Rust cung cấp để giúp chúng ta viết tests, 
những công cụ, macros, chạy tests, cách tổ chức unit tests 
và integration tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tổ-chức-tests"><a class="header" href="#tổ-chức-tests">Tổ chức Tests</a></h1>
<p>Testing là một kỹ năng phức tạp. Nhiều lập trình viên sử dụng nhiều thuật ngữ khác nhau
và tổ chức code tests khác nhau. Cộng đồng Rust đặt ra hai loại tests:</p>
<ul>
<li><em>Unit tests</em>: nhỏ và tập trung vào một function, module độc lập tại một thời điểm.</li>
<li><em>Integration tests</em>: tests nằm ngoài thư viện của bạn, sử dụng thư viện của bạn để tests như thể là một chương trình thực tế sẽ thực sự sử dụng. Chỉ test trên public interface và tập trung vào cả 1 module cho một test.</li>
</ul>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>Unit tests được đặt trong thư mục <code>src</code> trong mỗi file code mà bạn đang test.
Có một convention là tạo một module tên <code>tests</code> trong mỗi file chứa function cần test,
annotate module này với attribute <code>#[cfg(test)]</code>.</p>
<h3 id="cfgtest"><a class="header" href="#cfgtest"><code>#[cfg(test)]</code></a></h3>
<p><code>#[cfg(test)]</code> báo cho compiler biết module này được dùng để compile thành test, chỉ được dùng 
khi chạy <code>cargo test</code>, không dùng khi <code>cargo build</code>.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Trong module <code>tests</code> có thể sẽ có một vài helper function khác, do đó những function nào
là function test sẽ được đánh dấu là <code>#[test]</code> để compiler nhận biết.</p>
<h3 id="test-private-function"><a class="header" href="#test-private-function">Test private function</a></h3>
<p>Ở ví dụ trên thì public function <code>adder</code> được import vào trong module <code>tests</code> theo đúng rule của Rust.
Vậy còn private function thì sao? Có một cuộc tranh cãi trong cộng đồng về việc này.
Cuối cùng thì Rust cho phép import private function vào <code>tests</code> module.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    adder_internal(a, b)
}

fn adder_internal(a: i32, b: i32) -&gt; i32 {
    a + b
}
 
#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder_internal(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests nằm hoàn toàn bên ngoài thư viện của bạn.
Mục đích của integration tests nhằm kiểm tra các thành phần của
thư viện của bạn hoạt động cùng với nhau có chính xác không.</p>
<p>Để bắt đầu viết integration tests, tạo thư mục <code>tests</code> nằm cùng cấp với <code>src</code>.</p>
<p>Trong thư mục <code>tests</code>, cargo sẽ compile mỗi file thành một thành một crate độc lập.</p>
<p>File: tests/integration_test.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adder;

#[test]
fưn it_adds_two() {
  assert_eq!(4, adder::adder(2, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Ở đây chúng ta import <code>use adder</code> thay vì <code>use crate::</code> 
do file integration test này là một crate độc lập.</p>
<p>Chạy <code>cargo test</code></p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::test_adder ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00sđ
</code></pre>
<p>Do integration tests phải import thư viện để chạy test code, crate bắt buộc phải có <code>src/lib.rs</code>.
Các binary crates không thể test theo cách này.</p>
<p>Do đó các project Rust họ thường tổ chức theo kiểu build binary từ <code>src/main.rs</code> và import trực tiếp logic từ <code>src/lib.rs</code>.</p>
<h4 id="references-8"><a class="header" href="#references-8">References</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#submodules-in-integration-tests">Submodules in Integration Tests</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></li>
</ul>
<h2 id="doc-tests"><a class="header" href="#doc-tests">Doc Tests</a></h2>
<p>Rust cũng hỗ trợ execute code ví dụ trên document như là một test.
Đây là giải pháp cực kỳ thông minh giúp đảm bảo example code luôn up to date 
và nó có hoạt động.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Function that adding two number
///
/// # Example
///
/// ```
/// use adder::adder;
/// 
/// assert_eq!(4, adder(2, 2));
/// ```
pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>Khi chạy <code>cargo test</code> hoặc <code>cargo test --doc</code>, cargo sẽ compile
phần example code này thành một crate test và thực thi nó.</p>
<p>Mặc định nếu không chỉ định ngôn ngữ cho block code thì rustdoc sẽ
ngầm định nó là Rust code. Do đó</p>
<pre><code class="language-md">```
let x = 5;
```
</code></pre>
<p>sẽ tương đương với</p>
<pre><code>```rust
let x = 5;
```
</code></pre>
<h3 id="Ẩn-một-phần-của-example-code"><a class="header" href="#Ẩn-một-phần-của-example-code">Ẩn một phần của example code</a></h3>
<p>Đôi lúc bạn sẽ cần example code gọn hơn, 
ẩn bớt một số logic mà bạn chuẩn bị để code có thể chạy được, 
tránh làm distract của người xem.</p>
<pre><code>/// ```
/// /// Some documentation.
/// # fn foo() {} // this function will be hidden
/// println!(&quot;Hello, World!&quot;);
/// ```
</code></pre>
<p>Chúng ta thêm <code>#</code> ở phần đầu của dòng code muốn ẩn đi trong generate doc,
nó vẫn sẽ được compile như mình thường.</p>
<h3 id="sử-dụng--trong-doc-tests"><a class="header" href="#sử-dụng--trong-doc-tests">Sử dụng <code>?</code> trong doc tests</a></h3>
<p><code>?</code> chỉ có thể được sử dụng khi function trả về <code>Result&lt;T, E&gt;</code>. Hãy sử dụng cách sau:</p>
<pre><code>/// A doc test using ?
///
/// ```
/// use std::io;
/// fn main() -&gt; io::Result&lt;()&gt; {
///     let mut input = String::new();
///     io::stdin().read_line(&amp;mut input)?;
///     Ok(())
///  }
/// ```
</code></pre>
<p>Cùng với việc sử dụng <code>#</code> như ở trên, chúng ta có thể ẩn đi bớt logic.</p>
<pre><code>/// A doc test using ?
///
/// ```
/// # use std::io;
/// # fn main() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok(())
/// # }
/// ```
</code></pre>
<h3 id="references-9"><a class="header" href="#references-9">References</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h2>
<p>Unit tests được đặt trong thư mục <code>src</code> trong mỗi file code mà bạn đang test.
Có một convention là tạo một module tên <code>tests</code> trong mỗi file chứa function cần test,
annotate module này với attribute <code>#[cfg(test)]</code>.</p>
<h3 id="cfgtest-1"><a class="header" href="#cfgtest-1"><code>#[cfg(test)]</code></a></h3>
<p><code>#[cfg(test)]</code> báo cho compiler biết module này được dùng để compile thành test, chỉ được dùng 
khi chạy <code>cargo test</code>, không dùng khi <code>cargo build</code>.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Trong module <code>tests</code> có thể sẽ có một vài helper function khác, do đó những function nào
là function test sẽ được đánh dấu là <code>#[test]</code> để compiler nhận biết.</p>
<h3 id="test-private-function-1"><a class="header" href="#test-private-function-1">Test private function</a></h3>
<p>Ở ví dụ trên thì public function <code>adder</code> được import vào trong module <code>tests</code> theo đúng rule của Rust.
Vậy còn private function thì sao? Có một cuộc tranh cãi trong cộng đồng về việc này.
Cuối cùng thì Rust cho phép import private function vào <code>tests</code> module.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    adder_internal(a, b)
}

fn adder_internal(a: i32, b: i32) -&gt; i32 {
    a + b
}
 
#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder_internal(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h2>
<p>Integration tests nằm hoàn toàn bên ngoài thư viện của bạn.
Mục đích của integration tests nhằm kiểm tra các thành phần của
thư viện của bạn hoạt động cùng với nhau có chính xác không.</p>
<p>Để bắt đầu viết integration tests, tạo thư mục <code>tests</code> nằm cùng cấp với <code>src</code>.</p>
<p>Trong thư mục <code>tests</code>, cargo sẽ compile mỗi file thành một thành một crate độc lập.</p>
<p>File: tests/integration_test.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adder;

#[test]
fưn it_adds_two() {
  assert_eq!(4, adder::adder(2, 2));
}
<span class="boring">}
</span></code></pre></pre>
<p>Ở đây chúng ta import <code>use adder</code> thay vì <code>use crate::</code> 
do file integration test này là một crate độc lập.</p>
<p>Chạy <code>cargo test</code></p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::test_adder ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00sđ
</code></pre>
<p>Do integration tests phải import thư viện để chạy test code, crate bắt buộc phải có <code>src/lib.rs</code>.
Các binary crates không thể test theo cách này.</p>
<p>Do đó các project Rust họ thường tổ chức theo kiểu build binary từ <code>src/main.rs</code> và import trực tiếp logic từ <code>src/lib.rs</code>.</p>
<h4 id="references-10"><a class="header" href="#references-10">References</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#submodules-in-integration-tests">Submodules in Integration Tests</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-tests-1"><a class="header" href="#doc-tests-1">Doc Tests</a></h2>
<p>Rust cũng hỗ trợ execute code ví dụ trên document như là một test.
Đây là giải pháp cực kỳ thông minh giúp đảm bảo example code luôn up to date 
và nó có hoạt động.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Function that adding two number
///
/// # Example
///
/// ```
/// use adder::adder;
/// 
/// assert_eq!(4, adder(2, 2));
/// ```
pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>Khi chạy <code>cargo test</code> hoặc <code>cargo test --doc</code>, cargo sẽ compile
phần example code này thành một crate test và thực thi nó.</p>
<p>Mặc định nếu không chỉ định ngôn ngữ cho block code thì rustdoc sẽ
ngầm định nó là Rust code. Do đó</p>
<pre><code class="language-md">```
let x = 5;
```
</code></pre>
<p>sẽ tương đương với</p>
<pre><code>```rust
let x = 5;
```
</code></pre>
<h3 id="Ẩn-một-phần-của-example-code-1"><a class="header" href="#Ẩn-một-phần-của-example-code-1">Ẩn một phần của example code</a></h3>
<p>Đôi lúc bạn sẽ cần example code gọn hơn, 
ẩn bớt một số logic mà bạn chuẩn bị để code có thể chạy được, 
tránh làm distract của người xem.</p>
<pre><code>/// ```
/// /// Some documentation.
/// # fn foo() {} // this function will be hidden
/// println!(&quot;Hello, World!&quot;);
/// ```
</code></pre>
<p>Chúng ta thêm <code>#</code> ở phần đầu của dòng code muốn ẩn đi trong generate doc,
nó vẫn sẽ được compile như mình thường.</p>
<h3 id="sử-dụng--trong-doc-tests-1"><a class="header" href="#sử-dụng--trong-doc-tests-1">Sử dụng <code>?</code> trong doc tests</a></h3>
<p><code>?</code> chỉ có thể được sử dụng khi function trả về <code>Result&lt;T, E&gt;</code>. Hãy sử dụng cách sau:</p>
<pre><code>/// A doc test using ?
///
/// ```
/// use std::io;
/// fn main() -&gt; io::Result&lt;()&gt; {
///     let mut input = String::new();
///     io::stdin().read_line(&amp;mut input)?;
///     Ok(())
///  }
/// ```
</code></pre>
<p>Cùng với việc sử dụng <code>#</code> như ở trên, chúng ta có thể ẩn đi bớt logic.</p>
<pre><code>/// A doc test using ?
///
/// ```
/// # use std::io;
/// # fn main() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok(())
/// # }
/// ```
</code></pre>
<h3 id="references-11"><a class="header" href="#references-11">References</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xung-đột-biến-môi-trường"><a class="header" href="#xung-đột-biến-môi-trường">Xung đột biến môi trường</a></h1>
<p>Các unit tests trong cùng một module được thực thi song song nhau, trong cùng một process. 
Một trường hợp mà mình đã gặp phải là xung đột do 2 tests cùng sử dụng một biến môi trường
hoặc biến môi trường ảnh hưởng đến kết quả của tests khác.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

#[test]
fn test_one() {
  env::set_var(&quot;KEY&quot;, &quot;value_one&quot;);
  assert_eq!(env::var(&quot;KEY&quot;), Ok(&quot;value_one&quot;.to_string()));
}

#[test]
fn test_one() {
  env::set_var(&quot;KEY&quot;, &quot;value_two&quot;);
  assert_eq!(env::var(&quot;KEY&quot;), Ok(&quot;value_two&quot;.to_string()));
}
<span class="boring">}
</span></code></pre></pre>
<p>Giải pháp ổn nhất hiện tại mình dùng để giải quyết là
<a href="https://docs.rs/serial_test/latest/serial_test/"><code>serial_test</code></a></p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dev-dependencies]
serial_test = &quot;0.9&quot;
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

#[test]
#[serial]
fn test_one() {
  env::set_var(&quot;KEY&quot;, &quot;value_one&quot;);
  assert_eq!(env::var(&quot;KEY&quot;), Ok(&quot;value_one&quot;.to_string()));
}

#[test]
#[serial]
fn test_one() {
  env::set_var(&quot;KEY&quot;, &quot;value_two&quot;);
  assert_eq!(env::var(&quot;KEY&quot;), Ok(&quot;value_two&quot;.to_string()));
}
<span class="boring">}
</span></code></pre></pre>
<p>Các tests có <code>#[serial]</code> sẽ được thực hiện tuần tự nhau, tránh trường hợp xung đột như trước.</p>
<h2 id="references-12"><a class="header" href="#references-12">References</a></h2>
<ul>
<li><a href="https://crates.io/crates/serial_test">https://crates.io/crates/serial_test</a></li>
<li><a href="https://docs.rs/serial_test">https://docs.rs/serial_test</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viết-docs"><a class="header" href="#viết-docs">Viết Docs</a></h1>
<p>Rust mặc định được phát hành cùng với một công cụ gọi là <code>rustdoc</code> hay <code>cargo doc</code>. 
Giúp generate document cho Rust project.</p>
<h2 id="cơ-bản"><a class="header" href="#cơ-bản">Cơ bản</a></h2>
<p>Thử viết 1 crate đơn giản và document nó:</p>
<pre><code class="language-bash">cargo new duyet_lib --lib
cd duyet_lib
</code></pre>
<p>Trong <code>src/lib.rs</code>, Cargo đã generate sẵn 1 đoạn code, hãy xóa và thay nó bằng:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// foo is a function
fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>Bây giờ hãy dùng lệnh sau để generate document và xem nó trên trình duyệt:</p>
<pre><code class="language-bash">cargo doc --open
</code></pre>
<p><code>rustdoc</code> đọc mọi comment <code>///</code>, <code>//!</code> và generate document theo cấu trúc của project.
Nôi dung của document được viết bằng Markdown.</p>
<p>Hãy xem trang <a href="basic/rustdoc/../code-comment/README.html">viết comment sao cho đúng</a> 
và <a href="basic/rustdoc/../code-comment/doc-comment.html">Doc comments</a> 
để biết thêm về cách viết comment doc sao cho chuẩn.</p>
<h2 id="references-13"><a class="header" href="#references-13">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">What is rustdoc?</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">How to write documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-comments-2"><a class="header" href="#doc-comments-2">Doc comments</a></h2>
<p>Doc comments sẽ được Compiler parse thành <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">HTML documentation</a>
khi render document bằng <a href="basic/code-comment/./cargo-doc.html"><code>cargo doc</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Generate library docs for the following item.
//! Generate library docs for the enclosing item.
<span class="boring">}
</span></code></pre></pre>
<p>Doc comments sẽ cực kỳ hữu ích cho project lớn và cần một hệ thống document chính xác và up to date.</p>
<p><code>//!</code> sẽ generate doc cho crate/mod trong file hiện tại.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![crate_name = &quot;playground&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp;self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre></pre>
<p>Chúng ta có thể thậm chí comment lại example code hoặc cách sử dụng một function nào đó,
code này cũng sẽ được compile và test, đảm bảo được code và document 
luôn luôn chính xác với nhau, một giải pháp khá thông minh.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sử-dụng-readmemd-làm-crate-document"><a class="header" href="#sử-dụng-readmemd-làm-crate-document">Sử dụng README.md làm crate document</a></h1>
<p>Nội dung comment dưới đây trong <code>src/lib.rs</code> được gọi là crate document, 
được render thành nội dung trong trang chủ doc của library.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! This is crate document
//!
//! # Usage
//!
//! ```
//! [dependencies]
//! duyet_lib = &quot;0.9&quot;
//! ```
//! ...
<span class="boring">}
</span></code></pre></pre>
<p>Và nội dung này cũng thường sẽ giống với <code>README.md</code> để hiển thị trên Github.
Một cách để tránh lặp lại nội dung và đồng bộ với nhau là <code>rustdoc</code> render trực tiếp
nội dung từ <code>README.md</code>.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc = include_str!(&quot;../README.md&quot;)]
<span class="boring">}
</span></code></pre></pre>
<p>File: README.md</p>
<pre><code class="language-markdown">This is crate document

# Usage

```
[dependencies]
duyet_lib = &quot;0.9&quot;
```
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavioural-patterns"><a class="header" href="#behavioural-patterns">Behavioural Patterns</a></h1>
<p>Theo Wikipedia:</p>
<blockquote>
<p>Behavioural Patterns: Design patterns that identify common communication patterns among objects. By doing so, these patterns increase flexibility in carrying out communication.</p>
</blockquote>
<p>Một số Behavioural Patterns trong Rust</p>
<ul>
<li><a href="design-pattern/behavioural/./strategy.html">Strategy Pattern</a></li>
<li><a href="design-pattern/behavioural/./command.html">Command Pattern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy design pattern</a> 
là một technique nhằm mục đích phân tách nhiều vấn đề, 
tách software modules thông qua <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion</a>. </p>
<p>Ý tưởng cơ bản của Strategy pattern là chỉ cần define skeleton 
ở abstract level, chúng ta tách biệt phần implementation của 
logic thành nhiều phần. Client sử dụng có thể tự implement 
1 số method theo cách riêng của nó nhưng vẫn giữ được cấu trúc
của logic workflow gốc. </p>
<p>Abstract class không không phụ thuộc vào implementation của lớp dẫn xuất (derived class), 
nhưng implementation của lớp dẫn xuất phải tuân thủ theo đặc tả của lớp abstract. 
Cho nên chúng có tên gọi là <strong>Dependency Inversion</strong>.</p>
<p>Một thứ mình thấy rõ là các project Rust rất hay sử dụng Strategy Design Pattern này.</p>
<p>Ví dụ, chúng ta có 1 <code>struct Data</code> và implement một số phương thức để generate ra 
nhiều dạng format khác nhau (ví dụ <code>JSON</code>, <code>YAML</code>, <code>Plain Text</code>, ...). 
Ta gọi mỗi format ở đây là một strategy.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

type Data = HashMap&lt;String, u32&gt;;

impl Data {
  fn generate(&amp;self, format: &amp;str) {
    match format {
      &quot;json&quot; =&gt; { ... }
      &quot;yaml&quot; =&gt; { ... }
      &quot;text&quot; =&gt; { ... }
      _      =&gt; { ... }
    }
  }
}
</code></pre></pre>
<p>Mọi thứ thay đổi theo thời gian, và khó đoán được trong tương lai chương trình 
của chúng ta có thể sửa đổi hoặc bổ sung thêm các loại format nào nữa 
trong tương lai hay không (ví dụ <code>JSONLine</code>, <code>CSV</code>, <code>Parquet</code>, ...)</p>
<p>Nếu thiết kế sử dụng Strategy Pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

// Data
type Data = HashMap&lt;String, u32&gt;;
impl Data {
  // f: T chap nhan moi struct co impl Formatter
  fn generate&lt;T: Formatter&gt;(f: T) -&gt; String {
    f.format(&amp;self)
  }
}

// Formatter
trait Formatter {
  fn format(&amp;self, data: &amp;Data) -&gt; String;
}

// Formatter -&gt; Json
struct Json;
impl Formatter for Json {
  fn format(&amp;self, data: &amp;Data) -&gt; String {
    // res = { &quot;a&quot;: 1, &quot;b&quot;: 2. /// }
    res
  }
}

// Formatter -&gt; Text
struct Text;
impl Formatter for Text {
  fn format(&amp;self, data: &amp;Data) -&gt; String {
    // res = &quot;a = 1, b = 2, ...&quot;
    res
  }
}

fn main() {
  let mut data = Data::new();
  data.insert(&quot;a&quot;.to_string(), 1);
  data.insert(&quot;b&quot;.to_string(), 2);

  let s = data.generate(Text);
  assert!(s.contains(&quot;a = b, b = 2&quot;));

  let s = data.generate(Json);
  assert!(s.contains(r#&quot;{&quot;a&quot;:1, &quot;b&quot;:2}&quot;#));
}
</code></pre></pre>
<p>Theo chúng ta có thể thấy, <code>Data::generate</code> có thể không cần quan tâm implementation
của <code>f: T</code>. Chỉ cần biết nó là một dẫn xuất của <code>trait Formatter</code> và có method <code>format</code>. </p>
<p><strong>Nhược điểm</strong> là mỗi strategy cần được implement ít nhất một module, 
vì thế số lượng module có thể tăng cùng với số lượng strategy. 
Có quá nhiều strategy đòi hỏi user phải biết sự khác nhau giữa các strategy để sử dụng. </p>
<p><strong>Ưu điểm</strong> là chúng ta có thể tách việc xử lý <code>Json</code>, <code>Text</code>, ... ra thành nhiều bài toán (strategy) nhỏ hơn theo như ví dụ trên.</p>
<p>Ở ví dụ trên các strategy được đặt chung ở một file, 
thực tế người ta thưởng đặt ở nhiều module khác nhau hoặc mỗi strategy một file 
(<code>formatter::json</code>, <code>formatter::csv</code>, ...). Việc tách này còn cho phép sử dụng compiler feature flags. </p>
<p>Còn nếu chúng ta đang implement một <code>crate</code>, thì <code>crate</code> ở ví dụ trên user có thể dễ dàng custom một <code>Formatter</code> mới: </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use crate::example::{Data, Formatter};

struct CustomFormatter;

impl Formatter for CustomFormatter {
  fn format(&amp;self, data: &amp;Data) -&gt; String {
    ...
  }
}
</code></pre></pre>
<p><code>serde</code> là một ví dụ hay của <code>Strategy</code> pattern, serde cho phép 
<a href="https://serde.rs/custom-serialization.html">full customization</a> serialization 
behavior bằng cách implement <code>Serialize</code> và <code>Deserialize</code> traits cho kiểu dữ liệu riêng của chúng ta.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h1>
<p>Ý tưởng cơ bản của <a href="https://en.wikipedia.org/wiki/Command_pattern">Command Pattern</a> 
là tách các actions thành các object riêng và gọi chúng thông qua parameters.</p>
<h1 id="khi-nào-dùng"><a class="header" href="#khi-nào-dùng">Khi nào dùng</a></h1>
<p>Giả sử ta có một chuỗi các actions hoặc transactions. 
Chúng ta muốn các actions hoặc commands được thực thi theo thứ tự khác nhau. 
Các commands có thể được trigger bởi kết quả của một event nào đó. 
Ví dụ, khi user nhấn 1 nút, hoặc khi nhận được 1 data event nào đó. 
Ngoài ra thì các commands này có thể khôi phục (undo). 
Ví dụ như ta store các chuỗi thực thi (executed) của các commands, 
khi hệ thống gặp vấn đề ta có thể phục hồi lại bằng cách chạy lại từng commands một.</p>
<h1 id="ví-dụ"><a class="header" href="#ví-dụ">Ví dụ</a></h1>
<p>Ta define hai database operations <code>create table</code> và <code>add field</code>.
Mỗi operation là một command. Các command này có thể undo được, ví dụ <code>drop table</code>, <code>drop field</code>.</p>
<p>Khi user invoke database migration, mỗi command được thực thi theo thứ tự, 
khi user muốn rollback, tất cả command được undo theo thứ tự ngược lại.</p>
<h1 id="cách-1-sử-dụng-trait-objects"><a class="header" href="#cách-1-sử-dụng-trait-objects">Cách 1: sử dụng trait objects</a></h1>
<p>Chúng ta định nghĩa một common trait cho command 
với hai operation là <code>exec</code> và <code>rollback</code>. 
Các struct command phải được implement trait này.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Migration {
  fn execute(&amp;self) -&gt; &amp;str;
  fn rollback(&amp;self) -&gt; &amp;str;
}

pub struct CreateTable;
impl Migration for CreateTable {
  fn execute(&amp;self) -&gt; &amp;str {
    &quot;create table&quot;
  }
  fn rollback(&amp;self) -&gt; &amp;str {
    &quot;drop table&quot;
  }
}

pub struct AddField;
impl Migration for AddField {
  fn execute(&amp;self) -&gt; &amp;str {
    &quot;add field&quot;
  }
  fn rollback(&amp;self) -&gt; &amp;str {
    &quot;remove field&quot;
  }
}

struct Schema {
  commands: Vec&lt;Box&lt;dyn Migration&gt;&gt;,
}

impl Schema {
  fn new() -&gt; Self {
    Self { commands: vec![] }
  }

  fn add_migration(&amp;mut self, cmd: Box&lt;dyn Migration&gt;) {
    self.commands.push(cmd);
  }

  fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.commands.iter().map(|cmd| cmd.execute()).collect()
  }
  fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.commands
      .iter()
      .rev() // reverse iterator's direction
      .map(|cmd| cmd.rollback())
      .collect()
  }
}

fn main() {
  let mut schema = Schema::new();

  let cmd = Box::new(CreateTable);
  schema.add_migration(cmd);
  let cmd = Box::new(AddField);
  schema.add_migration(cmd);

  assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
  assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h1 id="cách-2-sử-dụng-function-pointers"><a class="header" href="#cách-2-sử-dụng-function-pointers">Cách 2: sử dụng function pointers</a></h1>
<p>Chúng ta có thể thực hiện theo một cách khác là tách mỗi 
command thành một function và lưu lại function pointer để thực thi sau.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">type FnPtr = fn() -&gt; String;

struct Command {
  execute: FnPtr,
  rollback: FnPtr,
}

struct Schema {
  commands: Vec&lt;Command&gt;,
}

impl Schema {
  fn new() -&gt; Self {
    Self { commands: vec![] }
  }
  fn add_migration(&amp;mut self, execute: FnPtr, rollback: FnPtr) {
    self.commands.push(Command { execute, rollback });
  }
  fn execute(&amp;self) -&gt; Vec&lt;String&gt; {
    self.commands.iter().map(|cmd| (cmd.execute)()).collect()
  }
  fn rollback(&amp;self) -&gt; Vec&lt;String&gt; {
    self.commands
      .iter()
      .rev()
      .map(|cmd| (cmd.rollback)())
      .collect()
  }
}

fn add_field() -&gt; String {
  &quot;add field&quot;.to_string()
}

fn remove_field() -&gt; String {
  &quot;remove field&quot;.to_string()
}

fn main() {
  let mut schema = Schema::new();
  schema.add_migration(|| &quot;create table&quot;.to_string(), || &quot;drop table&quot;.to_string());
  schema.add_migration(add_field, remove_field);

  assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
  assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h1 id="cách-3-sử-dụng-fn-trait-objects"><a class="header" href="#cách-3-sử-dụng-fn-trait-objects">Cách 3: sử dụng <code>Fn</code> trait objects</a></h1>
<p>Thay vì định nghĩa một command trait theo cách 1, 
ta có thể lưu tất cả command được implement <code>trait Fn</code> trong một vector.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">type Migration&lt;'a&gt; = Box&lt;dyn Fn() -&gt; &amp;'a str&gt;;

struct Schema&lt;'a&gt; {
  executes: Vec&lt;Migration&lt;'a&gt;&gt;,
  rollbacks: Vec&lt;Migration&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; Schema&lt;'a&gt; {
  fn new() -&gt; Self {
    Self {
        executes: vec![],
        rollbacks: vec![],
    }
  }

  fn add_migration&lt;E, R&gt;(&amp;mut self, execute: E, rollback: R)
  where
    E: Fn() -&gt; &amp;'a str + 'static,
    R: Fn() -&gt; &amp;'a str + 'static,
  {
    self.executes.push(Box::new(execute));
    self.rollbacks.push(Box::new(rollback));
  }

  fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.executes.iter().map(|cmd| cmd()).collect()
  }

  fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.rollbacks.iter().rev().map(|cmd| cmd()).collect()
  }
}

fn add_field() -&gt; &amp;'static str {
  &quot;add field&quot;
}

fn remove_field() -&gt; &amp;'static str {
  &quot;remove field&quot;
}

fn main() {
  let mut schema = Schema::new();
  schema.add_migration(|| &quot;create table&quot;, || &quot;drop table&quot;);
  schema.add_migration(add_field, remove_field);

  assert_eq!(vec![&quot;create table&quot;, &quot;add field&quot;], schema.execute());
  assert_eq!(vec![&quot;remove field&quot;, &quot;drop table&quot;], schema.rollback());
}
</code></pre></pre>
<h1 id="thảo-luận"><a class="header" href="#thảo-luận">Thảo luận</a></h1>
<p>Trong các ví dụ trên thì command của chúng ta khá nhỏ, 
nên thường được define dưới dạng function hoặc closure 
rồi bỏ thẳng function pointer vào Vec, rồi thực thi theo thứ tự. 
Trong thực tế các command có thể phức tạp hơn, 
có thể là một struct với hàng loạt các function và variable 
trong các module khác nhau, việc sử dụng <code>trait</code> và <code>Box</code> ở cách 1 sẽ hiệu quả hơn. </p>
<h1 id="references-14"><a class="header" href="#references-14">References</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Command_pattern">https://en.wikipedia.org/wiki/Command_pattern</a></li>
<li><a href="https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust">https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creational-patterns"><a class="header" href="#creational-patterns">Creational Patterns</a></h1>
<p>Theo Wikipedia:</p>
<blockquote>
<p>Creational Patterns: Design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or in added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p>
</blockquote>
<p>Một số Creational Patterns trong Rust</p>
<ul>
<li><a href="design-pattern/creational/./builder.html">Builder Pattern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-builder-design-pattern"><a class="header" href="#rust-builder-design-pattern">Rust Builder Design Pattern</a></h1>
<p>Rust không có overloading, do đó bạn cần phải viết nhiều construct
cho tất cả các trường hợp có thể có, với các method name khác nhau. 
Việc này sẽ cực kỳ mất thời gian nếu struct có quá nhiều <em>fields</em> hoặc <em>constructor</em> phức tạp.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl Foo {
  pub fn new(a: String) -&gt; Self {}
  pub fn new(a: String, b: String) -&gt; Self {} // &lt;-- không thể
  pub fn new(a: i32) -&gt; Self {} // &lt;-- không thể
}

// Thay vào đó
impl Foo {
  pub fn new(a: String) -&gt; Self {}
  pub fn new_from_two(a: String, b: String) -&gt; Self {}
  pub fn new_from_int(a: i32) -&gt; Self {}
}
</code></pre></pre>
<p>Do đó, <strong>builder</strong> được sử dụng cực kỳ phổ biến trong Rust so với các ngôn ngữ khác.</p>
<p>Builder cho phép construct một object bằng cách gọi <code>build()</code>.</p>
<h1 id="ví-dụ-1"><a class="header" href="#ví-dụ-1">Ví dụ</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, PartialEq)]
pub struct Foo {
  // Lots of complicated fields.
  bar: String,
}

impl Foo {
  // This method will help users to discover the builder
  pub fn builder() -&gt; FooBuilder {
    FooBuilder::default()
  }
}

#[derive(Default)]
pub struct FooBuilder {
  // Probably lots of optional fields.
  bar: String,
}

impl FooBuilder {
  pub fn new(/* ... */) -&gt; FooBuilder {
    // Set the minimally required fields of Foo.
    FooBuilder {
      bar: &quot;x&quot;.to_string(),
    }
  }

  pub fn name(mut self, bar: String) -&gt; FooBuilder {
    // Set the name on the builder itself, and return the builder by value.
    self.bar = bar;
    self
  }

  // If we can get away with not consuming the Builder here, that is an
  // advantage. It means we can use the FooBuilder as a template for constructing
  // many Foos.
  pub fn build(self) -&gt; Foo {
    // Create a Foo from the FooBuilder, applying all settings in FooBuilder
    // to Foo.
    Foo { bar: self.bar }
  }
}

#[test]
fn builder_test() {
  let foo = Foo { bar: &quot;y&quot;.to_string() };
  let foo_from_builder = FooBuilder::new().name(&quot;y&quot;.to_string()).build();

  assert_eq!(foo, foo_from_builder);
}
</code></pre></pre>
<h1 id="khi-nào-dùng-1"><a class="header" href="#khi-nào-dùng-1">Khi nào dùng</a></h1>
<p>Hữu ích khi bạn muốn có nhiều loại constructors khác nhau hoặc khi constructor có side effects.</p>
<h1 id="Ưu-điểm"><a class="header" href="#Ưu-điểm">Ưu điểm</a></h1>
<ul>
<li>Tách biệt các methods của builder và các method khác của object.</li>
<li>Không cần phải viết quá nhiều constructor nếu struct có quá nhiều fields hoặc quá nhiều cách để khởi tạo một object.</li>
<li>One-liner initialization: <code>FooBuilder::new().a().b().c().build()</code></li>
</ul>
<h1 id="nhược-điểm"><a class="header" href="#nhược-điểm">Nhược điểm</a></h1>
<p>Phức tạp hơn so với việc init object trực tiếp, hoặc so với object có constructor đơn giản.</p>
<h1 id="references-15"><a class="header" href="#references-15">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">https://doc.rust-lang.org/1.0.0/style/ownership/builders.html</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, một crate cho phép tự động tạo builder.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structural-patterns"><a class="header" href="#structural-patterns">Structural Patterns</a></h1>
<p>Theo Wikipedia:</p>
<blockquote>
<p>Structual Patterns: Design patterns that ease the design by identifying a simple way to realize relationships among entities.</p>
</blockquote>
<p>Một số Structural Patterns trong Rust</p>
<ul>
<li><a href="design-pattern/structural/./small-rates.html">Prefer Small Crates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefer-small-crates"><a class="header" href="#prefer-small-crates">Prefer Small Crates</a></h1>
<p>Không hẳn là một Design pattern, mình thấy đây là một tư tưởng khi viết các project bằng Rust.</p>
<p>Cargo và <a href="http://crates.io/">crates.io</a> giúp quản lý crate cực kỳ dễ dàng. 
Hơn nữa, crate trên crates.io không thể sửa hoặc xóa được sau khi publish, 
bất kỳ bản build nào đang hoạt động chắc chắn sẽ hoạt động được tiếp trong tương lai. 
Điều này bắt buộc để có được sự hiệu quả, mọi crate phải được thiết kế tốt, 
lựa chọn dependencies kỹ càng và càng nhỏ càng tốt.</p>
<blockquote>
<p>Prefer small crates that do one thing well.</p>
</blockquote>
<h1 id="Ưu-điểm-1"><a class="header" href="#Ưu-điểm-1">Ưu điểm</a></h1>
<ul>
<li>Small crate sẽ giúp ta dễ hiểu và dễ sử dụng hơn, code dễ module hóa hơn.</li>
<li>Đơn vị compilation nhỏ nhất của Rust là crate, tách nhỏ project thành nhiều crate giúp code build parallel.</li>
<li>Crate giúp tái sử dụng giữa nhiều project khác nhau.
<ul>
<li>Ví dụ, crate <code>url</code> là một phần của Servo browser engine, nhưng được sử dụng cực kỳ rộng rãi ở các project khác, do nó độc lập và giải quyết một vấn đề cụ thể.</li>
<li>Ví dụ, <a href="https://awslabs.github.io/aws-sdk-rust/">AWS SDK Rust</a> được tách thành rất nhiều crate nhỏ, và các crate nhỏ này được sử dụng ở khắp nơi không chỉ ở AWS SDK Rust.
<ul>
<li><code>aws-sdk-*</code></li>
<li><code>aws-config</code></li>
<li><code>aws_smithy_client</code></li>
<li><code>aws_types</code></li>
</ul>
</li>
</ul>
</li>
<li>Tách nhỏ crate độc lập giúp việc chia tasks trong một project lớn của team hiệu quả hơn.</li>
</ul>
<h1 id="nhược-điểm-1"><a class="header" href="#nhược-điểm-1">Nhược điểm</a></h1>
<ul>
<li>Có dễ dẫn đến “dependency hell”, một project depends vào cùng 1 crate nhưng version khác nhau cùng một lúc. Và các versions này xung đột nhau.</li>
<li>Hai crate quá nhỏ có thể kém hiệu quả hơn một crate lớn, bởi vì compiler mặc định không thực hiện link-time optimization (LTO).</li>
</ul>
<h1 id="một-số-small-crates-điển-hình"><a class="header" href="#một-số-small-crates-điển-hình">Một số small crates điển hình</a></h1>
<ul>
<li><a href="https://crates.io/crates/url">url</a>: crate xử lý url.</li>
<li><a href="https://crates.io/crates/ref_slice">ref_slice</a>: crate giúp convert từ <code>&amp;T</code> sang <code>&amp;[T]</code>. Crate này <a href="https://github.com/rust-lang/rust/issues/27774#issuecomment-150058618">từng nằm trong standard library</a> nhưng đã tách ra.</li>
<li><a href="https://crates.io/crates/num_cpus">num_cpus</a>: trả về số lượng cpu trên máy hiện tại.</li>
<li><a href="https://crates.io/crates/rand">rand</a>: random number generators.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anyhow"><a class="header" href="#anyhow"><a href="https://docs.rs/anyhow"><code>anyhow</code></a></a></h1>
<p><a href="https://docs.rs/anyhow"><code>anyhow</code></a> là thư viện giúp đơn giản hóa việc handle lỗi trong Rust application.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
anyhow = &quot;1.0&quot;
</code></pre>
<p>Cách sử dụng</p>
<ul>
<li>
<p>Sử dụng <code>anyhow::Result&lt;T&gt;</code> thay cho <code>Result</code> của <code>std</code>. Ta không cần định nghĩa Error trả về. Trong function sử dụng <code>?</code> để trả mọi error đã được impl <code>std::error::Error</code> lên level cao hơn. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;

fn get_cluster_info() -&gt; Result&lt;ClusterMap&gt; {
    let config = std::fs::read_to_string(&quot;cluster.json&quot;)?;
    let map: ClusterMap = serde_json::from_str(&amp;config)?;
    Ok(map)
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Thêm context để debug dễ hơn:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    ...
    it.detach().context(&quot;Failed to detach the important thing&quot;)?;

    let content = std::fs::read(path)
        .with_context(|| format!(&quot;Failed to read instrs from {}&quot;, path))?;
    ...
}
</code></pre></pre>
<pre><code>Error: Failed to read instrs from ./path/to/instrs.json

Caused by:
    No such file or directory (os error 2)
</code></pre>
</li>
<li>
<p>Return lỗi nhanh hơn với macros <a href="https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html"><code>anyhow!</code></a>, <a href="https://docs.rs/anyhow/latest/anyhow/macro.bail.html"><code>bail!</code></a>, <a href="https://docs.rs/anyhow/latest/anyhow/macro.ensure.html"><code>ensure!</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return Err(anyhow!(&quot;Missing attribute: {}&quot;, missing));
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bail!(&quot;Missing attribute: {}&quot;, missing);    
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ensure!(user == 0, &quot;only user 0 is allowed&quot;);
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="references-16"><a class="header" href="#references-16">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/anyhow">https://docs.rs/anyhow</a></li>
<li>Github: <a href="https://github.com/dtolnay/anyhow">https://github.com/dtolnay/anyhow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log"><a class="header" href="#log">log</a></h1>
<p><a href="https://docs.rs/log"><code>log</code></a> là thư viện logging lightweight cho Rust application. </p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;
</code></pre>
<p>Cách sử dụng</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{info, trace, warn};

pub fn shave_the_yak(yak: &amp;mut Yak) {
    trace!(&quot;Commencing yak shaving&quot;);

    loop {
        match find_a_razor() {
            Ok(razor) =&gt; {
                info!(&quot;Razor located: {}&quot;, razor);
                yak.shave(razor);
                break;
            }
            Err(err) =&gt; {
                warn!(&quot;Unable to locate a razor: {}, retrying&quot;, err);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="env_logger"><a class="header" href="#env_logger"><a href="https://docs.rs/env_logger"><code>env_logger</code></a></a></h2>
<p><a href="https://docs.rs/log"><code>log</code></a> thường được sử dụng với <a href="https://docs.rs/env_logger"><code>env_logger</code></a> để cấu hình logging
thông qua biến môi trường.</p>
<p>Mặc định, <code>env_logger</code> ghi log ra <code>stderr</code>.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4.0&quot;
env_logger = &quot;0.8.4&quot;
</code></pre>
<p>Ví dụ:</p>
<p>File: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  env_logger::init();

  info!(&quot;starting up&quot;);
  error!(&quot;this is error!&quot;);
  debug!(&quot;this is debug {}!&quot;, &quot;message&quot;);
}
</code></pre></pre>
<pre><code>$ RUST_LOG=error cargo run
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=debug cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<p>Filter log theo module name:</p>
<pre><code>$ RUST_LOG=main=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<p>Hiện mọi log level cho module <code>main</code>:</p>
<pre><code>$ RUST_LOG=main cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<h3 id="references-17"><a class="header" href="#references-17">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/env_logger">https://docs.rs/env_logger</a></li>
<li>Github: <a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></li>
<li><a href="https://docs.rs/env_logger/">https://docs.rs/env_logger/</a></li>
</ul>
<h3 id="references-18"><a class="header" href="#references-18">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/log">https://docs.rs/log</a></li>
<li>Github: <a href="https://github.com/rust-lang/log">https://github.com/rust-lang/log</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="env_logger-1"><a class="header" href="#env_logger-1"><a href="https://docs.rs/env_logger"><code>env_logger</code></a></a></h2>
<p>[<code>log</code>] thường được sử dụng với <a href="https://docs.rs/env_logger"><code>env_logger</code></a> để cấu hình logging
thông qua biến môi trường.</p>
<p>Mặc định, <code>env_logger</code> ghi log ra <code>stderr</code>.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4.0&quot;
env_logger = &quot;0.8.4&quot;
</code></pre>
<p>Ví dụ:</p>
<p>File: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  env_logger::init();

  info!(&quot;starting up&quot;);
  error!(&quot;this is error!&quot;);
  debug!(&quot;this is debug {}!&quot;, &quot;message&quot;);
}
</code></pre></pre>
<pre><code>$ RUST_LOG=error cargo run
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=debug cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<p>Filter log theo module name:</p>
<pre><code>$ RUST_LOG=main=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<p>Hiện mọi log level cho module <code>main</code>:</p>
<pre><code>$ RUST_LOG=main cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<h3 id="references-19"><a class="header" href="#references-19">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/env_logger">https://docs.rs/env_logger</a></li>
<li>Github: <a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></li>
<li><a href="https://docs.rs/env_logger/">https://docs.rs/env_logger/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async_trait"><a class="header" href="#async_trait"><a href="https://docs.rs/async-trait"><code>async_trait</code></a></a></h1>
<p>Rust chưa hỗ trợ <code>async</code> cho trait. Trait dưới đây sẽ báo lỗi:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    async fn f() {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>error[E0706]: trait fns cannot be declared `async`
 --&gt; src/main.rs:4:5
  |
4 |     async fn f() {}
  |     ^^^^^^^^^^^^^^^
</code></pre>
<p><a href="https://docs.rs/async-trait"><code>async_trait</code></a> cung cấp attribute macro để giúp async có thể hoạt động với trait.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
async_trait = &quot;0.1&quot;
</code></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;

#[async_trait]
trait Advertisement {
    async fn run(&amp;self);
}

struct Modal;

#[async_trait]
impl Advertisement for Modal {
    async fn run(&amp;self) {
        self.render_fullscreen().await;
        for _ in 0..4u16 {
            remind_user_to_join_mailing_list().await;
        }
        self.hide_for_now().await;
    }
}

struct AutoplayingVideo {
    media_url: String,
}

#[async_trait]
impl Advertisement for AutoplayingVideo {
    async fn run(&amp;self) {
        let stream = connect(&amp;self.media_url).await;
        stream.play().await;

        // Video probably persuaded user to join our mailing list!
        Modal.run().await;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="references-20"><a class="header" href="#references-20">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/anyhow">https://docs.rs/anyhow</a></li>
<li>Github: <a href="https://github.com/dtolnay/anyhow">https://github.com/dtolnay/anyhow</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">why async fn in traits are hard</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy_static"><a class="header" href="#lazy_static"><a href="https://docs.rs/lazy_static"><code>lazy_static</code></a></a></h1>
<p><a href="https://docs.rs/lazy_static"><code>lazy_static</code></a> là một macro cho phép khởi tạo biến <code>static</code> nhưng chứa giá trị
được thực thi lúc runtime. Các giá trị này có thể là bất kỳ cái gì cần heap allocations,
ví dụ như <code>Vector</code>, <code>HashMap</code> hoặc function call.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
lazy_static = &quot;1&quot;
</code></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use lazy_static::lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref HASHMAP: HashMap&lt;u32, &amp;'static str&gt; = {
        let mut m = HashMap::new();
        m.insert(0, &quot;foo&quot;);
        m.insert(1, &quot;bar&quot;);
        m.insert(2, &quot;baz&quot;);
        m
    };
    static ref COUNT: usize = HASHMAP.len();
    static ref NUMBER: u32 = times_two(21);
}

fn times_two(n: u32) -&gt; u32 { n * 2 }

fn main() {
    println!(&quot;The map has {} entries.&quot;, *COUNT);
    println!(&quot;The entry for `0` is \&quot;{}\&quot;.&quot;, HASHMAP.get(&amp;0).unwrap());
    println!(&quot;A expensive calculation on a static results in: {}.&quot;, *NUMBER);
}
</code></pre></pre>
<h3 id="references-21"><a class="header" href="#references-21">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/lazy_static">https://docs.rs/lazy_static</a></li>
<li>Github: <a href="https://github.com/rust-lang-nursery/lazy-static.rs">https://github.com/rust-lang-nursery/lazy-static.rs</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
