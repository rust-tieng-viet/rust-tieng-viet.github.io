<!DOCTYPE HTML>
<html lang="vi" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Tiếng Việt</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-88RKF7DLPY"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-88RKF7DLPY');
        </script>
        
        <!-- pageview.js -->
        <script>
          !function(e,n,t){e.onload=function(){
          let e=n.createElement("script");
          e.src=t,n.body.appendChild(e)}}
          (window,document,"https://pageview.duyet.net/pageview.js");
        </script>
        
        <script async src="https://seline.duyet.workers.dev/seline.js" data-api-host="https://seline.duyet.workers.dev" data-token="d7c8002f8e40139"></script>
        <script async src="https://cm43xj8zd00093b619ak2zfuc.d.jitsu.com/p.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Tiếng Việt</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-tiếng-việt"><a class="header" href="#rust-tiếng-việt">Rust Tiếng Việt</a></h1>
<p><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/actions/workflows/deploy.yml"><img src="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/actions/workflows/deploy.yml/badge.svg" alt="Deploy Book" /></a></p>
<blockquote>
<p>The book is published at <a href="https://rust-tieng-viet.github.io">https://rust-tieng-viet.github.io</a>.</p>
</blockquote>
<pre><code class="language-plantext">    _~^~^~_
\) /  o o  \ (/
  '_   _   _'
  / '-----' \
</code></pre>
<p>Rust là một ngôn ngữ nhanh, an toàn và được bình chọn là
ngôn ngữ được ưa thích nhất trong nhiều năm liền theo <a href="https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages.">Stack Overflow Survey</a>.
Rust có một hệ thống tài liệu và sách đồ sộ, chi tiết.
Nhưng đôi khi nó sẽ khó tiếp cận với một số người bởi đa số tài liệu là Tiếng Anh.
Với những ghi chép trong sách này, hy vọng có thể giúp cho mọi người
(cũng như các thành viên trong team mình <a href="https://blog.duyet.net/2021/11/rust-data-engineering.html">tại Fossil</a>) có thể tiếp cận với
ngôn ngữ này một cách nhanh chóng và dễ dàng hơn.
Cũng như truyền cảm hứng và mở rộng cộng đồng sử dụng Rust tại Việt Nam.</p>
<p>Mục tiêu của sách này không phải là dịch từ các sách tiếng Anh.
Mà sẽ là những ghi chép, những lưu ý cho một người mới bắt đầu học Rust
cho đến lúc thành thạo, từ lúc <code>hello world</code> cho đến các dự án thực tế.
Bao gồm những khó khăn mà bạn sẽ phải gặp, những thuật ngữ, concepts mới,
những thói quen lập trình mới mà bạn sẽ phải làm quen.</p>
<p>Mình vẫn luôn prefer đọc sách tiếng Anh nếu bạn có thể.
Vui lòng xem mục <strong>references</strong> ở cuối các trang nếu bạn muốn đào sâu hơn.</p>
<h3 id="links"><a class="header" href="#links">Links</a></h3>
<ul>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io">Mã nguồn sách này</a></li>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io#contribution">Đóng góp, chỉnh sửa</a></li>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/issues/new?assignees=duyet%2Cduyetbot&amp;labels=request%2Ccontent&amp;template=request_content.yml&amp;title=%5BY%C3%AAu+c%E1%BA%A7u+n%E1%BB%99i+dung%5D">Yêu cầu thêm nội dung</a></li>
<li><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/blob/main/LICENCE">License</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="who-is-using-rust"><a class="header" href="#who-is-using-rust">Who is using Rust?</a></h1>
<p>Công ty hoặc cộng đồng sử dụng Rust tại Việt Nam.</p>
<div class="table-wrapper"><table><thead><tr><th>Organization</th><th>Contact (GitHub User Name)</th><th>Environment</th><th>Description of Use</th></tr></thead><tbody>
<tr><td>Fossil Vietnam</td><td><a href="https://github.com/duyet">@duyet</a></td><td>Production</td><td>Data Platform</td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/rust-tieng-viet/rust-tieng-viet.github.io/edit/main/src/who-is-using.md">+ thêm</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cài-đặt-rust"><a class="header" href="#cài-đặt-rust">Cài đặt Rust</a></h1>
<p>Dưới đây là hướng dẫn chi tiết về cách cài đặt Rust trên hệ điều hành Windows, macOS và Linux. Bạn cũng có thể tự tham khảo trên trang chủ của Rust: <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>
<h2 id="cài-đặt-rust-trên-macos-linux"><a class="header" href="#cài-đặt-rust-trên-macos-linux">Cài đặt Rust trên macOS, Linux</a></h2>
<p>Mở Terminal và chạy lệnh sau:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Sau khi hoàn thành quá trình cài đặt, bạn có thể kiểm tra phiên bản Rust bằng cách mở Terminal và chạy lệnh sau:</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<h2 id="cài-đặt-rust-trên-windows"><a class="header" href="#cài-đặt-rust-trên-windows">Cài đặt Rust trên Windows</a></h2>
<p>Để tải xuống trình cài đặt Rust, bạn cần truy cập vào trang web chính thức của Rust tại địa chỉ <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">https://forge.rust-lang.org/infra/other-installation-methods.html</a></p>
<p>Chạy tập tin <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">rustup-init.exe</a> để bắt đầu quá trình cài đặt Rust trên máy tính của mình.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/learn/get-started">https://www.rust-lang.org/learn/get-started</a></li>
<li><a href="getting-started/./rust-playground.html">Rust Playground</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h1>
<p><a href="https://play.rust-lang.org">https://play.rust-lang.org</a> giúp chúng ta chạy Rust code trực tiếp trên trình duyệt mà không cần <a href="getting-started/./installation.html">cài đặt Rust trên máy</a>.</p>
<p><img src="getting-started/./plaground.png" alt="" /></p>
<p>Một số tips:</p>
<ul>
<li>Bấm Run để chạy code. Có thể chuyển đổi giữa các version của Rust.</li>
<li>Chọn Release thay vì Debug để chạy nhanh hơn (nhưng thiếu một số thông tin debug).</li>
<li>Chọn Share để chia sẻ link đoạn code với người khác.</li>
<li>Rustfmt sẽ tự động format code của bạn (như <code>cargo fmt</code>).</li>
<li>Clippy sẽ kiểm tra code của bạn và đưa ra gợi ý (như <code>cargo clippy</code>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-đầu-tiên"><a class="header" href="#project-đầu-tiên">Project đầu tiên</a></h1>
<p>Sau khi <a href="getting-started/./installation.html">cài đặt Rust</a> thành công, bạn có thể bắt đầu sử dụng <a href="getting-started/../basic/cargo">Cargo</a> (một công cụ quản lý gói mạnh mẽ được tích hợp sẵn trong Rust) để khởi tạo project hello world đầu tiên.</p>
<h2 id="bước-1-tạo-một-package-mới"><a class="header" href="#bước-1-tạo-một-package-mới">Bước 1: Tạo một package mới</a></h2>
<p>Để bắt đầu với Cargo, bạn cần tạo một package mới bằng lệnh <strong><code>cargo new &lt;name&gt;</code></strong>. Ví dụ, để tạo một package mới với tên là <code>hello_world</code>, bạn chạy lệnh sau đây:</p>
<pre><code class="language-bash">$ cargo new hello_world
# Created binary (application) `hello_world` package
</code></pre>
<p>Cargo sẽ tạo ra một package mới với một file <strong><code>Cargo.toml</code></strong> và một thư mục <strong><code>src</code></strong>. File <strong><code>Cargo.toml</code></strong> chứa tất cả các thông tin liên quan đến package của bạn.</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

2 directories, 2 files
</code></pre>
<p>Hãy xem nội dung của <code>src/main.rs</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<h2 id="bước-2-biên-dịch-và-chạy-chương-trình"><a class="header" href="#bước-2-biên-dịch-và-chạy-chương-trình">Bước 2: Biên dịch và chạy chương trình</a></h2>
<p>Tiếp theo, để biên dịch chương trình của bạn, hãy chạy lệnh <strong><code>cargo build</code></strong>. Sau khi quá trình biên dịch kết thúc, Cargo sẽ tạo ra một thư mục mới có tên <strong><code>target</code></strong>, chứa tệp thực thi của chương trình.</p>
<pre><code class="language-bash">$ cargo build

# Compiling hello_world v0.1.0 (/Users/duyet/project/hello_world)
#    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
</code></pre>
<p>Để chạy chương trình, bạn có thể sử dụng lệnh <strong><code>./target/debug/&lt;name&gt;</code></strong>. Ví dụ, để chạy chương trình <code>hello_world</code>, bạn có thể chạy lệnh sau đây:</p>
<pre><code class="language-bash">$ ./target/debug/hello_world
# Hello, world!
</code></pre>
<p>Kết quả sẽ hiển thị trên màn hình là "<em>Hello, world!</em>". Ngoài ra, bạn cũng có thể biên dịch và chạy chương trình chỉ trong một bước bằng cách sử dụng lệnh <strong><code>cargo run</code></strong>.</p>
<pre><code class="language-bash">$ cargo run
# Hello, world!
</code></pre>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/getting-started/first-steps.html">First Steps with Cargo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables trong Rust có kiểu dữ liệu tĩnh.
Ta khai báo kiểu dữ liệu trong lúc khai báo biến.
Trong đa số các trường hợp compiler có thể đoán được kiểu dữ liệu
nên đôi khi ta có thể bỏ qua.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let an_integer = 1u32;
let a_boolean = true;
let unit = ();

// copy `an_integer` into `copied_integer`
let copied_integer = an_integer;
<span class="boring">}</span></code></pre></pre>
<p>Mọi biến đều phải được sử dụng, nếu không, compiler sẽ warning.
Để skip warning, thêm dấu underscore ở đầu tên biến.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn check_error() {}
</span><span class="boring">fn main() {
</span>// The compiler warns about unused variable bindings; these warnings can
// be silenced by prefixing the variable name with an underscore
let _unused_variable = 3u32;

// Skip the result of function
let _ = check_error();
<span class="boring">}</span></code></pre></pre>
<h2 id="mut"><a class="header" href="#mut"><code>mut</code></a></h2>
<p>Mọi biến trong Rust mặc định là immutable, có nghĩa là không thể thay đổi,
không thể gán bằng một giá trị khác.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">fn main() {
</span>let a = 1;
a = 2;
<span class="boring">}
</span>
// error[E0384]: cannot assign twice to immutable variable `a`
//  --&gt; src/main.rs:4:1
//   |
// 3 | let a = 1;
//   |     -
//   |     |
//   |     first assignment to `a`
//   |     help: consider making this binding mutable: `mut a`
// 4 | a = 2;
//   | ^^^^^ cannot assign twice to immutable variable</code></pre></pre>
<p>Để có thể thay đổi giá trị của biến, ta thêm từ khóa <code>mut</code> sau <code>let</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a = 1;
a = 2;

println!("a = {}", a);
<span class="boring">}</span></code></pre></pre>
<p>Ta cũng có thể khai báo lại biến đó để assign lại giá trị mới:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let a = 1;
let a = a + 1;
<span class="boring">}</span></code></pre></pre>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>Giá trị của variables có thể được xác định tùy theo scope.
Scope là một tập hợp các dòng code nằm trong <code>{}</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let a = 1;

{
    let a = 2;
    println!("inner: a = {}", a); // 2
}

println!("outer: a = {}", a); // 1</code></pre></pre>
<h2 id="return-trong-scope"><a class="header" href="#return-trong-scope">Return trong scope</a></h2>
<p>Ta cũng có thể return giá trị trong một scope cho một variable.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let a = {
    let y = 10;
    let z = 100;

    y + z
};

println!("a = {}", a);</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mut-1"><a class="header" href="#mut-1"><code>mut</code></a></h2>
<p>Mọi biến trong Rust mặc định là immutable, có nghĩa là không thể thay đổi,
không thể gán bằng một giá trị khác.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">fn main() {
</span>let a = 1;
a = 2;
<span class="boring">}
</span>
// error[E0384]: cannot assign twice to immutable variable `a`
//  --&gt; src/main.rs:4:1
//   |
// 3 | let a = 1;
//   |     -
//   |     |
//   |     first assignment to `a`
//   |     help: consider making this binding mutable: `mut a`
// 4 | a = 2;
//   | ^^^^^ cannot assign twice to immutable variable</code></pre></pre>
<p>Để có thể thay đổi giá trị của biến, ta thêm từ khóa <code>mut</code> sau <code>let</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let mut a = 1;
a = 2;

println!("a = {}", a);
<span class="boring">}</span></code></pre></pre>
<p>Ta cũng có thể khai báo lại biến đó để assign lại giá trị mới:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let a = 1;
let a = a + 1;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uninitialized-variable"><a class="header" href="#uninitialized-variable">uninitialized variable</a></h1>
<p>Variable mà chưa được gán giá trị được gọi là uninitialized variable.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">fn main() {
  let my_variable; // ⚠️
}</code></pre></pre>
<p>Rust sẽ không compile và bạn sẽ không thể sử dụng cho đến khi <code>my_variable</code> được gán giá trị nào đó. Ta có thể lợi dụng điều này:</p>
<ul>
<li>Khai báo uninitialized variable.</li>
<li>Gán giá trị cho nó trong 1 scope khác</li>
<li>Vẫn giữ được giá trị của của variable đó khi ra khỏi scope.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
  let my_number;
  {
    my_number = 100;
  }

  println!("{}", my_number);
}</code></pre></pre>
<p>Hoặc phức tạp hơn</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn loop_then_return(mut counter: i32) -&gt; i32 {
  loop {
    counter += 1;
    if counter % 50 == 0 {
      break;
    }
  }

  counter
}

fn main() {
  let my_number;

  {
    // Pretend we need to have this code block
    let number = {
      // Pretend there is code here to make a number
      // Lots of code, and finally:
      57
    };

    my_number = loop_then_return(number);
  }

  println!("{}", my_number); // 100
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>Hay còn được gọi là <strong>anonymous functions</strong> hay <strong>lambda functions</strong>.
Khác với function bình thường, kiểu dữ liệu của tham số đầu vào
và kiểu dữ liệu trả ra là không bắt buộc.</p>
<p>Function bình thường:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_square_value(i: i32) -&gt; i32 {
  i * i
}

fn main() {
  let x = 2;
  println!("{}", get_square_value(x));
}</code></pre></pre>
<p>Closure:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = 2;

  let square = |i: i32| -&gt; i32 {
      i * i
  };

  println!("{}", square(x));
}</code></pre></pre>
<h3 id="closure-không-cần-data-type"><a class="header" href="#closure-không-cần-data-type">Closure không cần data type</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = 2;

  let square = |i| {
    i * i
  };

  println!("{}", square(x));
}</code></pre></pre>
<p>Tham số của của closure được đặt giữa 2 dấu: <code>|</code> và <code>|</code>.</p>
<h3 id="closure-không-có-tham-số"><a class="header" href="#closure-không-có-tham-số">Closure không có tham số</a></h3>
<p>Với closure không có tham số, ta viết như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func = || { 1 + 1 };
<span class="boring">}</span></code></pre></pre>
<h3 id="closure-chỉ-có-một-mệnh-đề"><a class="header" href="#closure-chỉ-có-một-mệnh-đề">Closure chỉ có một mệnh đề</a></h3>
<p>Dấu ngoặc <code>{}</code> cũng không bắt buộc nếu nội dung của closure chỉ có một mệnh đề.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func = || 1 + 1;
<span class="boring">}</span></code></pre></pre>
<h3 id="vừa-định-nghĩa-vừa-thực-thi"><a class="header" href="#vừa-định-nghĩa-vừa-thực-thi">Vừa định nghĩa, vừa thực thi</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let x = 2;

  let square = |i| -&gt; i32 { // ⭐️ nhưng bắt buộc khai báo return type
    i * i
  }(x);

  println!("{}", square);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code> là package management tool official của Rust.</p>
<p><code>cargo</code> có rất nhiều tính năng hữu ích để improve code quality và nâng cao tốc độ của lập trình viên.
<code>cargo</code> có hẳn một quyển sách riêng: <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a></p>
<p>Những tính năng phổ biến mà bạn sẽ phải dùng hằng ngày:</p>
<ul>
<li><code>cargo add &lt;crate&gt;</code>: cài đặt crate mới từ <a href="https://crates.io">https://crates.io</a>, crate sẽ được thêm vào <code>Cargo.toml</code>.</li>
<li><code>cargo r</code> hoặc <code>cargo run</code>: biên dịch và chạy chương trình (<code>main.rs</code>).</li>
<li><code>cargo t</code> hoặc <code>cargo test</code>: run mọi tests (unit tests, doc tests, integration tests).</li>
<li><code>cargo fmt</code>: format code.</li>
<li><code>cargo clippy</code>: lint để bắt các lỗi phổ biến trong lập trình, code đẹp hơn, chạy nhanh hơn, etc. <a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages-và-crates"><a class="header" href="#packages-và-crates">Packages và Crates</a></h1>
<p><strong>Package</strong> là một hoặc nhiều crates. Một package gồm một file <code>Cargo.toml</code> mô tả cách để build các crates đó.</p>
<p><strong>Crate</strong> có thể là một binary crate hoặc library crate.</p>
<ul>
<li><strong>binary crate</strong> có thể được compile thành binary và có thể thực thi được, ví dụ như một command-line hoặc server. Một binary crate bắt buộc phải có một hàm <code>main()</code></li>
<li><strong>library crate</strong> không cần hàm <code>main()</code>. Library crate dùng để share các tính năng cho các project khác.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-layout"><a class="header" href="#package-layout">Package layout</a></h1>
<p>Được mô tả trong <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">Cargo book</a>,
một crate trong Rust sẽ có layout như sau:</p>
<pre><code>.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   ├── helper.rs
│   ├── utils/
│   │   ├── mod.rs
│   │   └── math.rs
│   └── bin/
│       ├── named-executable.rs
│       └── another-executable.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench.rs
├── examples/
│   ├── simple.rs
│   └── complex.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code> và <code>Cargo.lock</code> dược đặt ở thư mục gốc của package. Thường để sử dụng các library nào đó, người ta sẽ hướng dẫn bạn thêm một dòng ví dụ <code>log = "0.6"</code> bên dưới section <code>[dependencies]</code> hoặc <code>[dev-dependencies]</code>. Không nên đụng đến file <code>Cargo.lock</code> do nó được generate tự động.</li>
<li>Source code được đặt trong thư mục <code>src</code>.</li>
<li>File chính của library crate là <code>src/lib.rs</code>.</li>
<li>File chính của binary crate là <code>src/main.rs</code>.</li>
<li>Benchmark code được đặt trong thư mục <code>benches</code>.</li>
<li>Code ví dụ (examples) được đặt trong thư mục <code>examples</code>.</li>
<li>Integration tests được đặt trong thư mục <code>tests</code>.</li>
<li><code>helper.rs</code> và <code>utils/</code> được gọi là các module. Nếu module là một thư mục gồm nhiều file khác, file <code>mod.rs</code> được coi như là file index của module đó. Xem thêm về modules <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">tại đây</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate"><a class="header" href="#crate">Crate</a></h1>
<p><strong>Crate</strong> có thể là một binary crate hoặc library crate.</p>
<ul>
<li><strong>binary crate</strong> có thể được compile thành binary và có thể thực thi được, ví dụ như một command-line hoặc server. Một binary crate bắt buộc phải có một hàm <code>main()</code></li>
<li><strong>library crate</strong> không cần hàm <code>main()</code>. Library crate dùng để share các tính năng cho các project khác.</li>
</ul>
<p>Crate được publish trên <a href="https://crates.io">https://crates.io</a>.</p>
<h2 id="init-crate"><a class="header" href="#init-crate">Init crate</a></h2>
<p>Để tạo một crate mới ta sử dụng cargo:</p>
<ul>
<li><code>cargo new crate_name</code>: binary crate.</li>
<li><code>cargo new crate_name --lib</code>: library crate.</li>
</ul>
<h2 id="layout-của-binary-crate-và-library-crate"><a class="header" href="#layout-của-binary-crate-và-library-crate">Layout của <strong>binary crate</strong> và <strong>library crate</strong></a></h2>
<pre><code>// Binary crate

├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<pre><code>// Library crate

├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<p>Một crate có thể vừa có <code>lib.rs</code> và <code>main.rs</code>.</p>
<p>Binary crate khi <code>cargo build</code> hoặc <code>cargo run</code> sẽ build ra một file binary bỏ trong <code>./target/debug/&lt;crate_name&gt;</code>.</p>
<p>Khi build cho môi trường production, ta thêm <code>--release</code> lúc này cargo sẽ build thành binary bỏ trong <code>./target/release/&lt;crate_name&gt;</code>.</p>
<p><code>debug</code> hay <code>release</code> được gọi là các build target. Build trong <code>release</code> sẽ được apply nhiều optimization hơn, kích thước nhỏ hơn, chạy nhanh hơn nhưng compile lâu hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-crate"><a class="header" href="#use-crate">use crate</a></h1>
<p>Để sử dụng (import) một crate từ <a href="https://crates.io">https://crates.io</a>, ví dụ <a href="https://crates.io/crates/log">https://crates.io/crates/log</a>.</p>
<h3 id="1-thêm-crate-vào-cargotoml"><a class="header" href="#1-thêm-crate-vào-cargotoml">1. Thêm crate vào <code>Cargo.toml</code></a></h3>
<p>Có 2 cách</p>
<p><strong>Cách 1:</strong> Edit trực tiếp file <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
log = "0.4"
</code></pre>
<p><strong>Cách 2:</strong> Sử dụng <code>cargo add</code>, cargo sẽ tự động update file <code>Cargo.toml</code> cho bạn</p>
<pre><code class="language-bash">cargo add log
</code></pre>
<pre><code class="language-toml">[dependencies]
log = "0.4.17"
</code></pre>
<p>Để thêm crate vào dev dependencies (dùng cho tests), ta thêm <code>--dev</code> vào lệnh:</p>
<pre><code class="language-bash">cargo add --dev log
</code></pre>
<pre><code class="language-toml">[dev-dependencies]
log = "0.4.17"
</code></pre>
<h3 id="2-sử-dụng-crate-trong-code"><a class="header" href="#2-sử-dụng-crate-trong-code">2. Sử dụng crate trong code</a></h3>
<pre><pre class="playground"><code class="language-rust no_run edition2021">fn main() {
    log::info!("hello");
    log::error!("oops");
}</code></pre></pre>
<p>Sử dụng keyword <code>use</code>. Chức năng chính của <code>use</code> là bind lại full path
của element vào một tên mới, để chúng ta không cần phải lặp lại một tên dài mỗi lần sử dụng.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use log::info;
use log::error;

fn main() {
    info!("hello");
    error!("oops");
}</code></pre></pre>
<p>Nhóm các import lại với nhau:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use log::{info, error};

fn main() {
    info!("hello");
    error!("oops");
}</code></pre></pre>
<p>Import mọi thứ được public trong crate/module. Cách này thường hay tránh bởi
sẽ khó biết được function, struct, ... nào đó đang thuộc crate nào, ngoại trừ các <code>prelude::*</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">use log::*;

fn main() {
    info!("hello");
    error!("oops");
}</code></pre></pre>
<h3 id="use-trong-scope"><a class="header" href="#use-trong-scope"><code>use</code> trong scope</a></h3>
<p><code>use</code> cũng thường được sử dụng import element vào trong scope hiện tại.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello() -&gt; String {
  "Hello, world!".to_string()
}

#[cfg(test)]
mod tests {
  use super::hello; // Import the `hello()` function into the scope
    
  #[test]
  fn test_hello() {
    assert_eq!("Hello, world!", hello()); // If not using the above `use` statement, we can run same via `super::hello()`
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Bạn sẽ sẽ hay gặp:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

#[cfg(test)]
mod tests {
  use super::*;
  use log::info;
    
  // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="self-super"><a class="header" href="#self-super"><code>self::</code>, <code>super::</code></a></h3>
<p>Mặc định thì <code>use</code> sẽ import đường dẫn tuyệt đối, bắt đầu từ crate root.
<code>self</code> và <code>super</code> thường dùng để import mod theo vị trí tương đối.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/level_1/level_2/mod.rs

use self::hello_1;
use super::super::level3::hello_2;
<span class="boring">}</span></code></pre></pre>
<h3 id="re-export"><a class="header" href="#re-export">Re-export</a></h3>
<p>Một trường hợp đặt biệt là sử dụng <code>pub use</code> là re-exporting,
khi bạn thiết kế một module bạn có thể export một số thứ từ module khác (*) từ module của bạn.
Do đó người sử dụng có thể sử dụng các module khác đó ngay từ module của bạn.</p>
<p>Module khác (*) đó có thể là một internal module, internal crate hoặc external crate.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/utils.rs
pub use log::*;

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">// src/main.rs
use crate::utils::info;

fn main() {
    info!("...");
}</code></pre></pre>
<p>Pattern này được sử dụng khá nhiều ở các thư viện lớn.
Nó giúp ẩn đi các internal module phức tạp của library đối với user.
Bởi vì user sẽ không cần quan tâm đến cấu trúc directory phức tạp khi sử dụng một library nào đó.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="self-super-1"><a class="header" href="#self-super-1"><code>self::</code>, <code>super::</code></a></h3>
<p>Mặc định thì <code>use</code> sẽ import đường dẫn tuyệt đối, bắt đầu từ crate root.
<code>self</code> và <code>super</code> thường dùng để import mod theo vị trí tương đối.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/level_1/level_2/mod.rs

use self::hello_1;
use super::super::level3::hello_2;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="re-export-1"><a class="header" href="#re-export-1">Re-export</a></h3>
<p>Một trường hợp đặt biệt là sử dụng <code>pub use</code> là re-exporting,
khi bạn thiết kế một module bạn có thể export một số thứ từ module khác (*) từ module của bạn.
Do đó người sử dụng có thể sử dụng các module khác đó ngay từ module của bạn.</p>
<p>Module khác (*) đó có thể là một internal module, internal crate hoặc external crate.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/utils.rs
pub use log::*;

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail no_run edition2021">// src/main.rs
use crate::utils::info;

fn main() {
    info!("...");
}</code></pre></pre>
<p>Pattern này được sử dụng khá nhiều ở các thư viện lớn.
Nó giúp ẩn đi các internal module phức tạp của library đối với user.
Bởi vì user sẽ không cần quan tâm đến cấu trúc directory phức tạp khi sử dụng một library nào đó.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preludes"><a class="header" href="#preludes"><a href="https://doc.rust-lang.org/std/prelude/"><code>Preludes</code></a></a></h1>
<p><a href="https://doc.rust-lang.org/std/prelude/"><code>Preludes</code></a> là những thứ được định nghĩa trong <a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a>,
và được import sẵn, vì chúng thường sẽ phải được dùng trong mọi chương trình Rust.
Bạn có thể sử dụng mà không cần phải import, ví dụ như: <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>,
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>, ...</p>
<p>Mặc dù <a href="https://doc.rust-lang.org/std/index.html"><code>std</code></a> của Rust có rất nhiều module và tính năng, nhưng không phải mọi thứ đều được preludes.</p>
<p>Đây là danh sách những thứ được preludes: <a href="https://doc.rust-lang.org/std/prelude/#prelude-contents">https://doc.rust-lang.org/std/prelude/#prelude-contents</a></p>
<hr />
<ul>
<li><code><a href="https://doc.rust-lang.org/std/marker"><code>std::marker</code></a>::{<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html"><code>Copy</code></a>, <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>, <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sized.html"><code>Sized</code></a>, <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a>, <a href="https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html"><code>Unpin</code></a>}</code>,
marker traits that indicate fundamental properties of types.</li>
<li><code><a href="https://doc.rust-lang.org/std/ops"><code>std::ops</code></a>::{<a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>}</code>, various
operations for both destructors and overloading <code>()</code>.</li>
<li><code><a href="https://doc.rust-lang.org/std/mem"><code>std::mem</code></a>::<a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>drop</code></a></code>, a convenience function for explicitly
dropping a value.</li>
<li><code><a href="https://doc.rust-lang.org/std/boxed"><code>std::boxed</code></a>::<a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code>Box</code></a></code>, a way to allocate values on the heap.</li>
<li><code><a href="https://doc.rust-lang.org/std/borrow"><code>std::borrow</code></a>::<a href="https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a></code>, the conversion trait that defines
<a href="https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>to_owned</code></a>, the generic method for creating an owned type from a
borrowed type.</li>
<li><code><a href="https://doc.rust-lang.org/std/clone"><code>std::clone</code></a>::<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html"><code>Clone</code></a></code>, the ubiquitous trait that defines
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code>clone</code></a>, the method for producing a copy of a value.</li>
<li><code><a href="https://doc.rust-lang.org/std/cmp"><code>std::cmp</code></a>::{<a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>, <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a>}</code>, the
comparison traits, which implement the comparison operators and are often
seen in trait bounds.</li>
<li><code><a href="https://doc.rust-lang.org/std/convert"><code>std::convert</code></a>::{<a href="https://doc.rust-lang.org/stable/std/convert/trait.AsRef.html"><code>AsRef</code></a>, <a href="https://doc.rust-lang.org/stable/std/convert/trait.AsMut.html"><code>AsMut</code></a>, <a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code>Into</code></a>, <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code>From</code></a>}</code>, generic
conversions, used by savvy API authors to create overloaded methods.</li>
<li><code><a href="https://doc.rust-lang.org/std/default"><code>std::default</code></a>::<a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a></code>, types that have default values.</li>
<li><code><a href="https://doc.rust-lang.org/std/iter"><code>std::iter</code></a>::{<a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>Iterator</code></a>, <a href="https://doc.rust-lang.org/stable/std/iter/trait.Extend.html"><code>Extend</code></a>, <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>, <a href="https://doc.rust-lang.org/stable/std/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a>, <a href="https://doc.rust-lang.org/stable/std/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a>}</code>,
iterators of various
kinds.</li>
<li><code><a href="https://doc.rust-lang.org/std/option"><code>std::option</code></a>::<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>::{<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>self</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some"><code>Some</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None"><code>None</code></a>}</code>, a
type which expresses the presence or absence of a value. This type is so
commonly used, its variants are also exported.</li>
<li><code><a href="https://doc.rust-lang.org/std/result"><code>std::result</code></a>::<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>::{<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>self</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>, <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>}</code>, a type
for functions that may succeed or fail. Like <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, its variants are
exported as well.</li>
<li><code><a href="https://doc.rust-lang.org/std/string"><code>std::string</code></a>::{<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code>String</code></a>, <a href="https://doc.rust-lang.org/stable/std/string/trait.ToString.html"><code>ToString</code></a>}</code>, heap-allocated strings.</li>
<li><code><a href="https://doc.rust-lang.org/std/vec"><code>std::vec</code></a>::<a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a></code>, a growable, heap-allocated vector.</li>
</ul>
<p>The prelude used in Rust 2021, <a href="https://doc.rust-lang.org/std/prelude/rust_2021/index.html"><code>std::prelude::rust_2021</code></a>, includes all of the above,
and in addition re-exports:</p>
<ul>
<li><code><a href="https://doc.rust-lang.org/std/convert"><code>std::convert</code></a>::{<a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>, <a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>}</code>,</li>
<li><code><a href="https://doc.rust-lang.org/std/iter"><code>std::iter</code></a>::<a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a></code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p><em>Ownership</em> là một trong những tính năng đặc trưng của Rust, đây là cách giúp Rust đảm bảo memory safety mà không cần đến garbage collector.</p>
<h1 id="ownership-là-gì"><a class="header" href="#ownership-là-gì">Ownership là gì?</a></h1>
<p><strong>Ownership</strong> là một khái niệm mới. Tất cả các chương trình đều cần phải quản lý
bộ nhớ mà chúng sử dụng trong quá trình thực thi. Một số ngôn ngữ sử dụng garbage collection
để tìm và giải phóng bộ nhớ trong thời gian chạy, trong khi một số ngôn ngữ khác yêu cầu
lập trình viên tự cấp phát (allocate) và giải phóng (free) bộ nhớ. Rust đi theo một hướng khác,
trong đó bộ nhớ được quản lý bởi một hệ thống ownership với các quy tắc mà trình biên dịch
sử dụng để kiểm tra (check) trong quá trình biên dịch. Bằng cách này, Rust buộc chúng ta
phải viết mã theo cách an toàn cho bộ nhớ, và sẽ phát hiện lỗi ngay trong quá trình biên dịch.
Càng hiểu rõ về khái niệm ownership, chúng ta càng có thể viết mã an toàn và hiệu quả hơn.</p>
<p>Để tìm hiểu kỹ hơn về Ownership, bạn có thể đọc Rust Book tại đây cực kỳ chi tiết:
<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-rules">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<p>Nói đơn giản về <em>ownership rules</em> thì có một số điều cơ bản sau:</p>
<ul>
<li>Mỗi giá trị trong Rust đều có một biến gọi là owner của nó.</li>
<li>Chỉ có một owner tại một thời điểm.</li>
<li>Khi owner ra khỏi scope, giá trị sẽ bị hủy.</li>
</ul>
<h3 id="borrow-checker"><a class="header" href="#borrow-checker">Borrow checker</a></h3>
<p>Bằng cách theo dõi data sử dụng thông qua bộ rules,
borrow checker có thể xác định khi nào data cần được khởi tạo
(initialized) và khi nào cần được giải phóng (freed, or dropped).<br />
Thực tế sẽ có một trong ba trường hợp sau khi bạn sử dụng variable:
tự move data và bỏ ownership; copy data sang một variable khác;
hoặc sử dụng reference (con trỏ) đến data và vẫn giữ ownership,
cho mượn (borrow) nó một thời gian.</p>
<p>Chỉ cần nhớ hai quy tắc quan trọng:</p>
<ol>
<li>Khi truyền một variable (thay vì reference tới variable) cho một function khác, ta sẽ mất quyền ownership. Function đó sẽ là owner của variable này và bạn không thể sử dụng lại được nữa ở context cũ.</li>
<li>Khi truyền một reference tới variable, bạn có thể <strong>immutable</strong> borrow không giới hạn; hoặc <strong>mutable</strong> borrow một lần.</li>
</ol>
<p>Ví dụ: đoạn chương trình sau sẽ không compile được</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail should_panic edition2021">fn hold_my_vec&lt;T&gt;(_: Vec&lt;T&gt;) {}

fn main() {
  let x = vec![1, 2, 3];
  hold_my_vec(x);

  let z = x.get(0);
  println!("Got: {:?}", z);
}</code></pre></pre>
<p>Compiler sẽ báo lỗi như sau: <code>rustc main.rs</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">error[E0382]: borrow of moved value: `x`
    --&gt; main.rs:7:13
  |
4 |  let x = vec![1, 2, 3];
  |      - move occurs because `x` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5 |  hold_my_vec(x);
  |              - value moved here
6 |
7 |  let z = x.get(0);
  |          ^^^^^^^^ value borrowed here after move
  |
  = note: borrow occurs due to deref coercion to `[i32]`</code></pre></pre>
<p>Lỗi nói rằng <code>Vec&lt;i32&gt;</code> không implement
<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy trait</a>,
vì thế data sẽ được di chuyển (move) hoặc mượn (borrow) vào function
<code>hold_my_vec()</code>. Do đó dòng 7 không thể thực hiện được do <code>x</code> được
được move vào trong function kia.</p>
<p>Mặc dùng không thể implement <code>Copy</code> trait, <code>Vec</code> vẫn có
<a href="https://doc.rust-lang.org/core/clone/trait.Clone.html">Clone trait</a>.
Chỉ để cho code chạy được thì đây là một cách nhanh để compiler ngưng báo lỗi.
Lưu ý thì việc clone thường sẽ tốn khá nhiều chi phí, nhất là đối với những object lớn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn hold_my_vec&lt;T&gt;(_: Vec&lt;T&gt;) {}

fn main() {
  let x = vec![1, 2, 3];
  hold_my_vec(x.clone()); // &lt;-- x.clone()

  let z = x.get(0);
  println!("Got: {:?}", z);
}</code></pre></pre>
<p>Trong trường hợp này, function <code>hold_my_vec</code> không làm gì ngoài việc nhận ownership.
Có một cách tốt hơn là <strong>references.</strong>
Thay vì để function nhận ownership, ta có thể cho nó mượn giá trị.
Chúng ta sẽ truyền vào một reference — một giá trị được mượn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn hold_my_vec&lt;T&gt;(_: &amp;Vec&lt;T&gt;) {}

fn main() {
  let x = vec![1, 2, 3];
  hold_my_vec(&amp;x); // &lt;--- &amp;x

  let z = x.get(0);
  println!("Got: {:?}", z);
}</code></pre></pre>
<p>Với cách này thì chúng ta sẽ để function mượn trong khi
vẫn có thể tiếp tục sử sử dụng trong chương trình.</p>
<p>Bạn có thể đọc thêm về <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">Ownership</a>,
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing">References and Borrowing</a> và
<a href="https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type">The Slice Type</a> tại the Rust Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<p>Struct được sử dụng trong Rust rất nhiều, hầu như là mọi lúc. Với struct ta có thể định nghĩa một kiểu dữ liệu riêng.</p>
<p>Tên của struct thường là <code>UpperCamelCase</code>. Nếu bạn định nghĩa tên struct là lowercase, compiler sẽ nhắc nhở ngay.</p>
<pre><code class="language-bash">warning: type `duyet_struct` should have an upper camel case name
 --&gt; src/main.rs:1:8
  |
1 | struct duyet_struct;
  |        ^^^^^^^^^^^^ help: convert the identifier to upper camel case: `DuyetStruct`
  |
  = note: `#[warn(non_camel_case_types)]` on by default
</code></pre>
<p>Có 3 loại struct:</p>
<h1 id="unit-struct"><a class="header" href="#unit-struct">Unit struct</a></h1>
<p>Unit struct là một struct mà không có gì cả:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct FileDirectory;
fn main() {}</code></pre></pre>
<h1 id="tuple-struct"><a class="header" href="#tuple-struct">Tuple struct</a></h1>
<p>Tuple struct hay còn gọi là Unnamed struct. Bạn chỉ cần định nghĩa kiểu dữ liệu, không cần định tên field name.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Colour(u8, u8, u8);

fn main() {
  let my_colour = Colour(50, 0, 50); // Make a colour out of RGB (red, green, blue)

  println!("The first part of the colour is: {}", my_colour.0);
  println!("The second part of the colour is: {}", my_colour.1);
}

// The first part of the colour is: 50
// The second part of the colour is: 0</code></pre></pre>
<h1 id="named-struct"><a class="header" href="#named-struct">Named struct</a></h1>
<p>Phổ biến nhất, bạn sẽ phải định nghĩa field name trong block <code>{}</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Colour(u8, u8, u8); // Declare the same Colour tuple struct

struct SizeAndColour {
  size: u32,
  colour: Colour, // And we put it in our new named struct
		  // The last comma is optional, but recommended
}

fn main() {
  let colour = Colour(50, 0, 50);

  let size_and_colour = SizeAndColour {
    size: 150,
    colour: colour
  };
}</code></pre></pre>
<p><code>colour: colour</code> có thể được viết gọn lại thành:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let size_and_colour = SizeAndColour {
  size: 150,
  colour
};</code></pre></pre>
<p>Xem về <a href="basic/./trait/README.html">Trait</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p>Rust có nhiều loại data types như primitives (<code>i8</code>, <code>i32</code>, <code>str</code>, ...), struct, enum và các loại kết hợp (aggregate) như tuples và array. Mọi types không có mối liên hệ nào với nhau. Các data types có các phương thức (methods) để tính toán hay convert từ loại này sang loại khác, nhưng chỉ để cho tiện lợi hơn, method chỉ là các function. Bạn sẽ làm gì nếu một tham số là nhiều loại kiểu dữ liệu? Một số ngôn ngữ như Typescript hay Python sẽ có cách sử dụng Union type như thế này:</p>
<pre><code class="language-typescript">function notify(data: string | number) {
  if (typeof data == 'number') {
    // ...
  } else if (typeof data == 'number') {
    // ...
  }
}
</code></pre>
<p>Còn trong Rust thì sao?</p>
<p><img src="https://i.imgur.com/ZKHSRQK.png" alt="Trait implementations for Display" /></p>
<h1 id="trait-là-gì"><a class="header" href="#trait-là-gì">Trait là gì?</a></h1>
<p>Có thể bạn đã thấy qua trait rồi: <code>Debug</code>, <code>Copy</code>, <code>Clone</code>, ... là các trait.</p>
<p>Trait là một cơ chế abstract để thêm các tính năng (functionality) hay hành vi (behavior)
khác nhau vào các kiểu dữ liệu (types) và tạo nên các mối quan hệ giữa chúng.</p>
<p>Trait thường đóng 2 vai trò:</p>
<ol>
<li>Giống như là interfaces trong Java hay C# (fun fact: lần đầu tiên nó được gọi là <code>interface</code>). Ta có thể kế thừa (inheritance) interface, nhưng không kế thừa được implementation của interface*.* Cái này giúp Rust có thể hỗ trợ <a href="https://stevedonovan.github.io/rust-gentle-intro/object-orientation.html">OOP</a>. Nhưng có một chút khác biệt, nó không hẳn là interface.</li>
<li>Vai trò này phổ biến hơn, trait đóng vai trò là generic constraints. Dễ hiểu hơn, ví dụ, bạn định nghĩa một function, tham số là một <em>kiểu dữ liệu bất kỳ</em> nào đó, không quan tâm, miễn sau kiểu dữ liệu đó phải có phương thức <code>method_this()</code>, <code>method_that()</code> nào đó cho tui. <em>Kiểu dữ liệu nào đó</em> gọi là <em>genetic type</em>. Function có chứa tham số generic type đó được gọi là <em>generic function</em>. Và việc ràng buộc phải có <code>method_this()</code>, <code>method_that()</code> , ... gọi là <em>generic constraints</em>. Mình sẽ giải thích rõ cùng với các ví dụ sau dưới đây.</li>
</ol>
<p>Để gắn một trait vào một type, bạn cần implement nó.
Bởi vì <code>Debug</code> hay <code>Copy</code> quá phổ biến, nên Rust có attribute để tự động implement:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct MyStruct {
  number: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>Nhưng một số trait phức tạp hơn bạn cần định nghĩa cụ thể
bằng cách <code>impl</code> nó. Ví dụ bạn có trait <code>Add</code>
(<a href="https://doc.rust-lang.org/std/ops/trait.Add.html#implementors">std::ops::Add</a>)
để add 2 type lại với nhau. Nhưng Rust sẽ không biết cách bạn add 2
type đó lại như thế nào, bạn cần phải tự định nghĩa:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct MyStruct {
  number: usize,
}

impl Add for MyStruct {    // &lt;-- here
  type Output = Self;
  fn add(self, other: Self) -&gt; Self {
    Self { number: self.number + other.number }
  }
}

fn main() {
  let a1 = MyStruct { number: 1 };
  let a2 = MyStruct { number: 2 };
  let a3 = MyStruct { number: 3 };

  assert_eq!(a1 + a2, a3);
}</code></pre></pre>
<p>Note: Mình sẽ gọi <strong>Define Trait</strong> là việc định nghĩa,
khai báo một trait mới trong Rust (<code>trait Add</code>).
<strong>Implement Trait</strong> là việc khai báo nội dung của function được
liệu kê trong Trait cho một kiểu dữ liệu cụ thể nào đó (<code>impl Add for MyStruct</code>).</p>
<h1 id="chi-tiết"><a class="header" href="#chi-tiết">Chi tiết</a></h1>
<ul>
<li><a href="basic/trait/./define-a-trait.html">Khai báo Trait</a></li>
<li><a href="basic/trait/./impl-trait.html">Implement Trait cho một Type</a></li>
<li><a href="basic/trait/./default-impls.html">Default Implementations</a></li>
<li><a href="basic/trait/./trait-as-params.html">Traits as Parameters</a></li>
<li><a href="basic/trait/./trait-bound.html">Trait Bound</a></li>
<li><a href="basic/trait/./multiple-trait-bound.html">Multiple Trait Bound</a></li>
<li><a href="basic/trait/./where-clauses.html"><code>where</code> Clauses</a></li>
<li><a href="basic/trait/./return-impl-trait.html">Returning Types that Implement Traits</a></li>
<li><a href="basic/trait/./conditionally-impl.html">Using Trait Bounds to Conditionally Implement Methods</a></li>
<li><a href="basic/trait/./blanked-impl.html">Blanket implementations</a></li>
<li><a href="basic/trait/./trait-inheritance.html">Trait Inheritance</a></li>
<li><a href="basic/trait/./supertraits.html">Supertraits</a></li>
<li><a href="basic/trait/./auto-trait.html">Auto Trait</a></li>
<li><a href="basic/trait/./copy-clone.html">Copy, Clone</a></li>
<li><a href="basic/trait/./string-str.html">String và &amp;str</a></li>
<li><a href="basic/trait/./fromstr.html">FromStr</a></li>
<li><a href="basic/trait/">Display</a></li>
</ul>
<h1 id="kết"><a class="header" href="#kết">Kết</a></h1>
<p>Compiler sử dụng trait bound để kiểm tra các kiểu dữ liệu được sử dụng trong code có đúng behavior không.
Trong Python hay các ngôn ngữ dynamic typed khác, ta sẽ gặp lỗi lúc runtime nếu chúng ta gọi các method mà
kiểu dữ liệu đó không có hoặc không được định nghĩa.</p>
<p>Bạn có chắc chắn là <code>a</code> dưới đây có method <code>summarize()</code> hay không?
Nhớ rằng typing hint của Python3 chỉ có tác dụng là nhắc nhở cho lập trình viên thôi.</p>
<pre><code class="language-python"># Python
func print_it(a: Union[NewsArticle, Tweet]):
  print(a.summarize())

print_it(1)
print_it("what")
</code></pre>
<p>Do đó Rust bắt được mọi lỗi lúc compile time và force chúng ta phải fix hết trước khi chương trình chạy.
Do đó chúng ta không cần phải viết thêm code để kiểm tra behavior (hay sự tồn tại của method)
trước khi sử dụng lúc runtime nữa, tăng cường được performance mà không phải từ bỏ tính flexibility của generics.</p>
<p>Xem về <a href="basic/trait/../struct.html">Struct</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="khai-báo--định-nghĩa-một-trait"><a class="header" href="#khai-báo--định-nghĩa-một-trait">Khai báo / định nghĩa một Trait</a></h1>
<p>Nhắc lại là Trait định nghĩa các hành vi (behavior).
Các types khác nhau có thể chia sẻ cùng cá hành vi.
Định nghĩa một trait giúp <strong>nhóm</strong> các hành vi để làm một việc gì đó.</p>
<p>Theo ví dụ của Rust Book, ví dụ ta các struct chứa nhiều loại text:</p>
<ul>
<li><code>NewsArticle</code> struct chứa news story, và</li>
<li><code>Tweet</code> struct có thể chứa tối đa 280 characters cùng với metadata.</li>
</ul>
<p>Bây giờ chúng ta cần viết 1 crate name có tên là <code>aggregator</code>
có thể hiển thị summaries của data có thể store trên <code>NewsArticle</code>
hoặc <code>Tweet</code> instance. Chúng ta cần định nghĩa method <code>summarize</code>
trên mỗi instance. Để định nghĩa một trait, ta dùng <code>trait</code> theo sau
là trait name; dùng keyword <code>pub</code> nếu định nghĩa một public trait.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String;
}</code></pre></pre>
<p>Trong ngoặc, ta định nghĩa các method signatures để định nghĩa hành vi:
<code>fn summarize(&amp;self) -&gt; String</code>. Ta có thể định nghĩa nội dung của function.
Hoặc không, ta dùng <code>;</code> kết thúc method signature, để bắt buộc type nào
implement <code>trait Summary</code> đều phải định nghĩa riêng cho nó,
bởi vì mỗi type (<code>NewsArticle</code> hay <code>Tweet</code>) đều có cách riêng để <code>summarize</code>. Mỗi trait có thể có nhiều method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implement-trait-cho-một-type"><a class="header" href="#implement-trait-cho-một-type">Implement Trait cho một Type</a></h1>
<p>Bây giờ ta định implement các method của trait Summary cho từng type.
Ví dụ dưới đây ta có <code>struct NewsArticle</code> và <code>struct Tweet</code>,
và ta định nghĩa <code>summarize</code> cho 2 struct này.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">    pub trait Summary {
        fn summarize(&amp;self) -&gt; String;
    }

    pub struct NewsArticle {
        pub headline: String,
        pub location: String,
        pub author: String,
        pub content: String,
    }

    impl Summary for NewsArticle {
        fn summarize(&amp;self) -&gt; String {
            format!("{}, by {} ({})", self.headline, self.author, self.location)
        }
    }

    pub struct Tweet {
        pub username: String,
        pub content: String,
        pub reply: bool,
        pub retweet: bool,
    }

    impl Summary for Tweet {
        fn summarize(&amp;self) -&gt; String {
            format!("{}: {}", self.username, self.content)
        }
    }</code></pre></pre>
<p>Implement trait cho type giống như <code>impl</code> bình thường,
chỉ có khác là ta thêm <strong>trait name</strong> và keyword <code>for</code> sau <code>impl</code>.
Bây giờ Summary đã được implement cho <code>NewsArticle</code> và <code>Tweet</code>,
người sử dụng crate đã có thể sử dụng các phương thức của trait như các method function bình thường.
Chỉ một điều khác biệt là bạn cần mang trait đó vào cùng scope hiện tại cùng với type để có thể sử dụng.
Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use aggregator::{Summary, Tweet}; // &lt;-- same scope

fn main() {
  let tweet = Tweet {
    username: String::from("horse_ebooks"),
    content: String::from("of course, as you probably already know, people"),
    reply: false,
    retweet: false,
  };

  println!("1 new tweet: {}", tweet.summarize());
  // 1 new tweet: horse_ebooks: of course, as you probably already know, people
}</code></pre></pre>
<p>Rust Playground: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dc563051aecebae4344776c06fb1b49d">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dc563051aecebae4344776c06fb1b49d</a></p>
<p>Chúng ta có thể implement trait cho mọi type khác bất kỳ, ví dụ implement <code>Summary</code> cho <code>Vec&lt;T&gt;</code> trong scope của crate hiện tại.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String;
}

impl&lt;T&gt; Summary for Vec&lt;T&gt; {    // &lt;-- local scope
  fn summarize(&amp;self) -&gt; String {
    format!("There are {} items in vec", self.len())
  }
}

fn main() {
  let vec = vec![1i32, 2i32];
  println!("{}", vec.summarize());
  // There are 2 items in vec
}</code></pre></pre>
<p>Rust Playground: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dcaa812fab222ec0c713a38b066bda20">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dcaa812fab222ec0c713a38b066bda20</a></p>
<p>Bạn sẽ không thể implement external traits trên external types.
Ví dụ ta không thể implement <code>Display</code> cho <code>Vec&lt;T&gt;</code> bởi vì
<code>Display</code> và <code>Vec&lt;T&gt;</code> được định nghĩa trong standard library,
trong trong crate hiện tại. Rule này giúp tránh chống chéo và chắc chắn
rằng không ai có thể break code của người khác và ngược lại.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h1>
<p>Đôi khi bạn cần có default behavior mà không cần phải implement content cho từng type mỗi khi cần sử dụng:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Summary {
  fn summarize(&amp;self) -&gt; String {
    String::from("(Read more...)")
  }
}

pub struct NewsArticle {
  pub headline: String,
  pub location: String,
  pub author: String,
  pub content: String,
}

impl Summary for NewsArticle {}; // &lt;-- sử dụng {}

fn main() {
  let article = NewsArticle { ... };
  println!("New article: {}", article.summarize());
  // New article: (Read more...)
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-as-parameters"><a class="header" href="#traits-as-parameters">Traits as Parameters</a></h1>
<p>Trở lại ví dụ Typescript ở đầu tiên, với Trait bạn đã có thể define
một function chấp nhận tham số là nhiều kiểu dữ liệu khác nhau.
Nói theo một cách khác, bạn không cần biết kiểu dữ liệu,
bạn cần biết kiểu dữ liệu đó mang các behavior nào thì đúng hơn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn notify(data: &amp;impl Summary) {
  println!("News: {}", data.summarize());
}

fn main() {
  let news = NewsArticle {};
  notify(news);
}</code></pre></pre>
<p>Ở đây, thay vì cần biết <code>data</code> là type nào (<code>NewsArticle</code> hay <code>Tweet</code>?),
ta chỉ cần cho Rust compiler biết là <code>notify</code> sẽ chấp nhận mọi
<strong>type có implement</strong> <code>trait Summary</code>, mà trait Summary có behavior <code>.summarize()</code>,
do đó ta có thể sử dụng method <code>.summary()</code> bên trong function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-bound"><a class="header" href="#trait-bound">Trait Bound</a></h1>
<p>Một syntax sugar khác mà ta có thể sử dụng thay cho <code>&amp;impl Summary</code> ở trên,
gọi là <em>trait bound</em>, bạn sẽ bắt gặp nhiều trong Rust document:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
  println!("News: {}", item.summarize());
}</code></pre></pre>
<p>Đầu tiên chúng ta định nghĩa trait bound bằng cách định nghĩa
một generic type parameter trước, sau đó là <code>:</code> trong ngoặc <code>&lt;</code> và <code>&gt;</code>.
Ta có thể đọc là: <code>item</code> có kiểu generic là <code>T</code> và <code>T</code> phải được <code>impl Summary</code>.</p>
<ul>
<li><code>notify&lt;T&gt;(</code> khai báo generic type <code>T</code></li>
<li><code>notify&lt;T: Summary&gt;(</code> generic type được implement <code>trait Summary</code></li>
</ul>
<p>Cú pháp này có thể dài hơn và không dễ đọc như <code>&amp;impl Summary</code>, nhưng hãy xem ví dụ dưới đây:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {}  // (1)
pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {}            // (2)</code></pre></pre>
<p>Dùng <em>trait bound</em> giúp ta tái sử dụng lại <code>T</code>,
mà còn giúp force <code>item1</code> và <code>item2</code> có cùng kiểu dữ liệu,
đây là cách duy nhất (cả 2 đều là <code>NewsArticle</code> hoặc cả 2 đều là <code>Tweet</code>) mà (1) không thể.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-multiple-trait-bounds-with-the--syntax"><a class="header" href="#specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the + Syntax</a></h1>
<p>Ta có cú pháp <code>+</code> nếu muốn generic <code>T</code> có được impl nhiều trait khác nhau.
Ví dụ ta muốn <code>item</code> phải có cả <code>Summary</code> lẫn <code>Display</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn notify(item: &amp;(impl Summary + Display)) {}
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-clauses"><a class="header" href="#where-clauses"><code>where</code> Clauses</a></h1>
<p>Đôi khi bạn sẽ có nhiều genenic type, mỗi generic type lại có nhiều trait bound,
khiến code khó đọc. Rust có một cú pháp <code>where</code> cho phép định nghĩa trait bound
phía sau function signature. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {</code></pre></pre>
<p>Với <code>where</code> clause:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
	  U: Clone + Debug,
{</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></h1>
<p>Chúng ta cũng có thể sử dụng <code>impl Trait</code> cho giá trị được trả về của function.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("ahihi"),
        reply: false,
        retweet: false,
    }
}</code></pre></pre>
<p>Được đọc là: function <code>returns_summarizable()</code> trả về bất kỳ kiểu dữ liệu nào có <code>impl Summary</code>.
Tuy nhiên bạn chỉ có thể return về hoặc <code>Tweet</code>
hoặc <code>NewsArticle</code> do cách implement của compiler. Code sau sẽ có lỗi:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch { NewsArticle {} }
		else { Tweet {} }
}</code></pre></pre>
<p>Rust Book có một chương riêng để xử lý vấn đề này: <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">Chapter 17: Using Trait Objects That Allow for Values of Different Types</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-trait-bounds-to-conditionally-implement-methods"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></h1>
<p>Ta có thể implement 1 method có điều kiện cho bất kỳ type nào
có implement một trait khác cụ thể. Ví dụ để dễ hiểu hơn dưới đây:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

struct Pair&lt;T&gt; {
  x: T,
  y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
  fn new(x: T, y: T) -&gt; Self {
    Self { x, y }
  }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
  fn cmp_display(&amp;self) {
    if self.x &gt;= self.y {
      println!("The largest member is x = {}", self.x);
    } else {
      println!("The largest member is y = {}", self.y);
    }
  }
}</code></pre></pre>
<p><code>impl&lt;T&gt; Pair&lt;T&gt;</code> implement function <code>new</code> trả về kiểu dữ liệu <code>Pair&lt;T&gt;</code> với <code>T</code> là generic (bất kỳ kiểu dữ liệu nào.</p>
<p><code>impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt;</code> implement function <code>cmp_display</code>
cho mọi generic <code>T</code> với <code>T</code> đã được implement <code>Display + PartialOrd</code>
trước đó rồi (do đó mới có thể sử dụng các behavior của
<code>Display</code> (<code>println!("{}")</code>) và <code>PartialOrd</code> (<code>&gt;</code>, <code>&lt;</code>, ...) được.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blanket-implementations"><a class="header" href="#blanket-implementations">Blanket implementations</a></h1>
<p>Ta cũng có thể implement 1 trait có điều kiện cho bất kỳ kiểu dữ liệu
nào có implement một trait khác rồi. Implementation của một trait cho
1 kiểu dữ liệu khác thỏa mãn trait bound được gọi là <em>blanket implementations</em>
và được sử dụng rộng rãi trong Rust standard library.
Hơi xoắn não nhưng hãy xem ví dụ dưới đây.</p>
<p>Ví dụ: <code>ToString</code> trait trong
<a href="https://doc.rust-lang.org/src/alloc/string.rs.html#2390">Rust standard library</a>,
nó được implement cho mọi kiểu dữ liệu nào có được implement <code>Display</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl&lt;T: Display&gt; ToString for T {
  // --snip--
}</code></pre></pre>
<p>Có nghĩa là, với mọi type có <code>impl Display</code>, ta có hiển nhiên thể sử dụng được các thuộc tính của <code>trait ToString</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let s = 3.to_string(); // do 3 thoaỏa manãn Display</code></pre></pre>
<p>Do <code>3</code> thỏa mãn điều kiện là đã được <code>impl Display for i32</code>.
(<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html#impl-Display-11">https://doc.rust-lang.org/std/fmt/trait.Display.html#impl-Display-11</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-inheritance"><a class="header" href="#trait-inheritance">Trait Inheritance</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait B: A {}</code></pre></pre>
<p>Cái này không hẳn gọi là <em>Trait Inheritance</em>, cái này đúng hơn gọi là "cái nào implement cái <code>B</code> thì cũng nên implement cái <code>A</code>". <code>A</code> và <code>B</code> vẫn là 2 trait độc lập nên vẫn phải implemenet cả 2.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl B for Z {}
impl A for Z {}</code></pre></pre>
<p>Inheritance thì không được khuyến khích sử dụng.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h1>
<p>Rust không có khái niệm "kế thừa" như trong OOP.
Nhưng bạn có thể định nghĩa một trait là một tập hợp của các trait khác.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Person {
  fn name(&amp;self) -&gt; String;
}

// Person là một supertrait của Student.
// Implement Student yêu cầu bạn phải cũng phải impl Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) là một subtrait
// của cả Programmer và Student.
//
// Implement CompSciStudent yêu cầu bạn phải impl tất cả supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        "My name is {} and I attend {}. My favorite language is {}. My Git username is {}",
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-traits"><a class="header" href="#auto-traits">Auto Traits</a></h1>
<p>Auto traits là các trait đánh dấu (marker trait) được tự động triển khai cho mọi kiểu dữ liệu,
trừ khi kiểu dữ liệu hoặc một kiểu dữ liệu mà nó chứa được khai báo tường minh là không impl bằng cách sử dụng <code>negative_impls</code>.</p>
<p>Ta cần bật feature <code>auto_traits</code> để khai báo auto trait.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(auto_traits)]

<span class="boring">fn main() {
</span>auto trait Valid {}
<span class="boring">}</span></code></pre></pre>
<p>Sau đó, ta có thể triển khai <code>trait Valid</code> cho các kiểu dữ liệu khác nhau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(auto_traits)]
#![feature(negative_impls)]
<span class="boring">auto trait Valid {}
</span>
struct True;
struct False;

// Negative impl
// Có nghĩa là Valid không được auto impl cho struct False
impl !Valid for False {}

// Nếu T được impl trait Valid, thì MaybeValid&lt;T&gt; cũng được impl trait Valid
struct MaybeValid&lt;T&gt;(T);

fn must_be_valid&lt;T: Valid&gt;(_t: T) { }

fn main() {
    // Hoạt động
    must_be_valid(MaybeValid(True));

    // Báo lỗi - do `False` không được impl trait Valid
    // must_be_valid(MaybeValid(False));
}</code></pre></pre>
<p>Auto trait <code>Valid</code>, sẽ tự động impl cho mọi <code>struct</code>, <code>enum</code>, ...</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li>https://doc.rust-lang.org/beta/unstable-book/language-features/auto-traits.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-clone"><a class="header" href="#copy-clone">Copy, Clone</a></h1>
<p>Có một số kiểu dữ liệu trong Rust rất đơn giản (simple types),
bao gồm integers, floats, booleans (<code>true</code> và <code>false</code>), và <code>char</code>.
Các simple types này nằm trên stack bởi vì complier biết chính xác size của nó.
Chúng được gọi là <strong>copy types</strong>. Bởi vì nó simple và nhỏ gọn nên dễ dàng để copy,
do đó compiler luôn copy nếu bạn bỏ nó vào function.</p>
<p>Làm sao để biết đọc một kiểu dữ liệu có được <strong>implement Copy</strong> hay không.
Bạn có thể xem trong Rust document. Ví dụ <code>char</code>:
<a href="https://doc.rust-lang.org/std/primitive.char.html">https://doc.rust-lang.org/std/primitive.char.html</a></p>
<p>Nếu bạn thấy:</p>
<ul>
<li><strong>Copy</strong>: có thể được copy nếu bạn bỏ nó vào function.</li>
<li><strong>Display:</strong> bạn có thể sử dụng <code>{}</code> để print.</li>
<li><strong>Debug:</strong> bạn có thể sử dụng <code>{:?}</code> để print.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_number(number: i32) {
  println!("{}", number);
}

fn main() {
  let my_number = 8;
  prints_number(my_number); // Prints 8. prints_number gets a copy of my_number
  prints_number(my_number); // Prints 8 again.
                            // No problem, because my_number is copy type!
}</code></pre></pre>
<p>Do <code>i32</code> được Copy nên chúng ta có thể sử dụng <code>my_number</code> nhiều lần mà không cần borrow <code>&amp;</code> như struct.</p>
<h1 id="clone-trait"><a class="header" href="#clone-trait">Clone trait</a></h1>
<p>Nếu bạn đọc document của String: <a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p><img src="basic/trait/clone-trait.png" alt="" /></p>
<p>String không được implement <strong>Copy</strong>, thay vào đó là <strong>Clone</strong>. Clone cũng giúp copy giá trị nhưng sẽ cần rất nhiều memory, và ta phải tự gọi method <code>.clone()</code> chứ Rust sẽ không tự Clone.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: String) {
  println!("{}", country_name);
}

fn main() {
  let country = String::from("Duyet");
  prints_country(country);
  prints_country(country); // ⚠️
}</code></pre></pre>
<p>Sẽ báo lỗi, theo như compiler giải thích rằng <code>country</code> là <code>String</code> và không được implement <code>Copy</code> nên country bị move vào trong function. Do đó ta không thể sử dụng <code>country</code> được nữa.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">error[E0382]: use of moved value: `country`
 --&gt; src/main.rs:8:20
  |
6 | let country = String::from("Duyet");
  |     ------- move occurs because `country` has type `String`, which does not implement the `Copy` trait
7 | prints_country(country);
  |                ------- value moved here
8 | prints_country(country); // ⚠️
  |                ^^^^^^^ value used here after move

For more information about this error, try `rustc --explain E0382`.</code></pre></pre>
<p>Có hai cách:</p>
<h3 id="1-sử-dụng-clone"><a class="header" href="#1-sử-dụng-clone">(1) Sử dụng <code>.clone()</code></a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: String) {
  println!("{}", country_name);
}

fn main() {
  let country = String::from("Duyet");
  prints_country(country.clone()); // &lt;-- clone
  prints_country(country);
}</code></pre></pre>
<p>String rất lớn, do đó <code>.copy()</code> sẽ tốn rất nhiều bộ nhớ. Sử dụng <code>&amp;</code> để reference sẽ nhanh hơn, nếu có thể.</p>
<h3 id="2-sử-dụng--reference"><a class="header" href="#2-sử-dụng--reference">(2) Sử dụng <code>&amp;</code> reference</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: &amp;String) {
  println!("{}", country_name);
}

fn main() {
  let country = String::from("Duyet");
  prints_country(&amp;country);
  prints_country(&amp;country);
}</code></pre></pre>
<h1 id="bonus-string-và-str"><a class="header" href="#bonus-string-và-str">Bonus: <code>String</code> và <code>&amp;str</code></a></h1>
<p>Nếu bạn có một <code>String</code> và <code>&amp;</code> reference, Rust sẽ convert nó thành <code>&amp;str</code> khi bạn cần.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: &amp;str) {
  println!("{}", country_name);
}

fn main() {
  let country = String::from("Duyet");
  prints_country(&amp;country);
  prints_country(&amp;country);
}</code></pre></pre>
<p><code>&amp;str</code> là một kiểu hơi phức tạp.</p>
<ul>
<li>Nó có thể vừa là String literals <code>let s = "I am &amp;str";</code>. Trường hợp này <code>s</code> có kiểu <code>&amp;'static</code> bởi vì nó được ghi trực tiếp vào binary.</li>
<li><code>&amp;str</code> cũng có thể là borrowed của <code>str</code> hoặc <code>String</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bonus-string-và-str-1"><a class="header" href="#bonus-string-và-str-1">Bonus: <code>String</code> và <code>&amp;str</code></a></h1>
<p>Nếu bạn có một <code>String</code> và <code>&amp;</code> reference, Rust sẽ convert nó thành <code>&amp;str</code> khi bạn cần.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn prints_country(country_name: &amp;str) {
  println!("{}", country_name);
}

fn main() {
  let country = String::from("Duyet");
  prints_country(&amp;country);
  prints_country(&amp;country);
}</code></pre></pre>
<p><code>&amp;str</code> là một kiểu hơi phức tạp.</p>
<ul>
<li>Nó có thể vừa là String literals <code>let s = "I am &amp;str";</code>. Trường hợp này <code>s</code> có kiểu <code>&amp;'static</code> bởi vì nó được ghi trực tiếp vào binary.</li>
<li><code>&amp;str</code> cũng có thể là borrowed của <code>str</code> hoặc <code>String</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromstr"><a class="header" href="#fromstr"><code>FromStr</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">FromStr</a>
là một trait để khởi tạo instance từ string trong Rust,
nó tương đương abstract class nếu bạn có background OOP.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait FromStr {
  type Err;
  fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}</code></pre></pre>
<p>Thường phương thức <code>from_str</code> của <code>FromStr</code> thường được ngầm định
sử dụng thông qua phương thức
<a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.parse">parse</a>
của <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Thay vì
let one = u32::from_str("1");

// thì sử dụng phương thức parse
let one: u32 = "1".parse().unwrap();
assert_eq!(1, one);

// parse() sử dụng turbofish ::&lt;&gt;
let two = "2".parse::&lt;u32&gt;();
assert_eq!(Ok(2), two);

let nope = "j".parse::&lt;u32&gt;();
assert!(nope.is_err());</code></pre></pre>
<p><code>parse</code> là một phương thức general nên thường được sử dụng với kiểu dữ liệu
như trên hoặc sử dụng <a href="basic/trait/../turbofish.html">turbofish</a> <code>::&lt;&gt;</code> để thuật toán inference
có thể hiểu để parse thành đúng kiểu bạn cần.</p>
<h1 id="parse-str-to-struct"><a class="header" href="#parse-str-to-struct">Parse <code>str</code> to <code>Struct</code></a></h1>
<p>Bạn có 1 struct và muốn parse 1 str thành struct đó, bạn sẽ cần impl trait <code>FromStr</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;
use std::num::ParseIntError;

#[derive(Debug, PartialEq)]
struct Point {
  x: i32,
  y: i32
}

impl FromStr for Point {
  type Err = ParseIntError;

  fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
    let coords: Vec&lt;&amp;str&gt; = s.trim_matches(|p| p == '(' || p == ')' )
                               .split(',')
                               .collect();

    let x_fromstr = coords[0].parse::&lt;i32&gt;()?;
    let y_fromstr = coords[1].parse::&lt;i32&gt;()?;

    Ok(Point { x: x_fromstr, y: y_fromstr })
  }
}

// Có nhiều cách
let p: Point = "(1,2)".parse();
let p = "(1,2)".parse::&lt;Point&gt;();
let p = Point::from_str("(1,2)");

assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )</code></pre></pre>
<h1 id="parse-str-to-enum"><a class="header" href="#parse-str-to-enum">Parse <code>str</code> to <code>Enum</code></a></h1>
<p>Một điều mình nhận thấy để code dễ đọc, dễ maintain hơn là
ta nên sử dụng Enum thay cho string để so sánh giá trị. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn print(color: &amp;str, text: &amp;str) { ... }
print("Foobar", "blue");</code></pre></pre>
<p>Thay vì đó mà hãy sử dụng enum:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Color { Red, Green, CornflowerBlue }

fn print(color: Color, text: &amp;str) { ... }
print(Green, "duyet");</code></pre></pre>
<p>Cũng nên hạn chế sử dụng quá nhiều Boolean, thực tế Boolean cũng chỉ là 1 enum</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum bool { true, false }</code></pre></pre>
<p>Thay vào đó hãy tự định nghĩa enum cho các ngữ cảnh khác nhau để code dễ đọc hơn:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum EnvVars { Clear, Inherit }
enum DisplayStyle { Color, Monochrome }</code></pre></pre>
<p>Chúng ta implement <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html">std::str::FromStr</a> trait như sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;

#[derive(Debug, PartialEq)]
enum Color {
  Red,
  Green,
  Blue
}

impl FromStr for Color {
  type Err = ();

  fn from_str(input: &amp;str) -&gt; Result&lt;Color, Self::Err&gt; {
    match input {
      "red"   =&gt; Ok(Color::Red),
      "green" =&gt; Ok(Color::Green),
      "blue"  =&gt; Ok(Color::Blue),
      _       =&gt; Err(()),
    }
  }
}

let c: Color = "red".parse().unwrap();
assert_eq!(c, Color::Red);</code></pre></pre>
<h1 id="references-3"><a class="header" href="#references-3">References</a></h1>
<ul>
<li><a href="basic/trait/../trait/README.html">Trait</a></li>
<li><a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.parse">https://doc.rust-lang.org/nightly/std/primitive.str.html#method.parse</a></li>
<li><a href="https://doc.rust-lang.org/nightly/std/str/trait.FromStr.html">https://doc.rust-lang.org/nightly/std/str/trait.FromStr.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Giống như các ngôn ngữ khác, Enum là một kiểu giá trị đơn, chứa các biến thể (variants).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}

let today = Day::Sunday;
<span class="boring">}</span></code></pre></pre>
<p>Enum variant có thể là</p>
<ul>
<li>unit variant</li>
<li>tuple variant</li>
<li>struct variant</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FlashMessage {
  Success, // unit variant
  Error(String), // tuple variant
  Warning { category: i32, message: String }, // struct variant
}
<span class="boring">}</span></code></pre></pre>
<h1 id="match-enum"><a class="header" href="#match-enum">match Enum</a></h1>
<p><code>match</code> cực kỳ mạnh và được dùng trong Rust phổ biến.</p>
<p>Ví dụ sau là cách để kiểm tra một giá trị enum là variant nào.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Coin::Penny =&gt; 1,
    Coin::Nickel =&gt; 5,
    Coin::Dime =&gt; 10,
    Coin::Quarter =&gt; 25,
  }
}

fn main() {}</code></pre></pre>
<p><code>match</code> còn có thể trích xuất các giá trị từ tuple variant hoặc struct variant.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FlashMessage {
  Success, // unit variant
  Error(String), // tuple variant
  Warning { category: i32, message: String }, // struct variant
}

fn format_message(message: FlashMessage) -&gt; String {
  match message {
    FlashMessage::Success =&gt; "success".to_string(),
    FlashMessage::Error(err) =&gt; format!("My error: {}", err),
    FlashMessage::Warning{ category, message } =&gt; format!("Warn: {} (category: {})", message, category),
  }
}

let m = format_message(FlashMessage::Error("something went wrong".to_string()));
println!("{m}");
<span class="boring">}</span></code></pre></pre>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-02-match.html">https://doc.rust-lang.org/book/ch06-02-match.html</a></li>
<li><a href="https://blog.logrocket.com/rust-enums-and-pattern-matching/">https://blog.logrocket.com/rust-enums-and-pattern-matching/</a></li>
</ul>
<h1 Variants="">use Enum::</h1>
<p>Ta có thể mang variants ra ngoài scope của enum bằng <code>use</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

// hoặc
// use self::Coin::{Penny, Nickel, Dime, Quarter};
use Coin::*;

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Penny =&gt; 1,
    Nickel =&gt; 5,
    Dime =&gt; 10,
    Quarter =&gt; 25,
  }
}

fn main() {
  assert_eq!(value_in_cents(Penny), 1);
  assert_eq!(value_in_cents(Coin::Penny), 1);
}</code></pre></pre>
<h1 id="impl-enum"><a class="header" href="#impl-enum">impl Enum</a></h1>
<p>Ta cũng có thể <code>impl</code> cho <code>enum</code> giống như <code>struct</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}

// impl enum
impl Day {
  fn today(self) -&gt; Self {
    self
  }
}

// Trait
trait DayOff {
  fn day_off(self);
}

// impl trait for enum
impl DayOff for Day {
  fn day_off(self) {
    match self.today() {
      Self::Sunday | Self::Saturday =&gt; println!("day off"),
      _ =&gt; println!("noooo"),
    }
  }
}

let today = Day::Sunday;
today.day_off();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-enum-1"><a class="header" href="#match-enum-1">match Enum</a></h1>
<p><code>match</code> cực kỳ mạnh và được dùng trong Rust phổ biến.</p>
<p>Ví dụ sau là cách để kiểm tra một giá trị enum là variant nào.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Coin::Penny =&gt; 1,
    Coin::Nickel =&gt; 5,
    Coin::Dime =&gt; 10,
    Coin::Quarter =&gt; 25,
  }
}

fn main() {}</code></pre></pre>
<p><code>match</code> còn có thể trích xuất các giá trị từ tuple variant hoặc struct variant.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FlashMessage {
  Success, // unit variant
  Error(String), // tuple variant
  Warning { category: i32, message: String }, // struct variant
}

fn format_message(message: FlashMessage) -&gt; String {
  match message {
    FlashMessage::Success =&gt; "success".to_string(),
    FlashMessage::Error(err) =&gt; format!("My error: {}", err),
    FlashMessage::Warning{ category, message } =&gt; format!("Warn: {} (category: {})", message, category),
  }
}

let m = format_message(FlashMessage::Error("something went wrong".to_string()));
println!("{m}");
<span class="boring">}</span></code></pre></pre>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-02-match.html">https://doc.rust-lang.org/book/ch06-02-match.html</a></li>
<li><a href="https://blog.logrocket.com/rust-enums-and-pattern-matching/">https://blog.logrocket.com/rust-enums-and-pattern-matching/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 Variants="">use Enum::</h1>
<p>Ta có thể mang variants ra ngoài scope của enum bằng <code>use</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

// hoặc
// use self::Coin::{Penny, Nickel, Dime, Quarter};
use Coin::*;

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Penny =&gt; 1,
    Nickel =&gt; 5,
    Dime =&gt; 10,
    Quarter =&gt; 25,
  }
}

fn main() {
  assert_eq!(value_in_cents(Penny), 1);
  assert_eq!(value_in_cents(Coin::Penny), 1);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-enum-1"><a class="header" href="#impl-enum-1">impl Enum</a></h1>
<p>Ta cũng có thể <code>impl</code> cho <code>enum</code> giống như <code>struct</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
}

// impl enum
impl Day {
  fn today(self) -&gt; Self {
    self
  }
}

// Trait
trait DayOff {
  fn day_off(self);
}

// impl trait for enum
impl DayOff for Day {
  fn day_off(self) {
    match self.today() {
      Self::Sunday | Self::Saturday =&gt; println!("day off"),
      _ =&gt; println!("noooo"),
    }
  }
}

let today = Day::Sunday;
today.day_off();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option"><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a></a></h1>
<p>Nhiều ngôn ngữ sử dụng kiểu dữ liệu <code>null</code> hoặc <code>nil</code> hoặc <code>undefined</code>
để đại diện cho các giá trị rỗng hoặc không tồn tại, và sử dụng <code>Exception</code>
để xử lý lỗi. Rust bỏ qua hai khái niệm này, để tránh gặp phải các lỗi phổ biến
như <strong>null pointer exceptions,</strong> hay <strong>lộ thông tin nhạy cảm thông qua exceptions,</strong> ...
Thay vào đó, Rust giới thiệu hai generic enums <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a>
và <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> để giải quyết các vấn đề trên.</p>
<hr />
<p>Trong hầu hết các ngôn ngữ họ C (C, C#, Java, ...), để xác định một cái gì đó failed
hay không tìm được giá trị thỏa mãn, chúng ta thường trả về một giá trị <em>"đặc biệt"</em> nào đó.
Ví dụ <code>indexOf()</code> của Javascript scan một phần tử trong mảng,
trả về vị trí của phần tử đó trong mảng. Và trả về <code>-1</code> nếu không tìm thấy.</p>
<p>Dẫn đến, ta sẽ thường thấy một số đoạn code như sau đây:</p>
<pre><code class="language-typescript">// Typescript

let sentence = "The fox jumps over the dog";
let index = sentence.indexOf("fox");

if (index &gt; -1) {
  let result = sentence.substr(index);
  console.log(result);
}
</code></pre>
<p>Như bạn thấy <code>-1</code> là một trường hợp đặc biệt cần xử lý.
Có khi nào bạn đã từng mắc lỗi ngớ ngẫn vì tưởng giá trị đặc biệt đó là <code>0</code> chưa?</p>
<pre><code class="language-typescript">// Typescript

if (index &gt; 0) {
  // 3000 days of debugging
}
</code></pre>
<p><code>""</code> hay <code>null</code> hay <code>None</code> cũng là một trong những trường hợp đặc biệt đó.
Bạn đã từng nghe đến <strong><strong><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a></strong></strong>?</p>
<p>Lý do cơ bản là không có gì chắc chắn và có thể ngăn bạn lại việc ... <strong>quên</strong>
xử lý mọi trường hợp giá trị đặc biệt, hoặc do chương trình trả về các giá trị đặc biệt không như mong đợi.
Có nghĩa là ta có thể <em>vô tình</em> làm crash chương trình với một lỗi nhỏ ở bất kỳ đâu, ở bất kỳ thời điểm nào.</p>
<p>Rust làm điều này tốt hơn, chỉ với <code>Option</code>.</p>
<p>Một giá trị optional có thể mang một giá trị nào đó <strong>Some(something)</strong> hoặc không mang giá trị nào cả (<strong>None</strong>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An output can have either Some value or no value/ None.
enum Option&lt;T&gt; { // T is a generic and it can contain any type of value.
  Some(T),
  None,
}
<span class="boring">}</span></code></pre></pre>
<p>Theo thiết kế, mặc định bạn sẽ không bao giờ lấy được giá trị bạn cần nếu không xử lý
các trường hợp có thể xảy ra với <code>Option</code>, là <code>None</code> chẳng hạn.
Điều này được bắt buộc bởi compiler lúc compile code,
có nghĩa là nếu bạn quên check, code sẽ không bao giờ được compile.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sentence = "The fox jumps over the dog";
let index = sentence.find("fox");

if let Some(fox) = index {
  let words_after_fox = &amp;sentence[fox..];
  println!("{}", words_after_fox);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cách-sử-dụng-option"><a class="header" href="#cách-sử-dụng-option"><strong>Cách sử dụng Option</strong></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> là standard library, do đã được
<a href="https://learning-rust.github.io/docs/d7.std_primitives_and_preludes.html#Preludes">preludes</a>
nên chúng ta không cần khai báo trước khi sử dụng. Ngoài enum
<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> thì các variant của nó cũng đã được preludes
sẵn như <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some">Some</a>
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None">None</a>.</p>
<p>Ví dụ, ta có một function tính giá trị chia hai số,
đôi khi sẽ không tìm ra được kết quả, ta sử dụng Some như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Option&lt;i32&gt; {
    if !name.starts_with('d') {
        return None;
    }

    Some(123)
}

fn main() {
    let name = "duyet";

    match get_id_from_name(name) {
        Some(id) =&gt; println!("User = {}", id),
        _ =&gt; println!("Not found"),
    }
}</code></pre></pre>
<p>Ta thường sử dụng <code>match</code> để bắt giá trị trả về (<code>Some</code> hoặc <code>None</code>).</p>
<p>Bạn sẽ bắt gặp rất nhiều method khác nhau để xử lý giá trị của <code>Option</code></p>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> method overview: <a href="https://doc.rust-lang.org/std/option/#method-overview">https://doc.rust-lang.org/std/option/#method-overview</a></p>
<h3 id="unwrap"><a class="header" href="#unwrap"><code>.unwrap()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some(T)</code>. Nếu giá trị là <code>None</code> thì panic chương trình.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some("air");
assert_eq!(x.unwrap(), "air");

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), "air"); // panic!
<span class="boring">}</span></code></pre></pre>
<h3 id="expect"><a class="header" href="#expect"><code>.expect()</code></a></h3>
<p>Giống <code>.unwrap()</code>, nhưng khi panic thì Rust sẽ kèm theo message</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;&amp;str&gt; = None;
x.expect("fruits are healthy"); // panics: `fruits are healthy`
<span class="boring">}</span></code></pre></pre>
<h3 id="unwrap_or"><a class="header" href="#unwrap_or"><code>.unwrap_or()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá trị nằm trong <code>or</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some("car").unwrap_or("bike"), "car");
<span class="boring">}</span></code></pre></pre>
<h3 id="unwrap_or_default"><a class="header" href="#unwrap_or_default"><code>.unwrap_or_default()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_year_from_input = "1909";
let bad_year_from_input = "190blarg";
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
<span class="boring">}</span></code></pre></pre>
<h3 id="ok_or"><a class="header" href="#ok_or"><code>.ok_or()</code></a></h3>
<p>Convert <code>Option&lt;T&gt;</code> sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>,
mapping <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some"><code>Some(v)</code></a>
thành <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok(v)</code></a>
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None"><code>None</code></a>
sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err(err)</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some("foo");
assert_eq!(x.ok_or(0), Ok("foo"));
<span class="boring">}</span></code></pre></pre>
<h3 id="match"><a class="header" href="#match"><code>match</code></a></h3>
<p>Chúng ta có thể sử dụng pattern matching để code dễ đọc hơn</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_name(who: Option&lt;String&gt;) -&gt; String {
  match who {
    Some(name) =&gt; format!("Hello {}", name),
    None       =&gt; "Who are you?".to_string(), 
  }
}

get_name(Some("duyet"));
<span class="boring">}</span></code></pre></pre>
<h3 id="if-let-somex--x"><a class="header" href="#if-let-somex--x">if let Some(x) = x</a></h3>
<p>Có thể bạn sẽ gặp pattern này nhiều khi đọc code Rust.
Nếu giá trị của <code>x</code> là <code>Some</code> thì sẽ destruct
giá trị đó bỏ vào biến <code>x</code> nằm trong scope của <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; Option&lt;String&gt; {
    Some("ok".to_string())
}

if let Some(data) = get_data() {
    println!("data = {}", data);
} else {
    println!("no data");
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unwrap-1"><a class="header" href="#unwrap-1"><code>.unwrap()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some(T)</code>. Nếu giá trị là <code>None</code> thì panic chương trình.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some("air");
assert_eq!(x.unwrap(), "air");

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), "air"); // panic!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="expect-1"><a class="header" href="#expect-1"><code>.expect()</code></a></h3>
<p>Giống <code>.unwrap()</code>, nhưng khi panic thì Rust sẽ kèm theo message</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;&amp;str&gt; = None;
x.expect("fruits are healthy"); // panics: `fruits are healthy`
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="unwrap_or_default-1"><a class="header" href="#unwrap_or_default-1"><code>.unwrap_or_default()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_year_from_input = "1909";
let bad_year_from_input = "190blarg";
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="if-let-somex--x-1"><a class="header" href="#if-let-somex--x-1">if let Some(x) = x</a></h3>
<p>Có thể bạn sẽ gặp pattern này nhiều khi đọc code Rust.
Nếu giá trị của <code>x</code> là <code>Some</code> thì sẽ destruct
giá trị đó bỏ vào biến <code>x</code> nằm trong scope của <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; Option&lt;String&gt; {
    Some("ok".to_string())
}

if let Some(data) = get_data() {
    println!("data = {}", data);
} else {
    println!("no data");
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result"><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a></a></h1>
<p>Tương tự như <code>Option</code>.
Một kết quả trả về (<a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a>)
của một function thường sẽ có hai trường hợp:</p>
<ul>
<li>thành công (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>) và trả về kết quả</li>
<li>hoặc lỗi (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>) và trả về thông tin lỗi.</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a> là một phiên bản cao cấp hơn của <code>Option</code>.
Nó mô tả <em>lỗi gì</em> đang xảy ra thay vì khả năng <em>tồn tại</em> giá trị hay không.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Ví dụ</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; {
    if !name.starts_with('d') {
        return Err("not found");
    }

    Ok(123)
}

fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    let name = "duyet";

    match get_id_from_name(name) {
        Ok(id) =&gt; println!("User = {}", id),
        Err(e) =&gt; println!("Error: {}", e),
    };

    Ok(())
}</code></pre></pre>
<p>Như bạn thấy thì <code>main()</code> cũng có thể return về <code>Result&lt;(), &amp;'static str&gt;</code></p>
<h3 id="unwrap-2"><a class="header" href="#unwrap-2"><code>.unwrap()</code></a></h3>
<p>Ví dụ trên nhưng sử dụng <code>.unwrap()</code> , chủ động panic (crash) dừng chương trình nếu gặp lỗi.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = "duyet";
  let age = get_age(who).unwrap();
  println!("{} is {}", who, age);

  Ok(())
}</code></pre></pre>
<h3 id="expect-2"><a class="header" href="#expect-2"><code>.expect()</code></a></h3>
<p>Giống như <code>unwrap()</code>: chủ động panic (crash) dừng chương trình nếu gặp lỗi và kèm theo message. Sẽ rất có ích, nhất là khi có quá nhiều unwrap, bạn sẽ không biết nó panic ở đâu.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = "ngan";
  let age = get_age(who).expect("could not get age");
  println!("{} is {}", who, age);

  Ok(())
}</code></pre></pre>
<p>Xem thêm mọi method khác của <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> <a href="https://doc.rust-lang.org/std/result/enum.Result.html">tại đây</a>.</p>
<h1 id="convert-result---option"><a class="header" href="#convert-result---option">Convert <code>Result</code> -&gt; <code>Option</code></a></h1>
<p>Đôi khi bạn sẽ cần convert từ:</p>
<ul>
<li><code>Ok(v)</code> --&gt; <code>Some(v)</code></li>
<li>hoặc ngược lại, <code>Err(e)</code> --&gt; <code>Some(e)</code></li>
</ul>
<h2 id="ok"><a class="header" href="#ok"><code>.ok()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .ok(v) = Some(v)
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.ok(), Some(2));

let y: Result&lt;u32, &amp;str&gt; = Err("Nothing here");
assert_eq!(y.ok(), None);</code></pre></pre>
<h2 id="err"><a class="header" href="#err"><code>.err()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .err()
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.err(), None);

let x: Result&lt;u32, &amp;str&gt; = Err("Nothing here");
assert_eq!(x.err(), Some("Nothing here"));</code></pre></pre>
<h1 id="toán-tử-"><a class="header" href="#toán-tử-">Toán tử <code>?</code></a></h1>
<p>Khi viết code mà có quá nhiều functions trả về <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, việc handle <code>Err</code> sẽ khá nhàm chán.
Toán tử chấm hỏi <a href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>?</code></a> cho phép dừng function tại vị trí đó và return cho function cha nếu <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ở vị trí đó là <code>Err</code>.</p>
<p>Nó sẽ thay thế đoạn code sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  // Early return on error
  let mut file = match File::create("my_best_friends.txt") {
    Err(e) =&gt; return Err(e),
    Ok(f) =&gt; f,
  };
  if let Err(e) = file.write_all(format!("name: {}\n", info.name).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!("age: {}\n", info.age).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!("rating: {}\n", info.rating).as_bytes()) {
    return Err(e)
  }
  Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>thành</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  let mut file = File::create("my_best_friends.txt")?;
  // Early return on error
  file.write_all(format!("name: {}\n", info.name).as_bytes())?;
  file.write_all(format!("age: {}\n", info.age).as_bytes())?;
  file.write_all(format!("rating: {}\n", info.rating).as_bytes())?;
  Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Gọn đẹp hơn rất nhiều.</p>
<p>Toán tử <code>?</code> sẽ unwrap giá trị <code>Ok</code>, hoặc return giá trị <code>Err</code> ở vị trí gần toán tử đó.</p>
<p><code>?</code> chỉ có thể được dùng trong function có kiểu dữ liệu trả về là <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convert-result---option-1"><a class="header" href="#convert-result---option-1">Convert <code>Result</code> -&gt; <code>Option</code></a></h1>
<p>Đôi khi bạn sẽ cần convert từ:</p>
<ul>
<li><code>Ok(v)</code> --&gt; <code>Some(v)</code></li>
<li>hoặc ngược lại, <code>Err(e)</code> --&gt; <code>Some(e)</code></li>
</ul>
<h2 id="ok-1"><a class="header" href="#ok-1"><code>.ok()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .ok(v) = Some(v)
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.ok(), Some(2));

let y: Result&lt;u32, &amp;str&gt; = Err("Nothing here");
assert_eq!(y.ok(), None);</code></pre></pre>
<h2 id="err-1"><a class="header" href="#err-1"><code>.err()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .err()
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.err(), None);

let x: Result&lt;u32, &amp;str&gt; = Err("Nothing here");
assert_eq!(x.err(), Some("Nothing here"));</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toán-tử--1"><a class="header" href="#toán-tử--1">Toán tử <code>?</code></a></h1>
<p>Khi viết code mà có quá nhiều functions trả về <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, việc handle <code>Err</code> sẽ khá nhàm chán.
Toán tử chấm hỏi <a href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>?</code></a> cho phép dừng function tại vị trí đó và return cho function cha nếu <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ở vị trí đó là <code>Err</code>.</p>
<p>Nó sẽ thay thế đoạn code sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  // Early return on error
  let mut file = match File::create("my_best_friends.txt") {
    Err(e) =&gt; return Err(e),
    Ok(f) =&gt; f,
  };
  if let Err(e) = file.write_all(format!("name: {}\n", info.name).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!("age: {}\n", info.age).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!("rating: {}\n", info.rating).as_bytes()) {
    return Err(e)
  }
  Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>thành</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  let mut file = File::create("my_best_friends.txt")?;
  // Early return on error
  file.write_all(format!("name: {}\n", info.name).as_bytes())?;
  file.write_all(format!("age: {}\n", info.age).as_bytes())?;
  file.write_all(format!("rating: {}\n", info.rating).as_bytes())?;
  Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Gọn đẹp hơn rất nhiều.</p>
<p>Toán tử <code>?</code> sẽ unwrap giá trị <code>Ok</code>, hoặc return giá trị <code>Err</code> ở vị trí gần toán tử đó.</p>
<p><code>?</code> chỉ có thể được dùng trong function có kiểu dữ liệu trả về là <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>Generics là một khái niệm để tổng quát hóa các kiểu dữ liệu
hoặc tính năng cho các trường hợp rộng hơn. Tổng quát hóa cực kỳ hữu ích
trong việc giảm số lượng code duplication. Một trong những ví dụ phổ
biến nhất của tổng quát hóa là tổng quát một function có thể input nhiều loại
kiểu dữ liệu khác nhau (type parameters).</p>
<p>Generic type parameters thường được biểu diễn dưới dạng <code>&lt;T&gt;</code>.</p>
<p>Ví dụ, định nghĩa một <em>generic function</em> <code>foo</code> nhận một tham số <code>T</code> của mọi kiểu dữ liệu.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(arg: T) { ... }
<span class="boring">}</span></code></pre></pre>
<p>Xem các trang sau để biết chi tiết về generic type
được ứng dụng trong các trường hợp khác nhau như thế nào.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h1>
<p>Định nghĩa một generic function bằng cách khai báo generic type <code>&lt;T&gt;</code> sau tên của function.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {} // x có kiểu T, T là generic type

fn bar&lt;T&gt;(x: T, y: T) {} // x và y đều có kiểu T

fn baz&lt;T, U&gt;(x: T, y: U) {} // sử dụng nhiều generic type
<span class="boring">}</span></code></pre></pre>
<p>Gọi một generic function đôi khi yêu cầu chỉ định kiểu dữ liệu tường minh cho tham số đó.
Đôi khi là do function được gọi trả về kiểu dữ liệu là generic, hoặc compiler không có
đủ thông tin. Thực thi một function và chỉ định kiểu dữ liệu tường minh có cú pháp như sau:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>function_name::&lt;A, B&gt;()
<span class="boring">}</span></code></pre></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn print_me&lt;T: ToString&gt;(content: T) {
    println!("{}", content.to_string());
}

fn main() {
    print_me::&lt;i32&gt;(100);
    print_me::&lt;u64&gt;(1_000_000);
}</code></pre></pre>
<p>Cú pháp <code>&lt;T: ToString&gt;</code> có nghĩa là: function <code>print_me</code> chấp nhận mọi tham số có
kiểu <code>T</code>, miễn sau <code>T</code> được implement trait
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html">ToString</a>.</p>
<p>Một ví dụ khác phức tạp hơn từ <a href="https://doc.rust-lang.org/rust-by-example/generics/gen_fn.html">Rust By Example</a></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct A;          // Type tường minh `A`.
struct S(A);       // Type tường minh `S`.
struct SGen&lt;T&gt;(T); // Type Generic `SGen`.

// Các function sau sẽ take ownership của variable
// sau đó thoát ra khỏi scope {}, sau đó giải phóng variable.

// Định nghĩa function `reg_fn` nhận tham số `_s` có kiểu `S`.
// Không có `&lt;T&gt;` vì vậy đây không phải là một generic function.
fn reg_fn(_s: S) {}

// Định nghĩa function `gen_spec_t` nhận tham số `_s` có kiểu `SGen&lt;T&gt;`.
// Ở đây tường minh kiểu `A` cho `S`, và bởi vì `A` không được khai báo 
// như là một generic type parameter cho `gen_spec_t`, 
// nên đây cũng không phải là một generic function.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Định nghĩa function `gen_spec_i32` nhận tham số `_s` có kiểu `SGen&lt;i32&gt;`.
// Giống như ở trên, ta khai báo tường minh `i32` cho `T`.
// Bởi vì `i32` không phải là một a generic type, nên function này cũng không
// phải là một genenic function.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Định nghĩa một `generic` function, nhận tham số `_s` có kiểu `SGen&lt;T&gt;`.
// Bởi vì `SGen&lt;T&gt;` được đứng trước bởi `&lt;T&gt;`, nên function này generic bởi `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Gọi non-generic functions
    reg_fn(S(A));          // Concrete type.
    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.

    // Chỉ định cụ thể parameter `char` cho `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Chỉ định cụ thể `char` to `generic()`.
    generic(SGen('c'));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-struct"><a class="header" href="#generic-struct">Generic Struct</a></h1>
<p>Giống như function, ta cũng có thể sử dụng generic type cho
Struct</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point&lt;T&gt; {
  x: T,
  y: T,
}

fn main() {
  let point_a = Point { x: 0, y: 0 }; // T is a int type
  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-enum"><a class="header" href="#generic-enum">Generic Enum</a></h1>
<p><a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a> và <a href="https://doc.rust-lang.org/std/result/index.html"><code>Result</code></a> là 2 ví dụ của generic struct.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="sử-dụng-optiont"><a class="header" href="#sử-dụng-optiont">Sử dụng <a href="https://doc.rust-lang.org/std/option/index.html"><code>Option&lt;T&gt;</code></a>:</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Option&lt;i32&gt; {
    if !name.starts_with('d') {
        return None;
    }

    Some(123)
}

fn main() {
    let name = "duyet";

    match get_id_from_name(name) {
        Some(id) =&gt; println!("User = {}", id),
        _ =&gt; println!("Not found"),
    }
}</code></pre></pre>
<p>Xem thêm: <a href="basic/generics/../enum/option"><em>Enum &gt; Option<T></em></a></p>
<h4 id="sử-dụng-resultt-e"><a class="header" href="#sử-dụng-resultt-e">Sử dụng <a href="https://doc.rust-lang.org/std/result/index.html"><code>Result&lt;T, E&gt;</code></a>:</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; {
    if !name.starts_with('d') {
        return Err("not found");
    }

    Ok(123)
}

fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    let name = "duyet";

    match get_id_from_name(name) {
        Ok(id) =&gt; println!("User = {}", id),
        Err(e) =&gt; println!("Error: {}", e),
    };

    Ok(())
}</code></pre></pre>
<p>Xem tưhêm: <a href="basic/generics/../enum/result"><em>Enum &gt; Result&lt;T, E&gt;</em></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-implementation"><a class="header" href="#generic-implementation">Generic Implementation</a></h1>
<p>Ta cũng có thể sử dụng generic type cho implementation.</p>
<p>Khai báo generic type sau từ khóa <code>impl</code>: <code>impl&lt;T, U&gt; ...</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct S; // Kiểu tường minh `S`
struct GenericVal&lt;T&gt;(T); // Generic type `GenericVal`

// impl cho GenericVal, chúng ta có thể chỉ định cụ thể kiểu dữ liệu cho type parameters:
impl GenericVal&lt;f32&gt; {} // `f32`
impl GenericVal&lt;S&gt; {} // `S` được định nghĩa ở trên

// cần khai báo `&lt;T&gt;` để duy trì tính tổng quát
impl&lt;T&gt; GenericVal&lt;T&gt; {}

fn main() {}</code></pre></pre>
<p>Một ví dụ khác</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct GenVal&lt;T&gt; {
    gen_val: T,
}

// impl of GenVal for a generic type `T`
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = GenVal { gen_val: 3i32 };
    let y = GenVal::&lt;u32&gt; { gen_val: 6 };

    println!("{}, {}", x.value(), y.value());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-trait"><a class="header" href="#generic-trait">Generic Trait</a></h1>
<p>Trait cũng có thể được tổng quát hóa.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail edition2021">// Non-copyable types.
struct Empty;
struct Null;

// A trait generic over `T`.
trait DoubleDrop&lt;T&gt; {
    // Định nghĩa một method trên type hiện tại, method nhận
    // một giá trị khác cũng có kiểu `T` và không làm gì với nó.
    fn double_drop(self, _: T);
}

// Implement `DoubleDrop&lt;T&gt;` cho mọi generic parameter `T` và
// caller `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // Method này take ownership của cả 2 arguments,
    // sau đó giải phóng bộ nhớ cho cả 2, do ra khỏi scope {}
    // mà không làm gì cả.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    empty.double_drop(null);

    // TODO: uncomment
    // empty;
    // null;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounds"><a class="header" href="#bounds">Bounds</a></h1>
<p>Cái này rất khó giải thích bằng tiếng Việt bằng một từ đơn giản.
Khi sử dụng genenic, type parameter thường phải sử dụng các trait
như các ràng buộc, giới hạn (bounds) để quy định chức năng (functionality) của kiểu
đang được implement.</p>
<p>Trong ví dụ sau sử dụng trait <code>Display</code> để in, vì thế ta cần <code>T</code> bị ràng buộc (bound)
bởi <code>Display</code>. Có nghĩa là, ta cần tham số có kiểu <code>T</code>
và <code>T</code> <em>bắt buộc</em> phải đã được implement <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">use std::fmt::Display;
</span>fn printer&lt;T: Display&gt;(t: T) {
    println!("{}", t);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Bounding giới hạn lại generic type.</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>// T phải được impl `Display`
struct S&lt;T: Display&gt;(T);

// error[E0277]: `Vec&lt;{integer}&gt;` doesn't implement `std::fmt::Display`
let s = S(vec![1]);
<span class="boring">}</span></code></pre></pre>
<h2 id="t-display--debug"><a class="header" href="#t-display--debug"><code>T: Display + Debug</code></a></h2>
<p>Để bounding nhiều trait, ta sử dụng <code>+</code>.
Ví dụ sau có nghĩa <code>T</code> phải được implement trait <code>Display</code> và <code>Debug</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use core::fmt::Debug;
</span>fn printer&lt;T: Display + Debug&gt;(t: T) {
    println!("{:?}", t);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mệnh-đề-where"><a class="header" href="#mệnh-đề-where">Mệnh đề <code>where</code></a></h1>
<p>Mệnh đề <code>where</code> được sử dụng để làm rõ ràng hơn trong việc định nghĩa các generic types và bounds.
Nó cho phép chúng ta chỉ định các bound một cách tường minh ngay trước hàm, giúp cho mã nguồn trở nên dễ đọc và hiểu hơn.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span><span class="boring">use core::fmt::Debug;
</span>fn printer&lt;T&gt;(t: T) 
where
    T: Display + Debug
{
    println!("{:?}", t);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>Vector có để được xem là re-sizable array nhưng mọi phần tử trong vec phải có cùng kiểu dữ liệu.</p>
<p>Vector là một generic type: <code>Vec&lt;T&gt;</code>, <code>T</code> có thể là bất kỳ kiểu dữ liệu nào. Ví dụ một vector chứa <code>i32</code> được viết là <code>Vec&lt;i32&gt;</code>.</p>
<h2 id="tạo-vector"><a class="header" href="#tạo-vector">Tạo vector</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a1: Vec&lt;i32&gt; = Vec::new();
let a2: Vec&lt;i32&gt; = vec![];

// Khai báo kiểu cho phần tử đầu tiên
let b2 = vec![1i32, 2, 3];

// Vec chứa mười số 0
let b3 = vec![0; 10];
<span class="boring">}</span></code></pre></pre>
<h2 id="in-vector"><a class="header" href="#in-vector">In vector</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = vec![5, 4, 3, 2, 1];
println!("vec = {:?}", c);
<span class="boring">}</span></code></pre></pre>
<h2 id="push-và-pop"><a class="header" href="#push-và-pop">Push và Pop</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut d: Vec&lt;i32&gt; = vec![];
d.push(1);
d.push(2);
d.pop();
<span class="boring">}</span></code></pre></pre>
<h2 id="kiểm-tra-kích-thước-của-vector"><a class="header" href="#kiểm-tra-kích-thước-của-vector">Kiểm tra kích thước của vector</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let d = vec![0; 10];

println!("len = {}", d.len());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>Iterator pattern cho phép bạn thực hiện một số tác vụ trên từng phần tử một cách tuần tự.
Một iterator chịu trách nhiệm về logic của việc lặp qua từng phần tử và xác định khi nào chuỗi đã kết thúc.
Khi bạn sử dụng iterators, bạn không cần phải tái hiện lại logic đó một lần nữa.</p>
<p>Trong Rust, iterators là <em>lazy</em>, nghĩa là chúng không có tác dụng gì cho đến khi bạn gọi các phương thức consume iterator (e.g. <code>sum</code>, <code>count</code>, ...).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];
let v1_iter = v1.iter(); // lazy

for val in v1_iter {
    println!("Got: {val}");
}
// Got: 1
// Got: 2
// Got: 3
<span class="boring">}</span></code></pre></pre>
<h2 id="the-iterator-trait-and-the-next-method"><a class="header" href="#the-iterator-trait-and-the-next-method">The <code>Iterator</code> Trait and the <code>next</code> Method</a></h2>
<p>Tất cả iterators được implement một trait tên là <code>Iterator</code> được định nghĩa trong standard library. Định nghĩa của trait trông như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<h2 id="consume-the-iterator"><a class="header" href="#consume-the-iterator">Consume the Iterator</a></h2>
<p>Phương thức gọi <code>next</code> được gọi là <em>consuming adaptors</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];
let v1_iter = v1.iter(); // lazy

let total: i32 = v1_iter.sum(); // Consume
println!("Total: {}", &amp;total);  // Total: 6
<span class="boring">}</span></code></pre></pre>
<p><code>v1_iter</code> không thể sử dụng bởi vì <code>sum</code> đã takes ownership của iterator.</p>
<h2 id="produce-other-iterators"><a class="header" href="#produce-other-iterators">Produce Other Iterators</a></h2>
<p><em>Iterator adaptors</em> là các phương thức được định nghĩa trên trait <code>Iterator</code> không consume iterator.
Thay vào đó, chúng produce ra các iterator khác bằng cách thay đổi một ít từ iterator gốc.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1); // new iter
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

println!("{:?}", v2); // [2, 3, 4]
<span class="boring">}</span></code></pre></pre>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Processing a Series of Items with Iterators</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-code-comment-sao-cho-đúng"><a class="header" href="#-code-comment-sao-cho-đúng"><code>/// code comment</code> sao cho đúng</a></h1>
<p>Comment sao cho đúng để đồng đội bớt chửi.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}</span></code></pre></pre>
<h2 id="regular-comments"><a class="header" href="#regular-comments">Regular comments</a></h2>
<p>Trong Rust comment bắt đầu bằng 2 slashes <code>//</code> được gọi là <em>Regular comments</em>,
chú thích cho một đoạn code hoặc biểu thức theo sau nó.
Compiler sẽ không quan tâm đến các Regular comments này.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  // I’m feeling lucky today
  let lucky_number = 7;
}</code></pre></pre>
<p>Nếu comment có nhiều hơn một dòng,
hãy ngắt nó thành nhiều dòng -.-</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
<span class="boring">}</span></code></pre></pre>
<p>Comment cũng có thể được đặt cuối dòng code, nếu nó ngắn gọn và đơn giản:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let lucky_number = 7; // I’m feeling lucky today
}</code></pre></pre>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h2>
<p>Doc comments sẽ được Compiler parse thành <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">HTML documentation</a>
khi render document bằng <code>cargo doc</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Generate library docs for the following item.
//! Generate library docs for the enclosing item.
<span class="boring">}</span></code></pre></pre>
<p>Doc comments sẽ cực kỳ hữu ích cho project lớn và cần một hệ thống document chính xác và up to date.</p>
<p><code>//!</code> sẽ generate doc cho crate/mod trong file hiện tại.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![crate_name = "playground"]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new("name");
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says "Hello, [name]" to the `Person` it is called on.
    pub fn hello(&amp;self) {
        println!("Hello, {}!", self.name);
    }
}

fn main() {
    let john = Person::new("John");

    john.hello();
}</code></pre></pre>
<p>Chúng ta có thể thậm chí comment lại example code hoặc cách sử dụng một function nào đó,
code này cũng sẽ được compile và test, đảm bảo được code và document
luôn luôn chính xác với nhau, một giải pháp khá thông minh.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="regular-comments-1"><a class="header" href="#regular-comments-1">Regular comments</a></h2>
<p>Trong Rust comment bắt đầu bằng 2 slashes <code>//</code> được gọi là <em>Regular comments</em>,
chú thích cho một đoạn code hoặc biểu thức theo sau nó.
Compiler sẽ không quan tâm đến các Regular comments này.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  // I’m feeling lucky today
  let lucky_number = 7;
}</code></pre></pre>
<p>Nếu comment có nhiều hơn một dòng,
hãy ngắt nó thành nhiều dòng -.-</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
<span class="boring">}</span></code></pre></pre>
<p>Comment cũng có thể được đặt cuối dòng code, nếu nó ngắn gọn và đơn giản:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  let lucky_number = 7; // I’m feeling lucky today
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-comments-1"><a class="header" href="#doc-comments-1">Doc comments</a></h2>
<p>Doc comments sẽ được Compiler parse thành <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html">HTML documentation</a>
khi render document bằng <code>cargo doc</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Generate library docs for the following item.
//! Generate library docs for the enclosing item.
<span class="boring">}</span></code></pre></pre>
<p>Doc comments sẽ cực kỳ hữu ích cho project lớn và cần một hệ thống document chính xác và up to date.</p>
<p><code>//!</code> sẽ generate doc cho crate/mod trong file hiện tại.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![crate_name = "playground"]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new("name");
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says "Hello, [name]" to the `Person` it is called on.
    pub fn hello(&amp;self) {
        println!("Hello, {}!", self.name);
    }
}

fn main() {
    let john = Person::new("John");

    john.hello();
}</code></pre></pre>
<p>Chúng ta có thể thậm chí comment lại example code hoặc cách sử dụng một function nào đó,
code này cũng sẽ được compile và test, đảm bảo được code và document
luôn luôn chính xác với nhau, một giải pháp khá thông minh.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turbofish-"><a class="header" href="#turbofish-">Turbofish ::&lt;&gt;</a></h1>
<p><img src="https://blog.duyet.net/static/a4e75d7d370caf2b035a94ab66138e47/3fe5e/rust-turbofish.webp" alt="Rust Turbofish" /></p>
<p>Trong trường hợp bạn cần chỉ định kiểu dữ liệu cho một generic function, method, struct, hoặc enum,
Rust có một cú pháp đặc biệt để làm điều này gọi là turbofish. Quy tắc là khi nào bạn thấy</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">$ident&lt;T&gt;</code></pre></pre>
<p>trong bất kỳ định nghĩa nào, thì bạn có thể sử dụng nó dưới dạng</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">$ident::&lt;T&gt;</code></pre></pre>
<p>để chỉ định kiểu dữ liệu cho generic parameter. Sau đây là một số ví dụ để làm rõ hơn.</p>
<h2 id="generic-function"><a class="header" href="#generic-function">Generic Function</a></h2>
<p>Ví dụ function <code>std::mem::size_of()</code> có definition như sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub fn size_of&lt;T&gt;() -&gt; usize</code></pre></pre>
<p>Khi gọi <code>size_of</code> với turbofish:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">std::mem::size_of::&lt;u32&gt;()
// 4</code></pre></pre>
<p>sẽ cho ta biết size của u32 theo số bytes.</p>
<h2 id="generic-method"><a class="header" href="#generic-method">Generic Method</a></h2>
<p>Phương thức <code>parse()</code> của <code>str</code> bạn cũng sẽ hay gặp cách sử dụng với cú pháp turbofish:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt; where F: FromStr</code></pre></pre>
<p>Chúng ta có thể sử dụng turbofish để mô tả kiểu dữ liệu sẽ được parsed từ <code>str</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">"1234".parse::&lt;u32&gt;()</code></pre></pre>
<p>Một ví dụ phổ biến nữa là <code>collect()</code> của <code>Iterator</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator&lt;Self::Item&gt; </code></pre></pre>
<p>Bởi vì compiler đã biết kiểu dữ liệu của <code>Self::Item</code> mà ta đang collect rồi,
chúng ta thường không cần ghi ra. Thay vào đó là sử dụng <code>_</code> để compiler tự động infer ra. Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">let a = vec![1u8, 2, 3, 4];

a.iter().collect::&lt;Vec&lt;_&gt;&gt;();</code></pre></pre>
<p>Sẵn tiện nói về <code>Iterator</code> chúng ta cũng có thể sử dụng turbofish syntax với <code>sum()</code> và <code>product()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn sum&lt;S&gt;(self) -&gt; S where S: Sum&lt;Self::Item&gt;
fn product&lt;P&gt;(self) -&gt; P where P: Product&lt;Self::Item&gt;</code></pre></pre>
<p>Cú pháp như sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">[1, 2, 3, 4].iter().sum::&lt;u32&gt;()
[1, 2, 3, 4].iter().product::&lt;u32&gt;()</code></pre></pre>
<h2 id="generic-struct-1"><a class="header" href="#generic-struct-1">Generic Struct</a></h2>
<p>Trong trường hợp compiler không có đủ thông tin để infer khi tạo generic struct,
chúng ta cũng có thể sử dụng turbofish syntax. Ví dụ struct <code>Vec</code> có định nghĩa như sau</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub struct Vec&lt;T&gt; { /* fields omitted */ }</code></pre></pre>
<p>Ví dụ để khởi tạo <code>Vec</code> mới với <code>Vec::new()</code> ta có thể viết</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">Vec::&lt;u8&gt;::new()</code></pre></pre>
<p>Nhớ là ta bỏ turbofish sau <code>Vec::</code> không phải sau method <code>new</code>
bởi vì struct sử dụng generic type chứ không phải method <code>new</code>.
Hơi bựa nhưng nó vẫn thỏa quy tắc của turbofish. Một ví dụ khác</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">std::collections::HashSet::&lt;u8&gt;::with_capacity(10) </code></pre></pre>
<p>Ta đang tạo một <code>Hashset</code> với 10 phần tử, bởi vì <code>Hashset</code> struct có định nghĩa như sau</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub struct HashSet&lt;T, S = RandomState&gt; { /* fields omitted */ } </code></pre></pre>
<p>Chúng ta có thể sử dụng cú pháp này với mọi Rust collections.</p>
<h2 id="generic-enum-1"><a class="header" href="#generic-enum-1">Generic Enum</a></h2>
<p>Tuy nhiên Enum lại không theo quy tắc trên, bởi vì enum trong Rust không được
scoped tại enum name, do đó ta đặt turbofish sau enum variant.
Ví dụ hãy xem enum <code>Result</code> được dùng rất nhiều trong Rust</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[must_use]
pub enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}</code></pre></pre>
<p>Chúng ta sử dụng như thế này:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">Result::Ok::&lt;u8, ()&gt;(10)
Result::Err::&lt;u8, ()&gt;(())</code></pre></pre>
<p>Và bởi vì <code>Result</code> thường được prelude (import sẵn)
trong Rust, thực tế mọi người sẽ viết như thế này:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">Ok::&lt;u8, ()&gt;(10)
Err::&lt;u8, ()&gt;(()) </code></pre></pre>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-00-generics.html#generic-types-traits-and-lifetimes">Generic Types, Traits, and Lifetimes</a></li>
<li><a href="https://doc.rust-lang.org/book/generics.html">Generics in the rust book</a></li>
<li><a href="https://doc.rust-lang.org/book/syntax-index.html">Rust syntax index</a></li>
<li><a href="https://matematikaadit.github.io/posts/rust-turbofish.html">https://matematikaadit.github.io/posts/rust-turbofish.html</a></li>
<li><a href="https://techblog.tonsser.com/posts/what-is-rusts-turbofish">https://techblog.tonsser.com/posts/what-is-rusts-turbofish</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros"><code>macros!</code></a></h1>
<p>Mới bắt đầu với Rust chúng ta thường sử dụng rất nhiều macro như <code>println!</code>.</p>
<p>Thực chất có 3 loại macro trong Rust.</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the derive attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<h3 id="nội-dung"><a class="header" href="#nội-dung">Nội dung:</a></h3>
<ul>
<li><a href="basic/macro/./macros-vs-functions.html">Khác nhau giữa Macros và Functions</a></li>
<li><a href="basic/macro/./standard-macros.html">Standard Macros</a></li>
<li><a href="basic/macro/./println.html"><code>println!</code></a></li>
<li><a href="basic/macro/./format.html"><code>format!</code></a></li>
<li><a href="basic/macro/./todo.html"><code>todo!</code></a></li>
<li><a href="basic/macro/./macro_rules.html"><code>macro_rules!</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="khác-nhau-giữa-macros-và-functions"><a class="header" href="#khác-nhau-giữa-macros-và-functions">Khác nhau giữa Macros và Functions</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">// Macros

macro_rules! print_message {
    (msg: $msg:expr) =&gt; {
        println!("Message: {}", $msg);
    };
}

fn main() {
    print_message!(msg: "Hello, world!");
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">/// Functions
fn print_message(msg: &amp;str) {
    println!("Message: {}", msg);
}

fn main() {
    print_message("Hello, world!");
}</code></pre></pre>
<h2 id="Điểm-khác-biệt-trong-thời-điểm-biên-dịch"><a class="header" href="#Điểm-khác-biệt-trong-thời-điểm-biên-dịch">Điểm khác biệt trong thời điểm biên dịch</a></h2>
<ul>
<li>Functions được thực thi trong quá trình thực thi của chương trình, còn Macros được đánh giá và mở rộng trong quá trình biên dịch.</li>
<li>Functions chỉ có thể được gọi khi chương trình đang chạy, trong khi Macros có thể được gọi bất kỳ lúc nào trong quá trình biên dịch.</li>
</ul>
<h2 id="ast-abstract-syntax-tree"><a class="header" href="#ast-abstract-syntax-tree">AST (Abstract Syntax Tree)</a></h2>
<ul>
<li>Macros có thể truy cập vào AST của code được viết, cho phép thay đổi code theo cách động.</li>
<li>Functions không có quyền truy cập vào AST của code được viết.</li>
</ul>
<h2 id="input--output"><a class="header" href="#input--output">Input / Output</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>Rust Macros</strong></th><th><strong>Rust Functions</strong></th></tr></thead><tbody>
<tr><td>Input</td><td>Token stream</td><td>Tham số và đối số của hàm</td></tr>
<tr><td>Output</td><td>Đoạn mã Rust được mở rộng</td><td>Giá trị hoặc hiệu ứng sẽ được trả về</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! math {
    ($x:expr + $y:expr) =&gt; { $x * $y };
}

fn main() {
    let result = math!(4 + 5);
    println!("4 * 5 = {}", result);
}</code></pre></pre>
<p>Khi biên dịch, macro <code>math!</code> sẽ được mở rộng và tạo ra đoạn mã <code>4 * 5</code> được tính toán thành <code>20</code>.
Tham số của macro lúc này là <code>$x:expr + $y:expr</code> là <a href="https://doc.rust-lang.org/reference/macros-by-example.html">token stream</a>, cho phép khả năng mở rộng cú pháp không giới hạn.</p>
<h2 id="sử-dụng-và-ứng-dụng"><a class="header" href="#sử-dụng-và-ứng-dụng">Sử dụng và ứng dụng</a></h2>
<ul>
<li>Functions được sử dụng để đóng gói một khối lệnh nhất định, giúp tái sử dụng và quản lý code dễ dàng hơn.</li>
<li>Macros được sử dụng để thay đổi code tại thời điểm biên dịch, giúp viết code ngắn gọn và hiệu quả hơn.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-macros"><a class="header" href="#standard-macros">Standard Macros</a></h1>
<p>Standard Macros được định nghĩa bởi compiler và <a href="https://doc.rust-lang.org/std">std</a>.</p>
<pre><code>print!, println!, eprint!, eprintln!
format!, format_args!
write!, writeln!

concat!, concat_idents!, stringify // concat_idents: nightly-only experimental API

include!, include_bytes!, include_str!

assert!, assert_eq!, assert_ne!
debug_assert!, debug_assert_eq!, debug_assert_ne!

try!, panic!, compile_error!, unreachable!, unimplemented!

file!, line!, column!, module_path!
env!, option_env!
cfg!

select!, thread_local! // select: nightly-only experimental API

vec!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="println"><a class="header" href="#println"><code>println!</code></a></h1>
<p>Đây là một trong những macro được dùng nhiều nhất trong Rust.
Giúp in nội dung ra standard output, với một dấu newline xuống dòng.</p>
<p><code>println!</code> có cùng cú pháp với <a href="basic/macro/./format.html">format!</a>.</p>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">println!(); // prints just a newline
println!("hello there!");
println!("format {} arguments", "some");</code></pre></pre>
<h1 id="in-một-struct"><a class="header" href="#in-một-struct">In một Struct</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct MyStruct {
  item: String,
  n: i32,
}

let my_struct = MyStruct {
  item: "duyet".to_string(),
  n: 99,
};

println!("my struct = {:?}", my_struct); // my struct = MyStruct { item: "duyet", n: 99 }</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format"><code>format!</code></a></h1>
<p>Đây là một trong những macro được dùng nhiều nhất trong Rust.</p>
<p><code>format!()</code> giúp khởi tạo một <code>String</code>. Tham số đầu tiên của <code>format!</code> là chuỗi định dạng.
Sức mạnh của format string này ở trong các <code>{}</code>.</p>
<p>Xem các ví dụ sau:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021"><span class="boring">fn main() {
</span>format!("test");
format!("hello {}", "world!");
format!("x = {}, y = {y}", 10, y = 30);

let z = 100;
format!("z = {z}");
<span class="boring">}</span></code></pre></pre>
<h2 id="to_string-để-convert-một-giá-trị-thành-string"><a class="header" href="#to_string-để-convert-một-giá-trị-thành-string"><code>.to_string()</code> để convert một giá trị thành String</a></h2>
<p>Để convert một giá trị thành <code>String</code>, thay vì sử dụng <code>format!()</code> thì người ta hay sử dụng
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html">to_string</a>.
Method này sẽ sử dụng <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a> formatting trait.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021"><span class="boring">fn main() {
</span>// Thay vì
format!("single string");

// Sử dụng
"single string".to_string();
<span class="boring">}</span></code></pre></pre>
<h1 id="references-8"><a class="header" href="#references-8">References</a></h1>
<ul>
<li>https://doc.rust-lang.org/std/macro.format.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo"><code>todo!</code></a></h1>
<p>Đôi khi bạn sẽ cần viết code một cách tổng quát,
định nghĩa một loạt các function trước để hình dung ra flow của project,
liệt kê sẵn một loạt các function mà bạn dự định sẽ implementent và sử dụng sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Book {} // Okay, first I need a book struct.
               // Nothing in there yet - will add later

enum BookType { // A book can be hardcover or softcover, so add an enum
    HardCover,
    SoftCover,
}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {} // ⚠️ get_book should take a &amp;Book and return an Option&lt;String&gt;

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {} // delete_book should take a Book and return a Result...
                                                    // TODO: impl block and make these functions methods...
fn check_book_type(book_type: &amp;BookType) { // Let's make sure the match statement works
    match book_type {
        BookType::HardCover =&gt; println!("It's hardcover"),
        BookType::SoftCover =&gt; println!("It's softcover"),
    }
}

fn main() {
    let book_type = BookType::HardCover;
    check_book_type(&amp;book_type); // Okay, let's check this function!
}</code></pre></pre>
<p>Chúng ta chưa dùng đến, nhưng compiler vẫn sẽ không happy với <code>get_book</code> và <code>delete_book</code>.</p>
<pre><code>error[E0308]: mismatched types
  --&gt; src\main.rs:32:29
   |
32 | fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {}
   |    --------                 ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::option::Option&lt;std::string::String&gt;`
           found unit type `()`

error[E0308]: mismatched types
  --&gt; src\main.rs:34:31
   |
34 | fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {}
   |    -----------                ^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
   |
   = note:   expected enum `std::result::Result&lt;(), std::string::String&gt;`
           found unit type `()`
</code></pre>
<p>Khi này chúng ta sử dụng <code>todo!()</code>, Rust sẽ compile và không complain gì về những function dang dở này nữa.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Book {}

fn get_book(book: &amp;Book) -&gt; Option&lt;String&gt; {
    todo!() // todo means "I will do it later, please be quiet"
}

fn delete_book(book: Book) -&gt; Result&lt;(), String&gt; {
    todo!()
}

fn main() {}</code></pre></pre>
<h2 id="references-9"><a class="header" href="#references-9">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/macro.todo.html">https://doc.rust-lang.org/std/macro.todo.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro_rules"><a class="header" href="#macro_rules"><code>macro_rules!</code></a></h1>
<p><code>macro_rules!</code> là một macro cho phép định nghĩa một macro khác. Với macro này, bạn có thể tạo ra các macros như <code>println!</code> hoặc <code>vec!</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">// This is a simple macro named `say_hello`.
macro_rules! say_hello {
    // `()` indicates that the macro takes no argument.
    () =&gt; {
        // The macro will expand into the contents of this block.
        println!("Hello!");
    };
}

fn main() {
    // This call will expand into `println!("Hello");`
    say_hello!()
}</code></pre></pre>
<p>Trong đó <code>say_hello</code> là tên của macro bạn đang định nghĩa.
Sau đó, bạn có thể xác định các rule cho macro trong các block code phía sau.
Các quy tắc này được xác định bằng cách sử dụng các pattern và các rule. Pattern được sử dụng để so khớp với các biểu thức mà macro được áp dụng. Rule được sử dụng để chỉ định mã được tạo ra bởi macro khi so khớp với pattern.</p>
<pre><pre class="playground"><code class="language-rust edition2021">// This is a simple macro named `say_hello`.
macro_rules! say_hello {
    // `()` indicates that the macro takes no argument.
    () =&gt; {
        // The macro will expand into the contents of this block.
        println!("Hello!");
    };

    ($name: expr) =&gt; {
        println!("Hello {}!", $name);
    };
}

fn main() {
    // This call will expand into `println!("Hello {}", "Duyet");`
    say_hello!("Duyet")
}</code></pre></pre>
<p>Trong ví dụ trên, khi gọi <code>say_hello!("Duyet")</code> được so khớp với pattern <code>($name: expr)</code> do đó sau khi biên dịch,
đoạn mã được thực thi sẽ là <code>println!("Hello {}!", "Duyet");</code></p>
<h2 id="repeat--"><a class="header" href="#repeat--">Repeat <code>*</code>, <code>+</code></a></h2>
<p>Dưới đây là một ví dụ khác về cách sử dụng macro_rules! để định nghĩa một macro trong Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! vec_of_strings {
    ( $( $x:expr ),* ) =&gt; {
        vec![ $( $x.to_string() ),* ]
    };
}

fn main() {
    let fruits = vec_of_strings!["apple", "banana", "cherry"];
    println!("{:?}", fruits);
}</code></pre></pre>
<p>Trong đó, pattern <code>$( $x:expr ),*</code> so khớp với một danh sách các biểu thức được chuyển vào macro,
được phân tách bằng dấu phẩy <code>,</code>. Rule <code>vec![ $( $x.to_string() ),* ]</code> được sử dụng để tạo ra một <code>Vec</code>
các chuỗi được chuyển đổi từ các biểu thức được truyền vào.</p>
<p>Khi biên dịch, macro <code>vec_of_strings!</code> được mở rộng và tạo ra một <code>Vec</code> chứa các chuỗi <code>"apple"</code>, <code>"banana"</code>, và <code>"cherry"</code>.
Kết quả khi chạy chương trình sẽ là <code>["apple", "banana", "cherry"]</code> .</p>
<h2 id="Đệ-quy-macros"><a class="header" href="#Đệ-quy-macros">Đệ quy macros</a></h2>
<p>Dưới đây là một ví dụ về cách sử dụng đệ quy trong macro_rules! để tạo ra các macro phức tạp hơn:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! countdown {
    ($x:expr) =&gt; {
        println!("{}", $x);
    };
    ($x:expr, $($rest:expr),+) =&gt; {
        println!("{}", $x);
        countdown!($($rest),*);
    };
}

fn main() {
    countdown!(5, 4, 3, 2, 1);
}</code></pre></pre>
<p>Trong quy tắc macro <code>countdown!</code>, chúng ta sử dụng cấu trúc <code>$x:expr</code>
để lấy giá trị biểu thức được truyền vào và in ra nó bằng lệnh <code>println!</code>.
Sau đó, chúng ta sử dụng cấu trúc <code>$($rest:expr),+</code> để lấy danh sách các biểu thức còn lại,
và gọi lại macro <code>countdown!</code> với danh sách này.
Quá trình đệ quy này sẽ tiếp tục cho đến khi danh sách các biểu thức truyền vào rỗng,
khi đó macro sẽ không còn gọi lại chính nó nữa.</p>
<h2 id="references-10"><a class="header" href="#references-10">References</a></h2>
<ul>
<li>https://doc.rust-lang.org/rust-by-example/macros.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-1"><a class="header" href="#match-1">match</a></h1>
<p><code>match</code> được dùng khá phổ biến trong Rust (Pattern Syntax).</p>
<h3 id="nội-dung-1"><a class="header" href="#nội-dung-1">Nội dung</a></h3>
<ul>
<li><a href="basic/match/./literals.html">Matching giá trị</a></li>
<li><a href="basic/match/./named-vars.html">Matching Named Variables</a></li>
<li><a href="basic/match/./multiple.html">Matching Multiple</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-giá-trị"><a class="header" href="#matching-giá-trị">Matching giá trị</a></h1>
<p>Pattern matching với literals (giá trị cụ thể) là cách sử dụng phổ biến nhất của <code>match</code> trong Rust. Bạn có thể match trực tiếp với các giá trị cụ thể như số, ký tự, hay chuỗi.</p>
<h2 id="match-với-số-nguyên"><a class="header" href="#match-với-số-nguyên">Match với số nguyên</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn describe_number(x: i32) {
    match x {
        1 =&gt; println!("Một"),
        2 =&gt; println!("Hai"),
        3 =&gt; println!("Ba"),
        _ =&gt; println!("Số khác"),
    }
}

fn main() {
    describe_number(1);  // In ra: Một
    describe_number(5);  // In ra: Số khác
}</code></pre></pre>
<p>Pattern <code>_</code> (underscore) là một wildcard pattern, match với mọi giá trị còn lại. Nó giống như <code>default</code> case trong <code>switch</code> của C/Java.</p>
<h2 id="match-với-ký-tự"><a class="header" href="#match-với-ký-tự">Match với ký tự</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn describe_char(c: char) {
    match c {
        'a' =&gt; println!("Chữ a"),
        'b' =&gt; println!("Chữ b"),
        '0'..='9' =&gt; println!("Một chữ số"),
        _ =&gt; println!("Ký tự khác"),
    }
}

fn main() {
    describe_char('a');  // In ra: Chữ a
    describe_char('5');  // In ra: Một chữ số
    describe_char('z');  // In ra: Ký tự khác
}</code></pre></pre>
<p>Ở ví dụ trên, <code>'0'..='9'</code> là range pattern, match với mọi ký tự từ '0' đến '9'.</p>
<h2 id="match-với-boolean"><a class="header" href="#match-với-boolean">Match với boolean</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn is_true(b: bool) -&gt; &amp;'static str {
    match b {
        true =&gt; "Đúng rồi!",
        false =&gt; "Sai rồi!",
    }
}

fn main() {
    println!("{}", is_true(true));   // In ra: Đúng rồi!
    println!("{}", is_true(false));  // In ra: Sai rồi!
}</code></pre></pre>
<p>Với boolean, bạn không cần dùng <code>_</code> vì chỉ có 2 giá trị: <code>true</code> và <code>false</code>.</p>
<h2 id="match-với-range"><a class="header" href="#match-với-range">Match với range</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn categorize_age(age: u32) {
    match age {
        0 =&gt; println!("Trẻ sơ sinh"),
        1..=12 =&gt; println!("Trẻ em"),
        13..=19 =&gt; println!("Thiếu niên"),
        20..=64 =&gt; println!("Người trưởng thành"),
        65..=u32::MAX =&gt; println!("Người cao tuổi"),
    }
}

fn main() {
    categorize_age(5);   // In ra: Trẻ em
    categorize_age(25);  // In ra: Người trưởng thành
    categorize_age(70);  // In ra: Người cao tuổi
}</code></pre></pre>
<p>Cú pháp <code>1..=12</code> là inclusive range (bao gồm cả 1 và 12). Nếu dùng <code>1..12</code> thì sẽ là exclusive range (từ 1 đến 11, không bao gồm 12).</p>
<h2 id="exhaustiveness-checking"><a class="header" href="#exhaustiveness-checking">Exhaustiveness Checking</a></h2>
<p>Một điểm mạnh của <code>match</code> trong Rust là compiler sẽ kiểm tra xem bạn đã xử lý hết tất cả các trường hợp chưa. Điều này giúp tránh bugs.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_number(x: i32) {
    match x {
        1 =&gt; println!("Một"),
        2 =&gt; println!("Hai"),
        // ❌ Compiler sẽ báo lỗi: pattern `i32::MIN..=0_i32` and `3_i32..=i32::MAX` not covered
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Bạn phải xử lý tất cả các trường hợp, hoặc sử dụng <code>_</code> để bắt các trường hợp còn lại:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_number(x: i32) {
    match x {
        1 =&gt; println!("Một"),
        2 =&gt; println!("Hai"),
        _ =&gt; println!("Số khác"),  // ✅ OK
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="so-sánh-với-if-else"><a class="header" href="#so-sánh-với-if-else">So sánh với <code>if-else</code></a></h2>
<p>Trong một số ngôn ngữ khác như JavaScript hay Python, bạn có thể dùng <code>if-else</code> để làm việc tương tự:</p>
<pre><code class="language-javascript">// JavaScript
function describeNumber(x) {
  if (x === 1) {
    console.log("Một");
  } else if (x === 2) {
    console.log("Hai");
  } else if (x === 3) {
    console.log("Ba");
  } else {
    console.log("Số khác");
  }
}
</code></pre>
<p>Tuy nhiên <code>match</code> trong Rust có nhiều ưu điểm hơn:</p>
<ul>
<li>Compiler kiểm tra exhaustiveness (đã xử lý hết tất cả trường hợp chưa)</li>
<li>Dễ đọc và rõ ràng hơn với nhiều trường hợp</li>
<li>Có thể match với pattern phức tạp (struct, enum, ...)</li>
</ul>
<h2 id="trả-về-giá-trị"><a class="header" href="#trả-về-giá-trị">Trả về giá trị</a></h2>
<p><code>match</code> là một expression, có nghĩa là nó có thể trả về giá trị:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn number_to_string(x: i32) -&gt; String {
    match x {
        1 =&gt; "một".to_string(),
        2 =&gt; "hai".to_string(),
        3 =&gt; "ba".to_string(),
        _ =&gt; format!("số {}", x),
    }
}

fn main() {
    let result = number_to_string(2);
    println!("{}", result);  // In ra: hai
}</code></pre></pre>
<p>Tất cả các arm (nhánh) của <code>match</code> phải trả về cùng một kiểu dữ liệu.</p>
<h2 id="references-11"><a class="header" href="#references-11">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch06-02-match.html">Match - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Patterns and Matching</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-named-variables"><a class="header" href="#matching-named-variables">Matching Named Variables</a></h1>
<p>Named variables trong pattern matching cho phép bạn bind (gán) giá trị vào một biến mới trong match arm. Đây là một tính năng mạnh mẽ giúp bạn trích xuất và sử dụng giá trị từ các kiểu dữ liệu phức tạp.</p>
<h2 id="cơ-bản-về-named-variables"><a class="header" href="#cơ-bản-về-named-variables">Cơ bản về Named Variables</a></h2>
<p>Khi bạn sử dụng một tên biến trong pattern, Rust sẽ tạo một biến mới và gán giá trị match được vào biến đó:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;

    match x {
        value =&gt; println!("Giá trị là: {}", value),
    }
    // In ra: Giá trị là: 5
}</code></pre></pre>
<p>Ở ví dụ trên, <code>value</code> là một named variable, nó sẽ match với bất kỳ giá trị nào và bind giá trị đó vào biến <code>value</code>.</p>
<h2 id="shadowing-trong-match"><a class="header" href="#shadowing-trong-match">Shadowing trong Match</a></h2>
<p>Một điểm cần lưu ý là named variable trong match có thể shadow (che khuất) biến bên ngoài:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!("Bằng 50"),
        Some(y) =&gt; println!("Matched, y = {}", y),  // y ở đây là biến mới!
        _ =&gt; println!("Default case, x = {:?}", x),
    }

    println!("Kết thúc: x = {:?}, y = {}", x, y);
}</code></pre></pre>
<p>Output:</p>
<pre><code>Matched, y = 5
Kết thúc: x = Some(5), y = 10
</code></pre>
<p>Lưu ý rằng <code>y</code> trong pattern <code>Some(y)</code> là một biến mới, <strong>không phải</strong> là biến <code>y = 10</code> ở ngoài. Biến <code>y</code> trong match arm có giá trị là <code>5</code> (được extract từ <code>Some(5)</code>), còn biến <code>y</code> bên ngoài vẫn giữ nguyên giá trị <code>10</code>.</p>
<h2 id="match-với-struct"><a class="header" href="#match-với-struct">Match với Struct</a></h2>
<p>Named variables rất hữu ích khi destructure struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 0, y: 7 };

    match point {
        Point { x, y: 0 } =&gt; println!("Trên trục x tại x = {}", x),
        Point { x: 0, y } =&gt; println!("Trên trục y tại y = {}", y),
        Point { x, y } =&gt; println!("Tại ({}, {})", x, y),
    }
    // In ra: Trên trục y tại y = 7
}</code></pre></pre>
<p>Bạn có thể đặt tên khác cho biến:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 5, y: 10 };

    match point {
        Point { x: horizontal, y: vertical } =&gt; {
            println!("Tọa độ ngang: {}, tọa độ dọc: {}", horizontal, vertical);
        }
    }
    // In ra: Tọa độ ngang: 5, tọa độ dọc: 10
}</code></pre></pre>
<h2 id="match-với-enum"><a class="header" href="#match-với-enum">Match với Enum</a></h2>
<p>Named variables cho phép extract giá trị từ enum variants:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit =&gt; println!("Thoát"),
        Message::Move { x, y } =&gt; println!("Di chuyển đến ({}, {})", x, y),
        Message::Write(text) =&gt; println!("Văn bản: {}", text),
        Message::ChangeColor(r, g, b) =&gt; println!("Đổi màu RGB({}, {}, {})", r, g, b),
    }
}

fn main() {
    let msg1 = Message::Move { x: 10, y: 20 };
    let msg2 = Message::Write(String::from("Hello"));
    let msg3 = Message::ChangeColor(255, 0, 0);

    process_message(msg1);  // In ra: Di chuyển đến (10, 20)
    process_message(msg2);  // In ra: Văn bản: Hello
    process_message(msg3);  // In ra: Đổi màu RGB(255, 0, 0)
}</code></pre></pre>
<h2 id="match-với-tuple"><a class="header" href="#match-với-tuple">Match với Tuple</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let tuple = (1, 2, 3);

    match tuple {
        (0, y, z) =&gt; println!("Phần tử đầu là 0, y = {}, z = {}", y, z),
        (x, 0, z) =&gt; println!("Phần tử giữa là 0, x = {}, z = {}", x, z),
        (x, y, 0) =&gt; println!("Phần tử cuối là 0, x = {}, y = {}", x, y),
        (x, y, z) =&gt; println!("x = {}, y = {}, z = {}", x, y, z),
    }
    // In ra: x = 1, y = 2, z = 3
}</code></pre></pre>
<h2 id="sử-dụng--binding"><a class="header" href="#sử-dụng--binding">Sử dụng <code>@</code> binding</a></h2>
<p><code>@</code> operator cho phép bạn vừa test một giá trị với pattern, vừa bind giá trị đó vào một biến:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let age = 25;

    match age {
        n @ 0..=12 =&gt; println!("Trẻ em, tuổi: {}", n),
        n @ 13..=19 =&gt; println!("Thiếu niên, tuổi: {}", n),
        n @ 20..=64 =&gt; println!("Người trưởng thành, tuổi: {}", n),
        n @ 65.. =&gt; println!("Người cao tuổi, tuổi: {}", n),
    }
    // In ra: Người trưởng thành, tuổi: 25
}</code></pre></pre>
<p>Không có <code>@</code>, bạn sẽ không có biến để sử dụng:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match age {
    0..=12 =&gt; println!("Trẻ em"),  // không biết tuổi cụ thể
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="-với-enum"><a class="header" href="#-với-enum"><code>@</code> với enum</a></h2>
<p><code>@</code> binding rất hữu ích khi làm việc với enum:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello { id: id_var @ 3..=7 } =&gt; {
            println!("ID trong khoảng 3-7: {}", id_var);
        }
        Message::Hello { id: 10..=12 } =&gt; {
            println!("ID trong khoảng 10-12");
        }
        Message::Hello { id } =&gt; {
            println!("ID khác: {}", id);
        }
    }
    // In ra: ID trong khoảng 3-7: 5
}</code></pre></pre>
<h2 id="phân-biệt-với-_"><a class="header" href="#phân-biệt-với-_">Phân biệt với <code>_</code></a></h2>
<p>Named variable sẽ match và bind giá trị, trong khi <code>_</code> chỉ match mà không bind:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let x = 5;

    match x {
        value =&gt; println!("Có giá trị: {}", value),  // OK, có thể dùng value
    }

    match x {
        _ =&gt; println!("Có giá trị: {}", x),  // Dùng x từ outer scope
    }
}</code></pre></pre>
<p>Sử dụng <code>_</code> khi bạn không quan tâm đến giá trị:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

fn main() {
    let point = Point { x: 0, y: 0, z: 8 };

    match point {
        Point { x: 0, y: 0, z } =&gt; println!("Trên trục z tại z = {}", z),
        Point { x: 0, y, z: _ } =&gt; println!("Trên mặt phẳng yz, y = {}", y),
        Point { x, y: _, z: _ } =&gt; println!("x = {}, không quan tâm y và z", x),
        _ =&gt; println!("Điểm khác"),
    }
}</code></pre></pre>
<h2 id="ví-dụ-thực-tế-parse-kết-quả"><a class="header" href="#ví-dụ-thực-tế-parse-kết-quả">Ví dụ thực tế: Parse kết quả</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn parse_config(input: &amp;str) -&gt; Result&lt;(String, u16), String&gt; {
    let parts: Vec&lt;&amp;str&gt; = input.split(':').collect();

    match parts.as_slice() {
        [host, port] =&gt; {
            match port.parse::&lt;u16&gt;() {
                Ok(port_num) =&gt; Ok((host.to_string(), port_num)),
                Err(_) =&gt; Err("Port không hợp lệ".to_string()),
            }
        }
        _ =&gt; Err("Format không đúng".to_string()),
    }
}

fn main() {
    match parse_config("localhost:8080") {
        Ok((host, port)) =&gt; println!("Server: {} trên port {}", host, port),
        Err(e) =&gt; println!("Lỗi: {}", e),
    }
    // In ra: Server: localhost trên port 8080
}</code></pre></pre>
<h2 id="references-12"><a class="header" href="#references-12">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#-bindings">@ Bindings</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Patterns and Matching</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matching-multiple"><a class="header" href="#matching-multiple">Matching Multiple</a></h1>
<p>Trong Rust, bạn có thể match nhiều pattern trong cùng một arm của <code>match</code> expression. Điều này giúp code ngắn gọn và dễ đọc hơn khi nhiều giá trị cần được xử lý giống nhau.</p>
<h2 id="match-nhiều-giá-trị-với--or-pattern"><a class="header" href="#match-nhiều-giá-trị-với--or-pattern">Match nhiều giá trị với <code>|</code> (OR pattern)</a></h2>
<p>Toán tử <code>|</code> (pipe) cho phép bạn match nhiều pattern trong cùng một arm:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn describe_number(x: i32) {
    match x {
        1 | 2 =&gt; println!("Một hoặc hai"),
        3 | 4 | 5 =&gt; println!("Ba, bốn hoặc năm"),
        _ =&gt; println!("Số khác"),
    }
}

fn main() {
    describe_number(1);  // In ra: Một hoặc hai
    describe_number(4);  // In ra: Ba, bốn hoặc năm
    describe_number(7);  // In ra: Số khác
}</code></pre></pre>
<h2 id="kết-hợp-or-pattern-với-range"><a class="header" href="#kết-hợp-or-pattern-với-range">Kết hợp OR pattern với range</a></h2>
<p>Bạn có thể kết hợp nhiều pattern và range trong cùng một arm:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn categorize_number(x: i32) {
    match x {
        0 =&gt; println!("Số không"),
        1..=10 | 100 =&gt; println!("Từ 1 đến 10, hoặc 100"),
        -1 | -2 | -3 =&gt; println!("Số âm nhỏ"),
        _ =&gt; println!("Số khác"),
    }
}

fn main() {
    categorize_number(5);    // In ra: Từ 1 đến 10, hoặc 100
    categorize_number(100);  // In ra: Từ 1 đến 10, hoặc 100
    categorize_number(-2);   // In ra: Số âm nhỏ
}</code></pre></pre>
<h2 id="match-với-ký-tự-1"><a class="header" href="#match-với-ký-tự-1">Match với ký tự</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn is_vowel(c: char) -&gt; bool {
    match c {
        'a' | 'e' | 'i' | 'o' | 'u' =&gt; true,
        'A' | 'E' | 'I' | 'O' | 'U' =&gt; true,
        _ =&gt; false,
    }
}

fn main() {
    println!("{}", is_vowel('a'));  // true
    println!("{}", is_vowel('b'));  // false
    println!("{}", is_vowel('E'));  // true
}</code></pre></pre>
<p>Hoặc ngắn gọn hơn:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_vowel(c: char) -&gt; bool {
    match c {
        'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I' | 'O' | 'U' =&gt; true,
        _ =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="match-với-enum-1"><a class="header" href="#match-với-enum-1">Match với enum</a></h2>
<p>OR pattern rất hữu ích khi làm việc với enum:</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum Direction {
    North,
    South,
    East,
    West,
}

fn is_horizontal(dir: Direction) -&gt; bool {
    match dir {
        Direction::East | Direction::West =&gt; true,
        Direction::North | Direction::South =&gt; false,
    }
}

fn main() {
    println!("{}", is_horizontal(Direction::East));   // true
    println!("{}", is_horizontal(Direction::North));  // false
}</code></pre></pre>
<h2 id="ví-dụ-thực-tế-http-status-codes"><a class="header" href="#ví-dụ-thực-tế-http-status-codes">Ví dụ thực tế: HTTP status codes</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn handle_status_code(code: u16) {
    match code {
        200 | 201 | 202 | 204 =&gt; println!("Success"),
        301 | 302 | 303 | 307 | 308 =&gt; println!("Redirect"),
        400 | 401 | 403 | 404 =&gt; println!("Client error"),
        500 | 501 | 502 | 503 =&gt; println!("Server error"),
        _ =&gt; println!("Unknown status"),
    }
}

fn main() {
    handle_status_code(200);  // In ra: Success
    handle_status_code(404);  // In ra: Client error
    handle_status_code(500);  // In ra: Server error
}</code></pre></pre>
<p>Hoặc kết hợp với range để ngắn gọn hơn:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_status_code(code: u16) {
    match code {
        200..=299 =&gt; println!("Success"),
        300..=399 =&gt; println!("Redirect"),
        400..=499 =&gt; println!("Client error"),
        500..=599 =&gt; println!("Server error"),
        _ =&gt; println!("Unknown status"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="so-sánh-với-ngôn-ngữ-khác"><a class="header" href="#so-sánh-với-ngôn-ngữ-khác">So sánh với ngôn ngữ khác</a></h2>
<p>Trong JavaScript, bạn có thể sử dụng multiple <code>case</code> statements mà không có <code>break</code>:</p>
<pre><code class="language-javascript">// JavaScript
function describeNumber(x) {
  switch (x) {
    case 1:
    case 2:
      console.log("Một hoặc hai");
      break;
    case 3:
    case 4:
    case 5:
      console.log("Ba, bốn hoặc năm");
      break;
    default:
      console.log("Số khác");
  }
}
</code></pre>
<p>Trong Python (từ version 3.10), bạn có thể dùng <code>|</code> trong <code>match</code>:</p>
<pre><code class="language-python"># Python 3.10+
def describe_number(x):
    match x:
        case 1 | 2:
            print("Một hoặc hai")
        case 3 | 4 | 5:
            print("Ba, bốn hoặc năm")
        case _:
            print("Số khác")
</code></pre>
<p>Rust's OR pattern (<code>|</code>) tương tự như Python, nhưng được kiểm tra tại compile time để đảm bảo type safety.</p>
<h2 id="match-với-tuple-1"><a class="header" href="#match-với-tuple-1">Match với tuple</a></h2>
<p>Bạn cũng có thể sử dụng OR pattern với tuple:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn describe_point(point: (i32, i32)) {
    match point {
        (0, 0) =&gt; println!("Gốc tọa độ"),
        (0, _) | (_, 0) =&gt; println!("Nằm trên trục"),
        (x, y) if x == y =&gt; println!("Nằm trên đường chéo"),
        _ =&gt; println!("Điểm thông thường"),
    }
}

fn main() {
    describe_point((0, 0));  // In ra: Gốc tọa độ
    describe_point((0, 5));  // In ra: Nằm trên trục
    describe_point((3, 0));  // In ra: Nằm trên trục
    describe_point((4, 4));  // In ra: Nằm trên đường chéo
    describe_point((2, 3));  // In ra: Điểm thông thường
}</code></pre></pre>
<h2 id="lưu-ý-quan-trọng"><a class="header" href="#lưu-ý-quan-trọng">Lưu ý quan trọng</a></h2>
<p>Khi sử dụng OR pattern, tất cả các pattern phải bind (gán) cùng một tập hợp các biến. Ví dụ sau sẽ <strong>không</strong> compile:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Lỗi: variable `x` is not bound in all patterns
match (1, 2) {
    (x, _) | (_, x) =&gt; println!("{}", x),  // lỗi!
}
<span class="boring">}</span></code></pre></pre>
<p>Lý do là trong pattern đầu tiên <code>(x, _)</code>, <code>x</code> được bind với phần tử đầu tiên, nhưng trong pattern thứ hai <code>(_, x)</code>, <code>x</code> được bind với phần tử thứ hai. Compiler không thể xác định <code>x</code> nên lấy giá trị nào.</p>
<h2 id="references-13"><a class="header" href="#references-13">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#multiple-patterns">Multiple Patterns - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Patterns and Matching</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes"><code>#[attributes]</code></a></h1>
<p>Attribute là metadata được apply cho một số module, crate hoặc item.
Metadata này được dùng cho việc:</p>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">conditional compilation of code</a>: compile code theo điều kiện, ví dụ một số code sẽ chỉ được compile cho tests, cho OS cụ thể, cho một số feature nào đó, etc.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// This function only gets compiled if the target OS is linux
#[cfg(target_os = "linux")]
fn are_you_on_linux() {
    println!("You are running linux!");
}

// And this function only gets compiled if the target OS is *not* linux
#[cfg(not(target_os = "linux"))]
fn are_you_on_linux() {
    println!("You are *not* running linux!");
}</code></pre></pre>
</li>
<li>
<p><a href="https://doc.rust-lang.org/rust-by-example/attribute/crate.html">set crate name, version and type (binary or library)</a></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// This crate is a library
#![crate_type = "lib"]
// The library is named "rary"
#![crate_name = "rary"]

pub fn public_function() {
    println!("called rary's `public_function()`");
}</code></pre></pre>
</li>
<li>
<p>disable lints (warnings)</p>
</li>
<li>
<p>bật một số tính năng của compiler (macros, glob imports, etc.)</p>
</li>
<li>
<p>link đến foreign library</p>
</li>
<li>
<p>đánh dấu các function là unit tests</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[test]
fn test_hello() {
    assert!("hello");
}</code></pre></pre>
</li>
<li>
<p>đánh dấu function là một phần của benchmark</p>
</li>
</ul>
<p>Khi một attributes được apply cho cả crate, cú pháp là <code>#![crate_attribute]</code>.
Khi apply cho một module hoặc item, cú pháp là <code>#[item_attribute]</code> (không có dấu <code>!</code>).</p>
<p>Attributes cũng có thể có tham số:</p>
<ul>
<li><code>#[attribute = "value"]</code></li>
<li><code>#[attribute(key = "value")]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Attributes có thể có nhiều giá trị, có thể break thành nhiều dòng:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[attribute(value, value2)]

#[attribute(value, value2, value3,
            value4, value5)]</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xử-lý-lỗi"><a class="header" href="#xử-lý-lỗi">Xử lý lỗi</a></h1>
<p>Có rất nhiều cách để deal với error trong Rust. Bạn vui lòng xem trong các trang tiếp theo,
mặc dù có nhiều cách để xử lý tùy theo các trường hợp khác nhau, có một quy luật chung:</p>
<ul>
<li><code>panic</code> hầu hết hữu ích trong khi tests (panic khi test fail) hoặc đối mặt với các lỗi không thể xử lý được.</li>
<li><code>Option</code> khi một giá trị nào đó là không bắt buộc hoặc thiếu các giá trị này vẫn không gây lỗi cho chương trình. Chỉ sử dụng <code>unwrap()</code> khi prototyping hoặc các trường hợp chắc chắn luôn luôn có giá trị. Tuy nhiên <code>expect()</code> thì ổn hơn bởi nó giúp chúng ta bỏ thêm error message khi có biến.</li>
<li>Khi có khả năng một function nào đó có thể lỗi, và người gọi function bắt buộc phải xử lý lỗi đó, hãy sử dụng <code>Result</code>. Vui lòng chỉ sử dụng <code>unwrap()</code> và <code>expect()</code> trong khi test hoặc prototype.</li>
</ul>
<h3 id="nội-dung-2"><a class="header" href="#nội-dung-2">Nội dung</a></h3>
<ul>
<li><a href="basic/error-handling/./panic.html">panic</a></li>
<li><a href="basic/error-handling/./option.html">Option</a></li>
<li><a href="basic/error-handling/./result.html">Result</a>
<ul>
<li><a href="basic/error-handling/./result-map.html">Result map</a></li>
<li><a href="basic/error-handling/./result-alias.html">Result alias</a></li>
</ul>
</li>
<li><a href="basic/error-handling/./boxing-error.html">Boxing error</a></li>
<li><a href="basic/error-handling/./custom-error.html">Custom error</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic</a></h1>
<p>Cơ chế đơn giản nhất để xử lý lỗi là <code>panic!</code>. Panic sẽ in error message
và thường sẽ thoát chương trình.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn drink(beverage: &amp;str) {
    if beverage == "lemonade" { panic!("AAAaaaaa!!!!"); }

    println!("Some refreshing {} is all I need.", beverage);
}

fn main() {
    drink("water");
    drink("lemonade");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-1"><a class="header" href="#option-1"><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a></a></h1>
<p>Nhiều ngôn ngữ sử dụng kiểu dữ liệu <code>null</code> hoặc <code>nil</code> hoặc <code>undefined</code>
để đại diện cho các giá trị rỗng hoặc không tồn tại, và sử dụng <code>Exception</code>
để xử lý lỗi. Rust bỏ qua hai khái niệm này, để tránh gặp phải các lỗi phổ biến
như <strong>null pointer exceptions,</strong> hay <strong>lộ thông tin nhạy cảm thông qua exceptions,</strong> ...
Thay vào đó, Rust giới thiệu hai generic enums <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a>
và <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> để giải quyết các vấn đề trên.</p>
<hr />
<p>Trong hầu hết các ngôn ngữ họ C (C, C#, Java, ...), để xác định một cái gì đó failed
hay không tìm được giá trị thỏa mãn, chúng ta thường trả về một giá trị <em>"đặc biệt"</em> nào đó.
Ví dụ <code>indexOf()</code> của Javascript scan một phần tử trong mảng,
trả về vị trí của phần tử đó trong mảng. Và trả về <code>-1</code> nếu không tìm thấy.</p>
<p>Dẫn đến, ta sẽ thường thấy một số đoạn code như sau đây:</p>
<pre><code class="language-typescript">// Typescript

let sentence = "The fox jumps over the dog";
let index = sentence.indexOf("fox");

if (index &gt; -1) {
  let result = sentence.substr(index);
  console.log(result);
}
</code></pre>
<p>Như bạn thấy <code>-1</code> là một trường hợp đặc biệt cần xử lý.
Có khi nào bạn đã từng mắc lỗi ngớ ngẫn vì tưởng giá trị đặc biệt đó là <code>0</code> chưa?</p>
<pre><code class="language-typescript">// Typescript

if (index &gt; 0) {
  // 3000 days of debugging
}
</code></pre>
<p><code>""</code> hay <code>null</code> hay <code>None</code> cũng là một trong những trường hợp đặc biệt đó.
Bạn đã từng nghe đến <strong><strong><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a></strong></strong>?</p>
<p>Lý do cơ bản là không có gì chắc chắn và có thể ngăn bạn lại việc ... <strong>quên</strong>
xử lý mọi trường hợp giá trị đặc biệt, hoặc do chương trình trả về các giá trị đặc biệt không như mong đợi.
Có nghĩa là ta có thể <em>vô tình</em> làm crash chương trình với một lỗi nhỏ ở bất kỳ đâu, ở bất kỳ thời điểm nào.</p>
<p>Rust làm điều này tốt hơn, chỉ với <code>Option</code>.</p>
<p>Một giá trị optional có thể mang một giá trị nào đó <strong>Some(something)</strong> hoặc không mang giá trị nào cả (<strong>None</strong>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An output can have either Some value or no value/ None.
enum Option&lt;T&gt; { // T is a generic and it can contain any type of value.
  Some(T),
  None,
}
<span class="boring">}</span></code></pre></pre>
<p>Theo thiết kế, mặc định bạn sẽ không bao giờ lấy được giá trị bạn cần nếu không xử lý
các trường hợp có thể xảy ra với <code>Option</code>, là <code>None</code> chẳng hạn.
Điều này được bắt buộc bởi compiler lúc compile code,
có nghĩa là nếu bạn quên check, code sẽ không bao giờ được compile.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sentence = "The fox jumps over the dog";
let index = sentence.find("fox");

if let Some(fox) = index {
  let words_after_fox = &amp;sentence[fox..];
  println!("{}", words_after_fox);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cách-sử-dụng-option-1"><a class="header" href="#cách-sử-dụng-option-1"><strong>Cách sử dụng Option</strong></a></h2>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> là standard library, do đã được
<a href="https://learning-rust.github.io/docs/d7.std_primitives_and_preludes.html#Preludes">preludes</a>
nên chúng ta không cần khai báo trước khi sử dụng. Ngoài enum
<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> thì các variant của nó cũng đã được preludes
sẵn như <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some">Some</a>
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None">None</a>.</p>
<p>Ví dụ, ta có một function tính giá trị chia hai số,
đôi khi sẽ không tìm ra được kết quả, ta sử dụng Some như sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Option&lt;i32&gt; {
    if !name.starts_with('d') {
        return None;
    }

    Some(123)
}

fn main() {
    let name = "duyet";

    match get_id_from_name(name) {
        Some(id) =&gt; println!("User = {}", id),
        _ =&gt; println!("Not found"),
    }
}</code></pre></pre>
<p>Ta thường sử dụng <code>match</code> để bắt giá trị trả về (<code>Some</code> hoặc <code>None</code>).</p>
<p>Bạn sẽ bắt gặp rất nhiều method khác nhau để xử lý giá trị của <code>Option</code></p>
<p><a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> method overview: <a href="https://doc.rust-lang.org/std/option/#method-overview">https://doc.rust-lang.org/std/option/#method-overview</a></p>
<h3 id="unwrap-3"><a class="header" href="#unwrap-3"><code>.unwrap()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some(T)</code>. Nếu giá trị là <code>None</code> thì panic chương trình.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some("air");
assert_eq!(x.unwrap(), "air");

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), "air"); // panic!
<span class="boring">}</span></code></pre></pre>
<h3 id="expect-3"><a class="header" href="#expect-3"><code>.expect()</code></a></h3>
<p>Giống <code>.unwrap()</code>, nhưng khi panic thì Rust sẽ kèm theo message</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Option&lt;&amp;str&gt; = None;
x.expect("fruits are healthy"); // panics: `fruits are healthy`
<span class="boring">}</span></code></pre></pre>
<h3 id="unwrap_or-1"><a class="header" href="#unwrap_or-1"><code>.unwrap_or()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá trị nằm trong <code>or</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some("car").unwrap_or("bike"), "car");
<span class="boring">}</span></code></pre></pre>
<h3 id="unwrap_or_default-2"><a class="header" href="#unwrap_or_default-2"><code>.unwrap_or_default()</code></a></h3>
<p>Trả về giá trị nằm trong <code>Some</code>, nếu không trả về giá <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">default</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let good_year_from_input = "1909";
let bad_year_from_input = "190blarg";
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
<span class="boring">}</span></code></pre></pre>
<h3 id="ok_or-1"><a class="header" href="#ok_or-1"><code>.ok_or()</code></a></h3>
<p>Convert <code>Option&lt;T&gt;</code> sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>,
mapping <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some"><code>Some(v)</code></a>
thành <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok(v)</code></a>
và <a href="https://doc.rust-lang.org/std/option/enum.Option.html#variant.None"><code>None</code></a>
sang <a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err(err)</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some("foo");
assert_eq!(x.ok_or(0), Ok("foo"));
<span class="boring">}</span></code></pre></pre>
<h3 id="match-2"><a class="header" href="#match-2"><code>match</code></a></h3>
<p>Chúng ta có thể sử dụng pattern matching để code dễ đọc hơn</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_name(who: Option&lt;String&gt;) -&gt; String {
  match who {
    Some(name) =&gt; format!("Hello {}", name),
    None       =&gt; "Who are you?".to_string(), 
  }
}

get_name(Some("duyet"));
<span class="boring">}</span></code></pre></pre>
<h3 id="if-let-somex--x-2"><a class="header" href="#if-let-somex--x-2">if let Some(x) = x</a></h3>
<p>Có thể bạn sẽ gặp pattern này nhiều khi đọc code Rust.
Nếu giá trị của <code>x</code> là <code>Some</code> thì sẽ destruct
giá trị đó bỏ vào biến <code>x</code> nằm trong scope của <code>if</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_data() -&gt; Option&lt;String&gt; {
    Some("ok".to_string())
}

if let Some(data) = get_data() {
    println!("data = {}", data);
} else {
    println!("no data");
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1"><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a></a></h1>
<p>Tương tự như <code>Option</code>.
Một kết quả trả về (<a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a>)
của một function thường sẽ có hai trường hợp:</p>
<ul>
<li>thành công (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok"><code>Ok</code></a>) và trả về kết quả</li>
<li>hoặc lỗi (<a href="https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err"><code>Err</code></a>) và trả về thông tin lỗi.</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a> là một phiên bản cao cấp hơn của <code>Option</code>.
Nó mô tả <em>lỗi gì</em> đang xảy ra thay vì khả năng <em>tồn tại</em> giá trị hay không.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>Ví dụ</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn get_id_from_name(name: &amp;str) -&gt; Result&lt;i32, &amp;str&gt; {
    if !name.starts_with('d') {
        return Err("not found");
    }

    Ok(123)
}

fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    let name = "duyet";

    match get_id_from_name(name) {
        Ok(id) =&gt; println!("User = {}", id),
        Err(e) =&gt; println!("Error: {}", e),
    };

    Ok(())
}</code></pre></pre>
<p>Như bạn thấy thì <code>main()</code> cũng có thể return về <code>Result&lt;(), &amp;'static str&gt;</code></p>
<h3 id="unwrap-4"><a class="header" href="#unwrap-4"><code>.unwrap()</code></a></h3>
<p>Ví dụ trên nhưng sử dụng <code>.unwrap()</code> , chủ động panic (crash) dừng chương trình nếu gặp lỗi.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = "duyet";
  let age = get_age(who).unwrap();
  println!("{} is {}", who, age);

  Ok(())
}</code></pre></pre>
<h3 id="expect-4"><a class="header" href="#expect-4"><code>.expect()</code></a></h3>
<p>Giống như <code>unwrap()</code>: chủ động panic (crash) dừng chương trình nếu gặp lỗi và kèm theo message. Sẽ rất có ích, nhất là khi có quá nhiều unwrap, bạn sẽ không biết nó panic ở đâu.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
  let who = "ngan";
  let age = get_age(who).expect("could not get age");
  println!("{} is {}", who, age);

  Ok(())
}</code></pre></pre>
<p>Xem thêm mọi method khác của <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> <a href="https://doc.rust-lang.org/std/result/enum.Result.html">tại đây</a>.</p>
<h1 id="convert-result---option-2"><a class="header" href="#convert-result---option-2">Convert <code>Result</code> -&gt; <code>Option</code></a></h1>
<p>Đôi khi bạn sẽ cần convert từ:</p>
<ul>
<li><code>Ok(v)</code> --&gt; <code>Some(v)</code></li>
<li>hoặc ngược lại, <code>Err(e)</code> --&gt; <code>Some(e)</code></li>
</ul>
<h2 id="ok-2"><a class="header" href="#ok-2"><code>.ok()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .ok(v) = Some(v)
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.ok(), Some(2));

let y: Result&lt;u32, &amp;str&gt; = Err("Nothing here");
assert_eq!(y.ok(), None);</code></pre></pre>
<h2 id="err-2"><a class="header" href="#err-2"><code>.err()</code></a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">// .err()
let x: Result&lt;u32, &amp;str&gt; = Ok(2);
assert_eq!(x.err(), None);

let x: Result&lt;u32, &amp;str&gt; = Err("Nothing here");
assert_eq!(x.err(), Some("Nothing here"));</code></pre></pre>
<h1 id="toán-tử--2"><a class="header" href="#toán-tử--2">Toán tử <code>?</code></a></h1>
<p>Khi viết code mà có quá nhiều functions trả về <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>, việc handle <code>Err</code> sẽ khá nhàm chán.
Toán tử chấm hỏi <a href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>?</code></a> cho phép dừng function tại vị trí đó và return cho function cha nếu <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> ở vị trí đó là <code>Err</code>.</p>
<p>Nó sẽ thay thế đoạn code sau:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  // Early return on error
  let mut file = match File::create("my_best_friends.txt") {
    Err(e) =&gt; return Err(e),
    Ok(f) =&gt; f,
  };
  if let Err(e) = file.write_all(format!("name: {}\n", info.name).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!("age: {}\n", info.age).as_bytes()) {
    return Err(e)
  }
  if let Err(e) = file.write_all(format!("rating: {}\n", info.rating).as_bytes()) {
    return Err(e)
  }
  Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>thành</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::prelude::*;
use std::io;

struct Info {
  name: String,
  age: i32,
  rating: i32,
}

fn write_info(info: &amp;Info) -&gt; io::Result&lt;()&gt; {
  let mut file = File::create("my_best_friends.txt")?;
  // Early return on error
  file.write_all(format!("name: {}\n", info.name).as_bytes())?;
  file.write_all(format!("age: {}\n", info.age).as_bytes())?;
  file.write_all(format!("rating: {}\n", info.rating).as_bytes())?;
  Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Gọn đẹp hơn rất nhiều.</p>
<p>Toán tử <code>?</code> sẽ unwrap giá trị <code>Ok</code>, hoặc return giá trị <code>Err</code> ở vị trí gần toán tử đó.</p>
<p><code>?</code> chỉ có thể được dùng trong function có kiểu dữ liệu trả về là <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-map"><a class="header" href="#result-map">Result <code>map</code></a></h1>
<p>Ta có thể xử lý giá trị bên trong <code>Result</code> mà không cần xử lý <code>Err</code>,
trong trường hợp bạn muốn trả <code>Err</code> cho hàm bên trên đó tự lý.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(a: &amp;str, b: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
  match a.parse::&lt;i32&gt;() {
    Ok(first) =&gt; {
      match b.parse::&lt;i32&gt;() {
        Ok(second) =&gt; Ok(first * second),
        Err(e) =&gt; Err(e),
      }
    },
    Err(e) =&gt; Err(e),
  }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
  match result {
    Ok(n)  =&gt; println!("n is {}", n),
    Err(e) =&gt; println!("Error: {}", e),
  }
}

fn main() {
  let twenty = multiply("10", "2");
  print(twenty);

  let tt = multiply("t", "2");
  print(tt);
}</code></pre></pre>
<p>Thay vào đó ta sử dụng <code>.map()</code>, <code>.and_then()</code> để đoạn code trên hiệu quả và dễ đọc hơn.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

fn multiply(a: &amp;str, b: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
  a.parse::&lt;i32&gt;().and_then(|first| {
    b.parse::&lt;i32&gt;().map(|second| first * second)
  })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
  match result {
    Ok(n)  =&gt; println!("n is {}", n),
    Err(e) =&gt; println!("Error: {}", e),
  }
}

fn main() {
    let twenty = multiply("10", "2");
    print(twenty);

    let tt = multiply("t", "2");
    print(tt);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-alias"><a class="header" href="#result-alias">Result alias</a></h1>
<p>Rust cho phép chúng ta tạo <a href="https://doc.rust-lang.org/rust-by-example/types/alias.html">alias</a>.
Việc alias <code>Result</code> sẽ tiết kiệm chúng ta rất nhiều thời gian,
nhất là trong cùng một module và ta đang cố reuse <code>Result</code> nhiều lần.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// Define a generic alias for a `Result` with the error type `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Use the above alias to refer to our specific `Result` type.
fn multiply(a: &amp;str, b: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
  a.parse::&lt;i32&gt;().and_then(|first| {
    b.parse::&lt;i32&gt;().map(|second| first * second)
  })
}

fn print(result: AliasedResult&lt;i32&gt;) {
  match result {
    Ok(n)  =&gt; println!("n is {}", n),
    Err(e) =&gt; println!("Error: {}", e),
  }
}

fn main() {
  print(multiply("10", "2"));
  print(multiply("t", "2"));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxing-error"><a class="header" href="#boxing-error">Boxing error</a></h1>
<p>Một cách để viết code đơn giản trong khi vẫn giữ lại các lỗi gốc là bằng cách sử dụng <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>. Nhược điểm là lỗi gốc bên dưới chỉ được biết lúc runtime và không được xác định trước (<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">statically determined</a>).</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error;
use std::fmt;

// Change the alias to use `Box&lt;dyn error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "invalid first item to double")
    }
}

impl error::Error for EmptyVec {}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Converts to Box
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Converts to Box
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}</code></pre></pre>
<h2 id="references-14"><a class="header" href="#references-14">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html">Rust by Example</a></li>
<li><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Dynamic dispatch</a></li>
<li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-error"><a class="header" href="#custom-error">Custom error</a></h1>
<p>Một cách khác để <a href="basic/error-handling/./boxing-error.html">boxing errors</a> là wrap chúng vào một kiểu dữ liệu được định nghĩa cụ thể. Cách này hơi mất thời gian nhưng code tường minh, lời khuyên là sử dụng một số thư viện khác thay cho việc tự định nghĩa lỗi một, ví dụ như <a href="https://crates.io/crates/thiserror"><code>thiserror</code></a>, <a href="basic/error-handling/../../crates/anyhow.html"><code>anyhow</code></a>, etc.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error;
use std::error::Error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, "please use a vector with at least one element"),
            // The wrapped error contains additional information and is available
            // via the source() method.
            DoubleError::Parse(..) =&gt;
                write!(f, "the provided string could not be parsed as int"),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    // Here we implicitly use the `ParseIntError` implementation of `From` (which
    // we defined above) in order to create a `DoubleError`.
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("The first doubled is {}", n),
        Err(e) =&gt; {
            println!("Error: {}", e);
            if let Some(source) = e.source() {
                println!("  Caused by: {}", source);
            }
        },
    }
}

fn main() {
    let numbers = vec!["42", "93", "18"];
    let empty = vec![];
    let strings = vec!["tofu", "93", "18"];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}</code></pre></pre>
<h2 id="references-15"><a class="header" href="#references-15">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/wrap_error.html">Rust by Example</a></li>
<li><a href="https://crates.io/keywords/error-handling">Crates for handling errors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viết-tests"><a class="header" href="#viết-tests">Viết Tests</a></h1>
<p>Rust được thiết kế để đưa tính đúng đắn của chương trình lên hàng đầu.
Như bạn đã thấy với những gì mà borrow checkers của compiler hay hệ thống type
đã làm. Nhưng tính đúng đắn thì cực kỳ phức tạp và Rust không thể đảm bảo hết điều này.</p>
<p>Tuy nhiên, testing lại là một kỹ năng phức tạp. Mục tiêu của
phần này mình sẽ không bàn đến việc viết good tests như thế nào,
chúng ta sẽ bàn về những gì mà Rust cung cấp để giúp chúng ta viết tests,
những công cụ, macros, chạy tests, cách tổ chức unit tests
và integration tests.</p>
<h3 id="nội-dung-3"><a class="header" href="#nội-dung-3">Nội dung</a></h3>
<ul>
<li><a href="basic/testing/./test-organization.html">Tổ chức Tests</a>
<ul>
<li><a href="basic/testing/./unit-tests.html">Unit Tests</a></li>
<li><a href="basic/testing/./integration-tests.html">Integration Tests</a></li>
<li><a href="basic/testing/./doc-tests.html">Doc Tests</a></li>
</ul>
</li>
<li><a href="basic/testing/./env-conflict.html">Xung đột biến môi trường</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tổ-chức-tests"><a class="header" href="#tổ-chức-tests">Tổ chức Tests</a></h1>
<p>Testing là một kỹ năng phức tạp. Nhiều lập trình viên sử dụng nhiều thuật ngữ khác nhau
và tổ chức code tests khác nhau. Cộng đồng Rust đặt ra hai loại tests:</p>
<ul>
<li><em>Unit tests</em>: nhỏ và tập trung vào một function, module độc lập tại một thời điểm.</li>
<li><em>Integration tests</em>: tests nằm ngoài thư viện của bạn, sử dụng thư viện của bạn để tests như thể là một chương trình thực tế sẽ thực sự sử dụng. Chỉ test trên public interface và tập trung vào cả 1 module cho một test.</li>
</ul>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>Unit tests được đặt trong thư mục <code>src</code> trong mỗi file code mà bạn đang test.
Có một convention là tạo một module tên <code>tests</code> trong mỗi file chứa function cần test,
annotate module này với attribute <code>#[cfg(test)]</code>.</p>
<h3 id="cfgtest"><a class="header" href="#cfgtest"><code>#[cfg(test)]</code></a></h3>
<p><code>#[cfg(test)]</code> báo cho compiler biết module này được dùng để compile thành test, chỉ được dùng
khi chạy <code>cargo test</code>, không dùng khi <code>cargo build</code>.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Trong module <code>tests</code> có thể sẽ có một vài helper function khác, do đó những function nào
là function test sẽ được đánh dấu là <code>#[test]</code> để compiler nhận biết.</p>
<h3 id="test-private-function"><a class="header" href="#test-private-function">Test private function</a></h3>
<p>Ở ví dụ trên thì public function <code>adder</code> được import vào trong module <code>tests</code> theo đúng rule của Rust.
Vậy còn private function thì sao? Có một cuộc tranh cãi trong cộng đồng về việc này.
Cuối cùng thì Rust cho phép import private function vào <code>tests</code> module.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    adder_internal(a, b)
}

fn adder_internal(a: i32, b: i32) -&gt; i32 {
    a + b
}
 
#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder_internal(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests nằm hoàn toàn bên ngoài thư viện của bạn.
Mục đích của integration tests nhằm kiểm tra các thành phần của
thư viện của bạn hoạt động cùng với nhau có chính xác không.</p>
<p>Để bắt đầu viết integration tests, tạo thư mục <code>tests</code> nằm cùng cấp với <code>src</code>.</p>
<p>Trong thư mục <code>tests</code>, cargo sẽ compile mỗi file thành một thành một crate độc lập.</p>
<p>File: tests/integration_test.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adder;

#[test]
fưn it_adds_two() {
  assert_eq!(4, adder::adder(2, 2));
}
<span class="boring">}</span></code></pre></pre>
<p>Ở đây chúng ta import <code>use adder</code> thay vì <code>use crate::</code>
do file integration test này là một crate độc lập.</p>
<p>Chạy <code>cargo test</code></p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::test_adder ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00sđ
</code></pre>
<p>Do integration tests phải import thư viện để chạy test code, crate bắt buộc phải có <code>src/lib.rs</code>.
Các binary crates không thể test theo cách này.</p>
<p>Do đó các project Rust họ thường tổ chức theo kiểu build binary từ <code>src/main.rs</code> và import trực tiếp logic từ <code>src/lib.rs</code>.</p>
<h4 id="references-16"><a class="header" href="#references-16">References</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#submodules-in-integration-tests">Submodules in Integration Tests</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></li>
</ul>
<h2 id="doc-tests"><a class="header" href="#doc-tests">Doc Tests</a></h2>
<p>Rust cũng hỗ trợ execute code ví dụ trên document như là một test.
Đây là giải pháp cực kỳ thông minh giúp đảm bảo example code luôn up to date
và nó có hoạt động.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Function that adding two number
///
/// # Example
///
/// ```
/// use adder::adder;
/// 
/// assert_eq!(4, adder(2, 2));
/// ```
pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>Khi chạy <code>cargo test</code> hoặc <code>cargo test --doc</code>, cargo sẽ compile
phần example code này thành một crate test và thực thi nó.</p>
<p>Mặc định nếu không chỉ định ngôn ngữ cho block code thì rustdoc sẽ
ngầm định nó là Rust code. Do đó</p>
<pre><code class="language-md">```
let x = 5;
```
</code></pre>
<p>sẽ tương đương với</p>
<pre><code>```rust
let x = 5;
```
</code></pre>
<h3 id="Ẩn-một-phần-của-example-code"><a class="header" href="#Ẩn-một-phần-của-example-code">Ẩn một phần của example code</a></h3>
<p>Đôi lúc bạn sẽ cần example code gọn hơn,
ẩn bớt một số logic mà bạn chuẩn bị để code có thể chạy được,
tránh làm distract của người xem.</p>
<pre><code>/// ```
/// /// Some documentation.
/// # fn foo() {} // this function will be hidden
/// println!("Hello, World!");
/// ```
</code></pre>
<p>Chúng ta thêm <code>#</code> ở phần đầu của dòng code muốn ẩn đi trong generate doc,
nó vẫn sẽ được compile như mình thường.</p>
<h3 id="sử-dụng--trong-doc-tests"><a class="header" href="#sử-dụng--trong-doc-tests">Sử dụng <code>?</code> trong doc tests</a></h3>
<p><code>?</code> chỉ có thể được sử dụng khi function trả về <code>Result&lt;T, E&gt;</code>. Hãy sử dụng cách sau:</p>
<pre><code>/// A doc test using ?
///
/// ```
/// use std::io;
/// fn main() -&gt; io::Result&lt;()&gt; {
///     let mut input = String::new();
///     io::stdin().read_line(&amp;mut input)?;
///     Ok(())
///  }
/// ```
</code></pre>
<p>Cùng với việc sử dụng <code>#</code> như ở trên, chúng ta có thể ẩn đi bớt logic.</p>
<pre><code>/// A doc test using ?
///
/// ```
/// # use std::io;
/// # fn main() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok(())
/// # }
/// ```
</code></pre>
<h3 id="references-17"><a class="header" href="#references-17">References</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h2>
<p>Unit tests được đặt trong thư mục <code>src</code> trong mỗi file code mà bạn đang test.
Có một convention là tạo một module tên <code>tests</code> trong mỗi file chứa function cần test,
annotate module này với attribute <code>#[cfg(test)]</code>.</p>
<h3 id="cfgtest-1"><a class="header" href="#cfgtest-1"><code>#[cfg(test)]</code></a></h3>
<p><code>#[cfg(test)]</code> báo cho compiler biết module này được dùng để compile thành test, chỉ được dùng
khi chạy <code>cargo test</code>, không dùng khi <code>cargo build</code>.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Trong module <code>tests</code> có thể sẽ có một vài helper function khác, do đó những function nào
là function test sẽ được đánh dấu là <code>#[test]</code> để compiler nhận biết.</p>
<h3 id="test-private-function-1"><a class="header" href="#test-private-function-1">Test private function</a></h3>
<p>Ở ví dụ trên thì public function <code>adder</code> được import vào trong module <code>tests</code> theo đúng rule của Rust.
Vậy còn private function thì sao? Có một cuộc tranh cãi trong cộng đồng về việc này.
Cuối cùng thì Rust cho phép import private function vào <code>tests</code> module.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn adder(a: i32, b: i32) -&gt; i32 {
    adder_internal(a, b)
}

fn adder_internal(a: i32, b: i32) -&gt; i32 {
    a + b
}
 
#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_adder() {
    let expected = 4;
    let actual = adder_internal(2, 2);

    assert_eq!(expected, actual);
  }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h2>
<p>Integration tests nằm hoàn toàn bên ngoài thư viện của bạn.
Mục đích của integration tests nhằm kiểm tra các thành phần của
thư viện của bạn hoạt động cùng với nhau có chính xác không.</p>
<p>Để bắt đầu viết integration tests, tạo thư mục <code>tests</code> nằm cùng cấp với <code>src</code>.</p>
<p>Trong thư mục <code>tests</code>, cargo sẽ compile mỗi file thành một thành một crate độc lập.</p>
<p>File: tests/integration_test.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use adder;

#[test]
fưn it_adds_two() {
  assert_eq!(4, adder::adder(2, 2));
}
<span class="boring">}</span></code></pre></pre>
<p>Ở đây chúng ta import <code>use adder</code> thay vì <code>use crate::</code>
do file integration test này là một crate độc lập.</p>
<p>Chạy <code>cargo test</code></p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::test_adder ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00sđ
</code></pre>
<p>Do integration tests phải import thư viện để chạy test code, crate bắt buộc phải có <code>src/lib.rs</code>.
Các binary crates không thể test theo cách này.</p>
<p>Do đó các project Rust họ thường tổ chức theo kiểu build binary từ <code>src/main.rs</code> và import trực tiếp logic từ <code>src/lib.rs</code>.</p>
<h4 id="references-18"><a class="header" href="#references-18">References</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#submodules-in-integration-tests">Submodules in Integration Tests</a></li>
<li><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-tests-1"><a class="header" href="#doc-tests-1">Doc Tests</a></h2>
<p>Rust cũng hỗ trợ execute code ví dụ trên document như là một test.
Đây là giải pháp cực kỳ thông minh giúp đảm bảo example code luôn up to date
và nó có hoạt động.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Function that adding two number
///
/// # Example
///
/// ```
/// use adder::adder;
/// 
/// assert_eq!(4, adder(2, 2));
/// ```
pub fn adder(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>Khi chạy <code>cargo test</code> hoặc <code>cargo test --doc</code>, cargo sẽ compile
phần example code này thành một crate test và thực thi nó.</p>
<p>Mặc định nếu không chỉ định ngôn ngữ cho block code thì rustdoc sẽ
ngầm định nó là Rust code. Do đó</p>
<pre><code class="language-md">```
let x = 5;
```
</code></pre>
<p>sẽ tương đương với</p>
<pre><code>```rust
let x = 5;
```
</code></pre>
<h3 id="Ẩn-một-phần-của-example-code-1"><a class="header" href="#Ẩn-một-phần-của-example-code-1">Ẩn một phần của example code</a></h3>
<p>Đôi lúc bạn sẽ cần example code gọn hơn,
ẩn bớt một số logic mà bạn chuẩn bị để code có thể chạy được,
tránh làm distract của người xem.</p>
<pre><code>/// ```
/// /// Some documentation.
/// # fn foo() {} // this function will be hidden
/// println!("Hello, World!");
/// ```
</code></pre>
<p>Chúng ta thêm <code>#</code> ở phần đầu của dòng code muốn ẩn đi trong generate doc,
nó vẫn sẽ được compile như mình thường.</p>
<h3 id="sử-dụng--trong-doc-tests-1"><a class="header" href="#sử-dụng--trong-doc-tests-1">Sử dụng <code>?</code> trong doc tests</a></h3>
<p><code>?</code> chỉ có thể được sử dụng khi function trả về <code>Result&lt;T, E&gt;</code>. Hãy sử dụng cách sau:</p>
<pre><code>/// A doc test using ?
///
/// ```
/// use std::io;
/// fn main() -&gt; io::Result&lt;()&gt; {
///     let mut input = String::new();
///     io::stdin().read_line(&amp;mut input)?;
///     Ok(())
///  }
/// ```
</code></pre>
<p>Cùng với việc sử dụng <code>#</code> như ở trên, chúng ta có thể ẩn đi bớt logic.</p>
<pre><code>/// A doc test using ?
///
/// ```
/// # use std::io;
/// # fn main() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok(())
/// # }
/// ```
</code></pre>
<h3 id="references-19"><a class="header" href="#references-19">References</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html">https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xung-đột-biến-môi-trường"><a class="header" href="#xung-đột-biến-môi-trường">Xung đột biến môi trường</a></h1>
<p>Các unit tests trong cùng một module được thực thi song song nhau, trong cùng một process.
Một trường hợp mà mình đã gặp phải là xung đột do 2 tests cùng sử dụng một biến môi trường
hoặc biến môi trường ảnh hưởng đến kết quả của tests khác.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

#[test]
fn test_one() {
  env::set_var("KEY", "value_one");
  assert_eq!(env::var("KEY"), Ok("value_one".to_string()));
}

#[test]
fn test_one() {
  env::set_var("KEY", "value_two");
  assert_eq!(env::var("KEY"), Ok("value_two".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<p>Giải pháp ổn nhất hiện tại mình dùng để giải quyết là
<a href="https://docs.rs/serial_test/latest/serial_test/"><code>serial_test</code></a></p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dev-dependencies]
serial_test = "0.9"
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

#[test]
#[serial]
fn test_one() {
  env::set_var("KEY", "value_one");
  assert_eq!(env::var("KEY"), Ok("value_one".to_string()));
}

#[test]
#[serial]
fn test_one() {
  env::set_var("KEY", "value_two");
  assert_eq!(env::var("KEY"), Ok("value_two".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<p>Các tests có <code>#[serial]</code> sẽ được thực hiện tuần tự nhau, tránh trường hợp xung đột như trước.</p>
<h2 id="references-20"><a class="header" href="#references-20">References</a></h2>
<ul>
<li><a href="https://crates.io/crates/serial_test">https://crates.io/crates/serial_test</a></li>
<li><a href="https://docs.rs/serial_test">https://docs.rs/serial_test</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viết-docs"><a class="header" href="#viết-docs">Viết Docs</a></h1>
<p>Rust mặc định được phát hành cùng với một công cụ gọi là <code>rustdoc</code> hay <code>cargo doc</code>.
Giúp generate document cho Rust project.</p>
<h2 id="cơ-bản"><a class="header" href="#cơ-bản">Cơ bản</a></h2>
<p>Thử viết 1 crate đơn giản và document nó:</p>
<pre><code class="language-bash">cargo new duyet_lib --lib
cd duyet_lib
</code></pre>
<p>Trong <code>src/lib.rs</code>, Cargo đã generate sẵn 1 đoạn code, hãy xóa và thay nó bằng:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// foo is a function
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>Bây giờ hãy dùng lệnh sau để generate document và xem nó trên trình duyệt:</p>
<pre><code class="language-bash">cargo doc --open
</code></pre>
<p><code>rustdoc</code> đọc mọi comment <code>///</code>, <code>//!</code> và generate document theo cấu trúc của project.
Nôi dung của document được viết bằng Markdown.</p>
<p>Hãy xem trang <a href="basic/rustdoc/../code-comment/README.html">viết comment sao cho đúng</a>
và <a href="basic/rustdoc/../code-comment/doc-comment.html">Doc comments</a>
để biết thêm về cách viết comment doc sao cho chuẩn.</p>
<h2 id="references-21"><a class="header" href="#references-21">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">What is rustdoc?</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">How to write documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sử-dụng-readmemd-làm-crate-document"><a class="header" href="#sử-dụng-readmemd-làm-crate-document">Sử dụng README.md làm crate document</a></h1>
<p>Nội dung comment dưới đây trong <code>src/lib.rs</code> được gọi là crate document,
được render thành nội dung trong trang chủ doc của library.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! This is crate document
//!
//! # Usage
//!
//! ```
//! [dependencies]
//! duyet_lib = "0.9"
//! ```
//! ...
<span class="boring">}</span></code></pre></pre>
<p>Và nội dung này cũng thường sẽ giống với <code>README.md</code> để hiển thị trên Github.
Một cách để tránh lặp lại nội dung và đồng bộ với nhau là <code>rustdoc</code> render trực tiếp
nội dung từ <code>README.md</code>.</p>
<p>File: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[doc = include_str!("../README.md")]
<span class="boring">}</span></code></pre></pre>
<p>File: README.md</p>
<pre><code class="language-markdown">This is crate document

# Usage

```
[dependencies]
duyet_lib = "0.9"
```
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p><em>Con trỏ</em> (pointer) là một khái niệm chung cho một biến chứa một địa chỉ trong bộ nhớ. Địa chỉ này tham chiếu đến (reference), hoặc "trỏ đến" ("points at"), một số dữ liệu khác.</p>
<p>Loại pointer phổ biến nhất trong Rust là reference, được biểu thị bằng ký hiệu <code>&amp;</code> và mượn giá trị chúng trỏ đến. Chúng không có bất kỳ khả năng đặc biệt nào ngoài việc tham chiếu đến dữ liệu, không tốn bất kỳ chi phí (overhead) nào.</p>
<p><em>Smart pointers</em> là các <strong>kiểu dữ liệu</strong> hoạt động như một con trỏ nhưng có thêm metadata và method. Khái niệm về smart pointers không phải là đặc thù riêng của Rust: smart pointers xuất phát từ C++ và tồn tại trong các ngôn ngữ khác nữa.</p>
<p>Rust có nhiều loại Smart Pointers được định nghĩa trong standard library. Khác với reference, Smart Pointers <strong>sở hữu (own)</strong> luôn dữ liệu, bạn sẽ thường thấy smart pointers có kiểu <code>Rc&lt;T&gt;</code>, <code>Box&lt;T&gt;</code> với <code>T</code> là kiểu dữ liệu gốc nó chứa bên trong.</p>
<p>Để khám phá khái niệm chung, chúng ta sẽ xem xét một số ví dụ khác nhau của smart points, chẳng hạn như</p>
<ul>
<li><em>Reference counting</em> (<a href="advanced/smart-pointer/./rc.html"><code>Rc&lt;T&gt;</code></a>): loại con trỏ này cho phép dữ liệu có nhiều owner bằng cách theo dõi số lượng owner và, khi không còn owner nào nữa, clean up giá trị đó.</li>
<li><a href="advanced/smart-pointer/./box.html"><code>Box&lt;T&gt;</code></a> allocation giá trị trên heap.</li>
<li><a href="advanced/smart-pointer/./ref.html"><code>Ref&lt;T&gt;</code></a> và <a href="advanced/smart-pointer/./refmut.html"><code>RefMut&lt;T&gt;</code></a> cho phép kiểu được borrow lúc runtime thay vì compile time.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h1>
<p>Tất cả giá trị trên Rust mặc định đều được allocated trên stack. Giá trị có thể được <em>boxed</em>, allocated trên heap bằng cách sử dụng <code>Box&lt;T&gt;</code>.
<code>Box&lt;T&gt;</code> là một smart pointer của Rust cho phép allocated trên heap giá trị có kiểu <code>T</code>, còn pointer trỏ đến giá trị đó sẽ nằm trên stack.
<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">Xem thêm về stack và heap tại đây</a>.</p>
<p>Khi một Box nằm ngoài scope, destructor sẽ được gọi để giải phóng bộ nhớ.
Sử dụng Box không ảnh hưởng nhiều đến performance do Box không bổ sung thêm thông tin metadata nào khác.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
  let b = Box::new(5);
  println!("b = {}", b);
}</code></pre></pre>
<p>Ở ví dụ trên, chúng ta định nghĩa <code>b</code> có giá trị của <code>Box</code> đang trỏ đến giá trị <code>5</code> và <code>5</code> đang được allocated trên heap. Chương trình sẽ in ra <code>b = 5</code> , cách truy cập giống hệt cách allocated trên stack. Giống như owned value, khi box out of scope, cuối hàm <code>main</code> sẽ được giải phóng.</p>
<p>Lưu một giá trị đơn giản trên Box không mang lại lợi ích gì cả. Chúng ta sẽ thường dùng Box trong các trường hợp sau:</p>
<ol>
<li>Khi bạn có một type mà không biết trước size ở compile time, và bạn cần sử dụng type đó trong một số ngữ cảnh cần biết trước chính xác data size (ví dụ như <em>recursive type)</em>.</li>
<li>Bạn cần xử lý các kiểu dữ liệu nhưng chỉ muốn quan tâm đến type đó được implement trait nào.</li>
<li>Khi bạn có một lượng lớn data cần transfer ownership nhưng muốn chắc là data sẽ không bị copy, sẽ ảnh hưởng đến hiệu năng và làm tăng bộ nhớ.</li>
</ol>
<p>Chúng ta sẽ làm rõ ngay sau đây.</p>
<h2 id="1-recursive-types-với-box"><a class="header" href="#1-recursive-types-với-box">1. Recursive types với <code>Box</code></a></h2>
<p>Tại compile time, Rust cần biết cần phải biết cần bao nhiêu bộ nhớ. Một trong những kiểu dữ liệu mà Rust không biết trước được size là <em>recursive type.</em> Giá trị có thể là một phần của giá trị khác có cùng một kiểu. Bởi vì nesting of values theo lý thuyết có thể kéo dài đến vô hạn. Trong trường hợp này ta có thể dùng <code>Box</code>.</p>
<p><a href="https://en.wikipedia.org/wiki/Cons">Cons list</a> là một kiểu dữ liệu phổ biến trong các ngôn ngữ functional programming,
là một ví dụ của recursive type. Cons là viết tắt của <em>"construct function"</em>.
Mỗi item trong cons list có 2 thành phần: giá trị của item hiện tại và next item.
Item cuối cùng có giá trị Nil và không có next item.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
  Cons(i32, List),
  Nil,
}
<span class="boring">}</span></code></pre></pre>
<p>Bây giờ hãy sử dụng <code>List</code> type để lưu list <code>1, 2, 3</code> như sau</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum List {
  Cons(i32, List),
  Nil,
}

use List::{Cons, Nil};

fn main() {
  let list = Cons(1, Cons(2, Cons(3, Nil)));
}</code></pre></pre>
<p>Nếu chúng ta compile đoạn code trên, compiler sẽ báo như sau:</p>
<pre><code class="language-bash">$ cargo run
   Compiling cons-list v0.1.0 (file:///duyet/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

error[E0391]: cycle detected when computing drop-check constraints for `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which immediately requires computing drop-check constraints for `List` again
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing }, value: List } }`

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to 2 previous errors
</code></pre>
<p>Compiler nói rằng kiểu dữ liệu này <em>has infinite size.</em> Bởi vì <code>List</code> có variant là <code>List::Cons</code> chứa trực tiếp một <code>List</code> khác trong chính nó. Do đó Rust sẽ không biết được sẽ cần bao nhiêu bộ nhớ để lưu giá trị của <code>List</code>.</p>
<p>Dừng lại một chút để xem Rust tính toán bộ nhớ của một kiểu dữ liệu bình thường như thế nào:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
<span class="boring">}</span></code></pre></pre>
<p>Để xác định bao nhiêu bộ nhớ cần để allocate cho <code>Message</code>, Rust sẽ kiểm tra từng variant (biến thể của enum) để xem variant nào cần bộ nhớ nhiều nhất. Rust thấy rằng <code>Message::Quit</code> không cần, <code>Message::Move</code> phải cần ít nhất bộ nhớ để lưu hai giá trị <code>i32</code>. Tương tự với các variant còn lại. Bởi vì một thời điểm cho có một variant được sử dụng, do đó bộ nhớ tối đa mà <code>Message</code> cần sẽ là một nhớ cần để lưu trữ variant lớn nhất.</p>
<p>Quay lại với Cons List, bộ nhớ mà Rust tính toán được có thể đến vô tận.</p>
<p><img src="advanced/smart-pointer/./box-cons.svg" alt="" /></p>
<p>Theo như gợi ý của compiler, chúng ta có thể sử dụng <code>Box&lt;T&gt;</code> để có một Recursive Type với một kích thước bộ nhớ xác định:</p>
<pre><code class="language-bash">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>Bởi vì <code>Box&lt;T&gt;</code> là một pointer, Rust luôn biết chính xác bao nhiêu bộ nhớ mà một <code>Box&lt;T&gt;</code> <strong>pointer</strong> cần.</p>
<p><img src="advanced/smart-pointer/./box-cons-box.png" alt="" /></p>
<p>Chương trình của chúng ta lúc này sẽ là:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">enum List {
  Cons(i32, Box&lt;List&gt;),
  Nil,
}

use List::{Cons, Nil};

fn main() {
  let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<h2 id="2-sử-dụng-trait-objects-cho-phép-sử-dụng-giá-trị-từ-nhiều-kiểu-dữ-liệu-khác-nhau"><a class="header" href="#2-sử-dụng-trait-objects-cho-phép-sử-dụng-giá-trị-từ-nhiều-kiểu-dữ-liệu-khác-nhau">2. Sử dụng <em>trait objects</em> cho phép sử dụng giá trị từ nhiều kiểu dữ liệu khác nhau</a></h2>
<p>Một giới hạn của <code>Vec</code> là chỉ có thể lưu trữ các thành phần có kiểu dữ liệu giống nhau mà thôi. Ta có thể lách luật trong một số trường hợp bằng cách sử dụng enum có nhiều variant giữ nhiều kiểu dữ liệu khác nhau</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Cell {
  Int(i32),
  Float(f64),
  Text(String),
}

let row = vec![
  Cell::Int(3),
  Cell::Text(String::from("blue")),
  Cell::Float(10.12),
];
<span class="boring">}</span></code></pre></pre>
<p>Tuy nhiên, trong một số trường hợp mong muốn thư viện của chúng ta có thể dễ dàng được mở rộng một số trường hợp khác. Chúng ta đã biết được định nghĩa Trait cho các Common Behavior. Trong Rust, trait định nghĩa các hành vi, và các hành vi này có thể được <code>impl</code> cho struct hoặc enum, để giúp một struct hoặc enum mang đặc tính các hành vi đó.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
  fn draw(&amp;self);
}

pub struct Screen {
  pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}

impl Screen {
  pub fn run(&amp;self) {
    for component in self.components.iter() {
      component.draw();
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Hãy xem ví dụ trên, ta có <code>components</code> có kiểu dữ liệu là <code>Vec&lt;T&gt;</code> với <code>&lt;T&gt;</code> là một <code>Box&lt;dyn Draw&gt;</code>. Chúng ta đã định nghĩa một vector chứa kiểu dữ liệu là một <em>trait object</em>.</p>
<p>Một <em>trait object</em> được định nghĩa bằng cách định nghĩa pointer, ví dụ như <code>&amp;dyn T</code> hoặc <code>Box&lt;dyn T&gt;</code> smart pointer.</p>
<p>Một <em>trait object</em> sẽ trỏ đến:</p>
<ul>
<li>một instance của một kiểu dữ liệu có implement trait của chúng ta</li>
<li>và một bảng ghi look up đến các trait methods lúc runtime.</li>
</ul>
<p>Sử dụng trait object, Rust type system sẽ chắc chắn là tại thời điểm compile, tất cả các giá trị sử dụng tại ngữ cảnh đó đều phải được implement trai của <em>trait object</em> đó. Nói tóm lại, chúng ta sẽ không cần quan tâm đó là kiểu dữ liệu gì, chỉ cần biết kiểu dữ liệu đó phải được implement <em>trait</em> chúng ta cần là được.</p>
<p>Lý do cần sử dụng pointer reference <code>&amp;</code> hoặc smart pointer <code>Box&lt;T&gt;</code> bởi vì compiler không biết chính xác về kiểu dữ liệu, Rust sẽ dùng pointer của trait object để biết được method nào để cần được gọi. Xem thêm về <strong><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a>.</strong></p>
<h2 id="references-22"><a class="header" href="#references-22">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch15-01-box.html">Using Box<T> to Point to Data on the Heap</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/std/box.html#box-stack-and-heap">Box, stack and heap - Rust By Example</a></li>
<li><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">Using Trait Objects That Allow for Values of Different Types</a></li>
<li><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html">Advanced Types - The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">The Stack and the Heap</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rct-reference-counted"><a class="header" href="#rct-reference-counted">Rc&lt;T&gt;, Reference Counted</a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> cung cấp giá trị shared ownership của một giá trị kiểu <code>T</code>, được cấp phát trên heap. Nếu ta gọi <code>.clone()</code> trên <code>Rc</code> tạo ra một con trỏ mới đến cùng một phần cấp phát trên heap.</p>
<p>Về lý thuyết <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> cho phép chúng ta có nhiều "owner" pointer cho cùng một giá trị, thường là giá trị có kích thước lớn.</p>
<p>Về kỹ thuật, <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> chứa một bộ counter, tự động tăng mỗi khi <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> được clone và giảm khi giá trị giữ con bỏ bị huỷ hoặc out of scope.  Khi con trỏ <code>Rc</code> cuối cùng đến allocation thì con trỏ tự động bị huỷ (destroyed), giá trị được lưu trữ trong phần cấp phát đó (thường được gọi là “inner value”) cũng sẽ bị hủy.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let rc = Rc::new(vec![1.0, 2.0, 3.0]);

// Method-call syntax
let rc2 = rc.clone();
<span class="boring">}</span></code></pre></pre>
<p>Shared references trong Rust mặc định không cho phép mutation, Rc cũng thế. Nếu muốn chúng ta phải đặt <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html" title="struct std::cell::Cell"><code>Cell</code></a> hoặc <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" title="struct std::cell::RefCell"><code>RefCell</code></a> bên trong <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" title="struct std::rc::Rc"><code>Rc</code></a>, xem <a href="https://doc.rust-lang.org/std/cell/index.html#introducing-mutability-inside-of-something-immutable">ví dụ</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::rc::Rc;

struct Data {
    name: String,
    // ...other fields
}

fn main() {
    // Create a reference-counted `Owner`.
    let p1: Rc&lt;Data&gt; = Rc::new(
        Data {
            name: "Duyet".to_string(),
        }
    );

	let p2 = p1.clone();
	let p3 = p1.clone();

	// Drop p1
	drop(p1);

	// Mặc dù đã drop p1 nhưng chúng ta vẫn có thể truy cập đến
	// các giá trị của p2 và p3. Bởi p1 là Rc&lt;Data&gt; tức chỉ chứa
	// con trỏ đến Data. Data sẽ chỉ bị drop sau khi không còn con
	// trỏ nào đến nó nữa.
	println!("p2 {}", p2.name);
    println!("p3 {}", p3.name);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cow---clone-on-write-smart-pointer"><a class="header" href="#cow---clone-on-write-smart-pointer"><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> - clone-on-write smart pointer</a></h1>
<p><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> là một smart pointer enum cực kỳ tiện dụng, được định nghĩa là "clone on write".
Nó sẽ trả về <code>&amp;str</code> nếu bạn không cần một <code>String</code>, hoặc trả về một
<code>String</code> nếu bạn cần <code>String</code>. Tương tự với array <code>&amp;[]</code> và <code>Vec</code>, v.v.</p>
<p>Đây là định nghĩa của <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Cow&lt;'a, B&gt;
where
    B: 'a + ToOwned + ?Sized,
 {
    Borrowed(&amp;'a B),
    Owned(&lt;B as ToOwned&gt;::Owned),
}
<span class="boring">}</span></code></pre></pre>
<p>Hãy phân tích <code>B</code>:</p>
<p><code>'a</code> có nghĩa là <code>Cow</code> làm việc được với references.</p>
<p>Trait <code>ToOwned</code> có nghĩa type này có thể convert thành owned type.
Ví dụ, <code>str</code> thường là một reference (<code>&amp;str</code>) hoặc bạn có thể convert nó thành owned <code>String</code>.</p>
<p><code>?Sized</code>, có nghĩa là có thể có <code>Sized</code> hoặc là không.
Hầu hết mọi type trong Rust đều là <code>Sized</code>, nhưng type như là <code>str</code> thì không.
Vì thế chúng ta cần <code>&amp;</code> cho <code>str</code>, bởi vì compiler không biết kích thước của <code>str</code>.
Nếu bạn cần một trait có thể sử dụng giá trị nào tương tư như <code>str</code>, bạn thêm <code>?Sized</code>.</p>
<p>Tiếp theo là <code>enum</code> variant: một giá trị <code>Cow</code> có thể là <code>Borrowed</code> hoặc <code>Owned</code>.</p>
<p>Ví dụ bạn có một function trả về giá trị <code>Cow&lt;'static, str&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_function() -&gt; Cow&lt;'static, str&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Nếu bạn yêu cầu function đó trả về <code>"My message".into()</code>,
nó sẽ xem <code>"My message"</code> là một <code>str</code>. Đây là một <code>Borrowed</code> type,
do đó variant sẽ là <code>Cow::Borrowed(&amp;'static str)</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_function() -&gt; Cow&lt;'static, str&gt; {
    "My message".into()
}
<span class="boring">}</span></code></pre></pre>
<p>Còn nếu bạn trả về</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cow_function() -&gt; Cow&lt;'static, str&gt; {
    format!("{}", "My message").into()
}
<span class="boring">}</span></code></pre></pre>
<p>lúc này kết quả trả về sẽ là <code>String</code>, bởi vì <code>format!()</code> trả về <code>String</code>.
Variant sẽ là <code>Cow::Owned</code>.</p>
<h2 id="lợi-ích-của-cow"><a class="header" href="#lợi-ích-của-cow">Lợi ích của <code>Cow</code></a></h2>
<p><em>Copy on write</em> là một kỹ thuật giúp tối ưu hoá, nhất là trong các
trường hợp reading nhiều hơn writing. Ý tưởng chính là không copy
object ngay lập tức, mà chỉ reference (borrow) đến object gốc, khi cần
một lượng lớn tác vụ reading. Và chỉ khi cần đến tác vụ writing (ít xảy ra hơn),
object mới được copy và thay đổi. Tác vụ để thay đổi giá trị object sẽ copy, di chuyển
object trong bộ nhớ là một tác vụ nặng, tốn kém. Do đó, ưu điểm của kỹ thuật này là
các tác vụ reading object rất nhanh do chỉ sử dụng reference (borrow) đến giá trị gốc.</p>
<h2 id="references-23"><a class="header" href="#references-23">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">https://doc.rust-lang.org/std/borrow/enum.Cow.html</a></li>
<li><a href="https://github.com/Dhghomon/easy_rust#cow">https://github.com/Dhghomon/easy_rust#cow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reft"><a class="header" href="#reft"><code>Ref&lt;T&gt;</code></a></h1>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{RefCell, Ref};

let c = RefCell::new((5, 'b'));
let b1: Ref&lt;'_, (u32, char)&gt; = c.borrow();
let b2: Ref&lt;'_, u32&gt; = Ref::map(b1, |t| &amp;t.0);
assert_eq!(*b2, 5)
<span class="boring">}</span></code></pre></pre>
<p>https://doc.rust-lang.org/std/cell/struct.Ref.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refmutt"><a class="header" href="#refmutt"><code>RefMut&lt;T&gt;</code></a></h1>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{RefCell, RefMut};

let c = RefCell::new((5, 'b'));
{
    let b1: RefMut&lt;'_, (u32, char)&gt; = c.borrow_mut();
    let mut b2: RefMut&lt;'_, u32&gt; = RefMut::map(b1, |t| &amp;mut t.0);
    assert_eq!(*b2, 5);
    *b2 = 42;
}
assert_eq!(*c.borrow(), (42, 'b'));
<span class="boring">}</span></code></pre></pre>
<p>https://doc.rust-lang.org/std/cell/struct.RefMut.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingt"><a class="header" href="#saturatingt"><code>Saturating&lt;T&gt;</code></a></h1>
<p>Khi nhìn vào ví dụ này, khi cộng (<code>+</code>) hoặc trừ (<code>-</code>) hai số unsigned <code>u8</code> có thể dẫn đến tràn số (overflow) <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c62ff328d54f469ee00bb87dcd5aeaee">(playground)</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("{:?}", 10_u8 - 20_u8);
}</code></pre></pre>
<pre><code>--&gt; src/main.rs:2:22
  |
2 |     println!("{:?}", 10_u8 - 20_u8);
  |                      ^^^^^^^^^^^^^ attempt to compute `10_u8 - 20_u8`, which would overflow
</code></pre>
<p>Tương tự, nếu ta cố gắng cộng hai <code>int</code>, điều này cũng có thể gây ra lỗi tương tự. Ví dụ <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=44b339ddf71420cbe307bb0639be32cf">(playground)</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("{:?}", i32::MAX + 1);
}</code></pre></pre>
<pre><code>--&gt; src/main.rs:2:22
  |
2 |     println!("{:?}", i32::MAX + 1);
  |                      ^^^^^^^^^^^^ attempt to compute `i32::MAX + 1_i32`, which would overflow
</code></pre>
<p><a href="https://doc.rust-lang.org/std/num/struct.Saturating.html"><code>Saturating&lt;T&gt;</code></a> là một bọc toán học với chức năng bão hòa. Các phép toán như <code>+</code> trên các giá trị <code>u32</code> được thiết kế để không bao giờ tràn số, và trong một số cấu hình debug, tràn số được phát hiện và dẫn đến một sự cố. Trong khi hầu hết các phép toán thuộc loại này, một số mã cụ thể mong muốn và phụ thuộc vào toán học bão hòa.</p>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ac1050dae945a7a9d7333f8539fda6f9">playground</a>)</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::num::Saturating;

fn main() {
	let a = Saturating(10_u8);
	let b = Saturating(20_u8);

    println!("{:?}", a - b); // 0

	// Giá trịgốc có thể được truy xuất thông qua `.0`
	let res = (a - b).0;    // 0
}</code></pre></pre>
<p>Một ví dụ khác là cố gắng <code>+</code> gây tràn số khi giá trị kết quả lớn hơn <strong>giá trị tối đa</strong> của kiểu dữ liệu số đó (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ab0d99413f36d53839569f314b0aa1c9">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::num::Saturating;

fn main() {
	let max = Saturating(u32::MAX);
	let one = Saturating(1u32);
	
	assert_eq!(u32::MAX, (max + one).0);
}</code></pre></pre>
<h3 id="một-số-methods-hữu-ích-khác"><a class="header" href="#một-số-methods-hữu-ích-khác">Một số methods hữu ích khác</a></h3>
<p><code>Saturating&lt;T&gt;::MIN</code> và <code>Saturating&lt;T&gt;::MAX</code> trả về giá trị nhỏ nhất và lớn nhất có thể được biểu diễn bởi kiểu số nguyên này:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::Saturating;

assert_eq!(&lt;Saturating&lt;usize&gt;&gt;::MIN, Saturating(usize::MIN));
assert_eq!(&lt;Saturating&lt;usize&gt;&gt;::MAX, Saturating(usize::MAX));
<span class="boring">}</span></code></pre></pre>
<p><code>pow</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::Saturating;

assert_eq!(Saturating(3usize).pow(4), Saturating(81));
assert_eq!(Saturating(3i8).pow(5), Saturating(127));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavioural-patterns"><a class="header" href="#behavioural-patterns">Behavioural Patterns</a></h1>
<p>Theo Wikipedia:</p>
<blockquote>
<p>Behavioural Patterns: Design patterns that identify common communication patterns among objects. By doing so, these patterns increase flexibility in carrying out communication.</p>
</blockquote>
<p>Một số Behavioural Patterns trong Rust</p>
<ul>
<li><a href="design-pattern/behavioural/./strategy.html">Strategy Pattern</a></li>
<li><a href="design-pattern/behavioural/./command.html">Command Pattern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy design pattern</a> 
là một technique nhằm mục đích phân tách nhiều vấn đề,
tách software modules thông qua <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion</a>.</p>
<p>Ý tưởng cơ bản của Strategy pattern là chỉ cần define skeleton
ở abstract level, chúng ta tách biệt phần implementation của
logic thành nhiều phần. Client sử dụng có thể tự implement
1 số method theo cách riêng của nó nhưng vẫn giữ được cấu trúc
của logic workflow gốc.</p>
<p>Abstract class không không phụ thuộc vào implementation của lớp dẫn xuất (derived class),
nhưng implementation của lớp dẫn xuất phải tuân thủ theo đặc tả của lớp abstract.
Cho nên chúng có tên gọi là <strong>Dependency Inversion</strong>.</p>
<p>Một thứ mình thấy rõ là các project Rust rất hay sử dụng Strategy Design Pattern này.</p>
<p>Ví dụ, chúng ta có 1 <code>struct Data</code> và implement một số phương thức để generate ra
nhiều dạng format khác nhau (ví dụ <code>JSON</code>, <code>YAML</code>, <code>Plain Text</code>, ...).
Ta gọi mỗi format ở đây là một strategy.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

type Data = HashMap&lt;String, u32&gt;;

impl Data {
  fn generate(&amp;self, format: &amp;str) {
    match format {
      "json" =&gt; { ... }
      "yaml" =&gt; { ... }
      "text" =&gt; { ... }
      _      =&gt; { ... }
    }
  }
}</code></pre></pre>
<p>Mọi thứ thay đổi theo thời gian, và khó đoán được trong tương lai chương trình
của chúng ta có thể sửa đổi hoặc bổ sung thêm các loại format nào nữa
trong tương lai hay không (ví dụ <code>JSONLine</code>, <code>CSV</code>, <code>Parquet</code>, ...)</p>
<p>Nếu thiết kế sử dụng Strategy Pattern:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::collections::HashMap;

// Data
type Data = HashMap&lt;String, u32&gt;;
impl Data {
  // f: T chap nhan moi struct co impl Formatter
  fn generate&lt;T: Formatter&gt;(f: T) -&gt; String {
    f.format(&amp;self)
  }
}

// Formatter
trait Formatter {
  fn format(&amp;self, data: &amp;Data) -&gt; String;
}

// Formatter -&gt; Json
struct Json;
impl Formatter for Json {
  fn format(&amp;self, data: &amp;Data) -&gt; String {
    // res = { "a": 1, "b": 2. /// }
    res
  }
}

// Formatter -&gt; Text
struct Text;
impl Formatter for Text {
  fn format(&amp;self, data: &amp;Data) -&gt; String {
    // res = "a = 1, b = 2, ..."
    res
  }
}

fn main() {
  let mut data = Data::new();
  data.insert("a".to_string(), 1);
  data.insert("b".to_string(), 2);

  let s = data.generate(Text);
  assert!(s.contains("a = b, b = 2"));

  let s = data.generate(Json);
  assert!(s.contains(r#"{"a":1, "b":2}"#));
}</code></pre></pre>
<p>Theo chúng ta có thể thấy, <code>Data::generate</code> có thể không cần quan tâm implementation
của <code>f: T</code>. Chỉ cần biết nó là một dẫn xuất của <code>trait Formatter</code> và có method <code>format</code>.</p>
<p><strong>Nhược điểm</strong> là mỗi strategy cần được implement ít nhất một module,
vì thế số lượng module có thể tăng cùng với số lượng strategy.
Có quá nhiều strategy đòi hỏi user phải biết sự khác nhau giữa các strategy để sử dụng.</p>
<p><strong>Ưu điểm</strong> là chúng ta có thể tách việc xử lý <code>Json</code>, <code>Text</code>, ... ra thành nhiều bài toán (strategy) nhỏ hơn theo như ví dụ trên.</p>
<p>Ở ví dụ trên các strategy được đặt chung ở một file,
thực tế người ta thưởng đặt ở nhiều module khác nhau hoặc mỗi strategy một file
(<code>formatter::json</code>, <code>formatter::csv</code>, ...). Việc tách này còn cho phép sử dụng compiler feature flags.</p>
<p>Còn nếu chúng ta đang implement một <code>crate</code>, thì <code>crate</code> ở ví dụ trên user có thể dễ dàng custom một <code>Formatter</code> mới:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use crate::example::{Data, Formatter};

struct CustomFormatter;

impl Formatter for CustomFormatter {
  fn format(&amp;self, data: &amp;Data) -&gt; String {
    ...
  }
}</code></pre></pre>
<p><code>serde</code> là một ví dụ hay của <code>Strategy</code> pattern, serde cho phép
<a href="https://serde.rs/custom-serialization.html">full customization</a> serialization
behavior bằng cách implement <code>Serialize</code> và <code>Deserialize</code> traits cho kiểu dữ liệu riêng của chúng ta.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h1>
<p>Ý tưởng cơ bản của <a href="https://en.wikipedia.org/wiki/Command_pattern">Command Pattern</a>
là tách các actions thành các object riêng và gọi chúng thông qua parameters.</p>
<h1 id="khi-nào-dùng"><a class="header" href="#khi-nào-dùng">Khi nào dùng</a></h1>
<p>Giả sử ta có một chuỗi các actions hoặc transactions.
Chúng ta muốn các actions hoặc commands được thực thi theo thứ tự khác nhau.
Các commands có thể được trigger bởi kết quả của một event nào đó.
Ví dụ, khi user nhấn 1 nút, hoặc khi nhận được 1 data event nào đó.
Ngoài ra thì các commands này có thể khôi phục (undo).
Ví dụ như ta store các chuỗi thực thi (executed) của các commands,
khi hệ thống gặp vấn đề ta có thể phục hồi lại bằng cách chạy lại từng commands một.</p>
<h1 id="ví-dụ"><a class="header" href="#ví-dụ">Ví dụ</a></h1>
<p>Ta define hai database operations <code>create table</code> và <code>add field</code>.
Mỗi operation là một command. Các command này có thể undo được, ví dụ <code>drop table</code>, <code>drop field</code>.</p>
<p>Khi user invoke database migration, mỗi command được thực thi theo thứ tự,
khi user muốn rollback, tất cả command được undo theo thứ tự ngược lại.</p>
<h1 id="cách-1-sử-dụng-trait-objects"><a class="header" href="#cách-1-sử-dụng-trait-objects">Cách 1: sử dụng trait objects</a></h1>
<p>Chúng ta định nghĩa một common trait cho command
với hai operation là <code>exec</code> và <code>rollback</code>.
Các struct command phải được implement trait này.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub trait Migration {
  fn execute(&amp;self) -&gt; &amp;str;
  fn rollback(&amp;self) -&gt; &amp;str;
}

pub struct CreateTable;
impl Migration for CreateTable {
  fn execute(&amp;self) -&gt; &amp;str {
    "create table"
  }
  fn rollback(&amp;self) -&gt; &amp;str {
    "drop table"
  }
}

pub struct AddField;
impl Migration for AddField {
  fn execute(&amp;self) -&gt; &amp;str {
    "add field"
  }
  fn rollback(&amp;self) -&gt; &amp;str {
    "remove field"
  }
}

struct Schema {
  commands: Vec&lt;Box&lt;dyn Migration&gt;&gt;,
}

impl Schema {
  fn new() -&gt; Self {
    Self { commands: vec![] }
  }

  fn add_migration(&amp;mut self, cmd: Box&lt;dyn Migration&gt;) {
    self.commands.push(cmd);
  }

  fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.commands.iter().map(|cmd| cmd.execute()).collect()
  }
  fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.commands
      .iter()
      .rev() // reverse iterator's direction
      .map(|cmd| cmd.rollback())
      .collect()
  }
}

fn main() {
  let mut schema = Schema::new();

  let cmd = Box::new(CreateTable);
  schema.add_migration(cmd);
  let cmd = Box::new(AddField);
  schema.add_migration(cmd);

  assert_eq!(vec!["create table", "add field"], schema.execute());
  assert_eq!(vec!["remove field", "drop table"], schema.rollback());
}</code></pre></pre>
<h1 id="cách-2-sử-dụng-function-pointers"><a class="header" href="#cách-2-sử-dụng-function-pointers">Cách 2: sử dụng function pointers</a></h1>
<p>Chúng ta có thể thực hiện theo một cách khác là tách mỗi
command thành một function và lưu lại function pointer để thực thi sau.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">type FnPtr = fn() -&gt; String;

struct Command {
  execute: FnPtr,
  rollback: FnPtr,
}

struct Schema {
  commands: Vec&lt;Command&gt;,
}

impl Schema {
  fn new() -&gt; Self {
    Self { commands: vec![] }
  }
  fn add_migration(&amp;mut self, execute: FnPtr, rollback: FnPtr) {
    self.commands.push(Command { execute, rollback });
  }
  fn execute(&amp;self) -&gt; Vec&lt;String&gt; {
    self.commands.iter().map(|cmd| (cmd.execute)()).collect()
  }
  fn rollback(&amp;self) -&gt; Vec&lt;String&gt; {
    self.commands
      .iter()
      .rev()
      .map(|cmd| (cmd.rollback)())
      .collect()
  }
}

fn add_field() -&gt; String {
  "add field".to_string()
}

fn remove_field() -&gt; String {
  "remove field".to_string()
}

fn main() {
  let mut schema = Schema::new();
  schema.add_migration(|| "create table".to_string(), || "drop table".to_string());
  schema.add_migration(add_field, remove_field);

  assert_eq!(vec!["create table", "add field"], schema.execute());
  assert_eq!(vec!["remove field", "drop table"], schema.rollback());
}</code></pre></pre>
<h1 id="cách-3-sử-dụng-fn-trait-objects"><a class="header" href="#cách-3-sử-dụng-fn-trait-objects">Cách 3: sử dụng <code>Fn</code> trait objects</a></h1>
<p>Thay vì định nghĩa một command trait theo cách 1,
ta có thể lưu tất cả command được implement <code>trait Fn</code> trong một vector.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">type Migration&lt;'a&gt; = Box&lt;dyn Fn() -&gt; &amp;'a str&gt;;

struct Schema&lt;'a&gt; {
  executes: Vec&lt;Migration&lt;'a&gt;&gt;,
  rollbacks: Vec&lt;Migration&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; Schema&lt;'a&gt; {
  fn new() -&gt; Self {
    Self {
        executes: vec![],
        rollbacks: vec![],
    }
  }

  fn add_migration&lt;E, R&gt;(&amp;mut self, execute: E, rollback: R)
  where
    E: Fn() -&gt; &amp;'a str + 'static,
    R: Fn() -&gt; &amp;'a str + 'static,
  {
    self.executes.push(Box::new(execute));
    self.rollbacks.push(Box::new(rollback));
  }

  fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.executes.iter().map(|cmd| cmd()).collect()
  }

  fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
    self.rollbacks.iter().rev().map(|cmd| cmd()).collect()
  }
}

fn add_field() -&gt; &amp;'static str {
  "add field"
}

fn remove_field() -&gt; &amp;'static str {
  "remove field"
}

fn main() {
  let mut schema = Schema::new();
  schema.add_migration(|| "create table", || "drop table");
  schema.add_migration(add_field, remove_field);

  assert_eq!(vec!["create table", "add field"], schema.execute());
  assert_eq!(vec!["remove field", "drop table"], schema.rollback());
}</code></pre></pre>
<h1 id="thảo-luận"><a class="header" href="#thảo-luận">Thảo luận</a></h1>
<p>Trong các ví dụ trên thì command của chúng ta khá nhỏ,
nên thường được define dưới dạng function hoặc closure
rồi bỏ thẳng function pointer vào Vec, rồi thực thi theo thứ tự.
Trong thực tế các command có thể phức tạp hơn,
có thể là một struct với hàng loạt các function và variable
trong các module khác nhau, việc sử dụng <code>trait</code> và <code>Box</code> ở cách 1 sẽ hiệu quả hơn.</p>
<h1 id="references-24"><a class="header" href="#references-24">References</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Command_pattern">https://en.wikipedia.org/wiki/Command_pattern</a></li>
<li><a href="https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust">https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creational-patterns"><a class="header" href="#creational-patterns">Creational Patterns</a></h1>
<p>Theo Wikipedia:</p>
<blockquote>
<p>Creational Patterns: Design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or in added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p>
</blockquote>
<p>Một số Creational Patterns trong Rust</p>
<ul>
<li><a href="design-pattern/creational/./builder.html">Builder Pattern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-builder-design-pattern"><a class="header" href="#rust-builder-design-pattern">Rust Builder Design Pattern</a></h1>
<p>Rust không có overloading, do đó bạn cần phải viết nhiều construct
cho tất cả các trường hợp có thể có, với các method name khác nhau.
Việc này sẽ cực kỳ mất thời gian nếu struct có quá nhiều <em>fields</em> hoặc <em>constructor</em> phức tạp.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">impl Foo {
  pub fn new(a: String) -&gt; Self {}
  pub fn new(a: String, b: String) -&gt; Self {} // &lt;-- không thể
  pub fn new(a: i32) -&gt; Self {} // &lt;-- không thể
}

// Thay vào đó
impl Foo {
  pub fn new(a: String) -&gt; Self {}
  pub fn new_from_two(a: String, b: String) -&gt; Self {}
  pub fn new_from_int(a: i32) -&gt; Self {}
}</code></pre></pre>
<p>Do đó, <strong>builder</strong> được sử dụng cực kỳ phổ biến trong Rust so với các ngôn ngữ khác.</p>
<p>Builder cho phép construct một object bằng cách gọi <code>build()</code>.</p>
<h1 id="ví-dụ-1"><a class="header" href="#ví-dụ-1">Ví dụ</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, PartialEq)]
pub struct Foo {
  // Lots of complicated fields.
  bar: String,
}

impl Foo {
  // This method will help users to discover the builder
  pub fn builder() -&gt; FooBuilder {
    FooBuilder::default()
  }
}

#[derive(Default)]
pub struct FooBuilder {
  // Probably lots of optional fields.
  bar: String,
}

impl FooBuilder {
  pub fn new(/* ... */) -&gt; FooBuilder {
    // Set the minimally required fields of Foo.
    FooBuilder {
      bar: "x".to_string(),
    }
  }

  pub fn name(mut self, bar: String) -&gt; FooBuilder {
    // Set the name on the builder itself, and return the builder by value.
    self.bar = bar;
    self
  }

  // If we can get away with not consuming the Builder here, that is an
  // advantage. It means we can use the FooBuilder as a template for constructing
  // many Foos.
  pub fn build(self) -&gt; Foo {
    // Create a Foo from the FooBuilder, applying all settings in FooBuilder
    // to Foo.
    Foo { bar: self.bar }
  }
}

#[test]
fn builder_test() {
  let foo = Foo { bar: "y".to_string() };
  let foo_from_builder = FooBuilder::new().name("y".to_string()).build();

  assert_eq!(foo, foo_from_builder);
}</code></pre></pre>
<h1 id="khi-nào-dùng-1"><a class="header" href="#khi-nào-dùng-1">Khi nào dùng</a></h1>
<p>Hữu ích khi bạn muốn có nhiều loại constructors khác nhau hoặc khi constructor có side effects.</p>
<h1 id="Ưu-điểm"><a class="header" href="#Ưu-điểm">Ưu điểm</a></h1>
<ul>
<li>Tách biệt các methods của builder và các method khác của object.</li>
<li>Không cần phải viết quá nhiều constructor nếu struct có quá nhiều fields hoặc quá nhiều cách để khởi tạo một object.</li>
<li>One-liner initialization: <code>FooBuilder::new().a().b().c().build()</code></li>
</ul>
<h1 id="nhược-điểm"><a class="header" href="#nhược-điểm">Nhược điểm</a></h1>
<p>Phức tạp hơn so với việc init object trực tiếp, hoặc so với object có constructor đơn giản.</p>
<h1 id="references-25"><a class="header" href="#references-25">References</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">https://doc.rust-lang.org/1.0.0/style/ownership/builders.html</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, một crate cho phép tự động tạo builder.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structural-patterns"><a class="header" href="#structural-patterns">Structural Patterns</a></h1>
<p>Theo Wikipedia:</p>
<blockquote>
<p>Structual Patterns: Design patterns that ease the design by identifying a simple way to realize relationships among entities.</p>
</blockquote>
<p>Một số Structural Patterns trong Rust</p>
<ul>
<li><a href="design-pattern/structural/./small-rates.html">Prefer Small Crates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefer-small-crates"><a class="header" href="#prefer-small-crates">Prefer Small Crates</a></h1>
<p>Không hẳn là một Design pattern, mình thấy đây là một tư tưởng khi viết các project bằng Rust.</p>
<p>Cargo và <a href="http://crates.io/">crates.io</a> giúp quản lý crate cực kỳ dễ dàng.
Hơn nữa, crate trên crates.io không thể sửa hoặc xóa được sau khi publish,
bất kỳ bản build nào đang hoạt động chắc chắn sẽ hoạt động được tiếp trong tương lai.
Điều này bắt buộc để có được sự hiệu quả, mọi crate phải được thiết kế tốt,
lựa chọn dependencies kỹ càng và càng nhỏ càng tốt.</p>
<blockquote>
<p>Prefer small crates that do one thing well.</p>
</blockquote>
<h1 id="Ưu-điểm-1"><a class="header" href="#Ưu-điểm-1">Ưu điểm</a></h1>
<ul>
<li>Small crate sẽ giúp ta dễ hiểu và dễ sử dụng hơn, code dễ module hóa hơn.</li>
<li>Đơn vị compilation nhỏ nhất của Rust là crate, tách nhỏ project thành nhiều crate giúp code build parallel.</li>
<li>Crate giúp tái sử dụng giữa nhiều project khác nhau.
<ul>
<li>Ví dụ, crate <code>url</code> là một phần của Servo browser engine, nhưng được sử dụng cực kỳ rộng rãi ở các project khác, do nó độc lập và giải quyết một vấn đề cụ thể.</li>
<li>Ví dụ, <a href="https://awslabs.github.io/aws-sdk-rust/">AWS SDK Rust</a> được tách thành rất nhiều crate nhỏ, và các crate nhỏ này được sử dụng ở khắp nơi không chỉ ở AWS SDK Rust.
<ul>
<li><code>aws-sdk-*</code></li>
<li><code>aws-config</code></li>
<li><code>aws_smithy_client</code></li>
<li><code>aws_types</code></li>
</ul>
</li>
</ul>
</li>
<li>Tách nhỏ crate độc lập giúp việc chia tasks trong một project lớn của team hiệu quả hơn.</li>
</ul>
<h1 id="nhược-điểm-1"><a class="header" href="#nhược-điểm-1">Nhược điểm</a></h1>
<ul>
<li>Có dễ dẫn đến “dependency hell”, một project depends vào cùng 1 crate nhưng version khác nhau cùng một lúc. Và các versions này xung đột nhau.</li>
<li>Hai crate quá nhỏ có thể kém hiệu quả hơn một crate lớn, bởi vì compiler mặc định không thực hiện link-time optimization (LTO).</li>
</ul>
<h1 id="một-số-small-crates-điển-hình"><a class="header" href="#một-số-small-crates-điển-hình">Một số small crates điển hình</a></h1>
<ul>
<li><a href="https://crates.io/crates/url">url</a>: crate xử lý url.</li>
<li><a href="https://crates.io/crates/ref_slice">ref_slice</a>: crate giúp convert từ <code>&amp;T</code> sang <code>&amp;[T]</code>. Crate này <a href="https://github.com/rust-lang/rust/issues/27774#issuecomment-150058618">từng nằm trong standard library</a> nhưng đã tách ra.</li>
<li><a href="https://crates.io/crates/num_cpus">num_cpus</a>: trả về số lượng cpu trên máy hiện tại.</li>
<li><a href="https://crates.io/crates/rand">rand</a>: random number generators.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex"><a class="header" href="#regex"><a href="https://crates.io/crates/regex"><code>regex</code></a></a></h1>
<p>Regular expressions cho Rust.</p>
<h2 id="cài-đặt"><a class="header" href="#cài-đặt">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add regex
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
regex = "1"
</code></pre>
<h2 id="sử-dụng"><a class="header" href="#sử-dụng">Sử dụng</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use regex::Regex;

fn main() {
    let re = Regex::new(r"(\d{4})-(\d{2})-(\d{2})").unwrap();
    let hay = "On 2010-03-14, foo happened. On 2014-10-14, bar happened.";

    let mut dates = vec![];
    for (_, [year, month, day]) in re.captures_iter(hay).map(|c| c.extract()) {
        dates.push((year, month, day));
    }
    assert_eq!(dates, vec![
      ("2010", "03", "14"),
      ("2014", "10", "14"),
    ]);
}</code></pre></pre>
<h2 id="references-26"><a class="header" href="#references-26">References</a></h2>
<ul>
<li>https://docs.rs/regex</li>
<li>https://crates.io/crates/regex</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chrono"><a class="header" href="#chrono"><a href="https://crates.io/crates/chrono"><code>chrono</code></a></a></h1>
<p><a href="https://crates.io/crates/chrono"><code>chrono</code></a> có hầu hết mọi thứ giúp bạn xử lý dates và times. <a href="https://crates.io/crates/chrono_tz"><code>chrono_tz</code></a> không được ship bên trong <a href="https://crates.io/crates/chrono"><code>chrono</code></a> vì lý do binary size nên chúng ta có thể cài đặt riêng nếu cần thiết.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
chrono = "*"
chrono-tz = "*"
</code></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::prelude::*;

let utc: DateTime&lt;Utc&gt; = Utc::now();
println!("{}", utc);
<span class="boring">}</span></code></pre></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::prelude::*;

let dt: DateTime&lt;Local&gt; = Local::now();

println!("{}", dt); 
// 2024-06-20 09:05:39.051849711 +00:00

println!("{}", dt.format("%A, %B %e, %Y %r")); 
// Thursday, June 20, 2024 09:06:36 AM

println!("year = {}", dt.year());
// year = 2024
<span class="boring">}</span></code></pre></pre>
<p>Khởi tạo naive datetime và convert thành timezone-aware datetime</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{TimeZone, NaiveDate};
use chrono_tz::Asia::Ho_Chi_Minh;

let naive_dt = NaiveDate::from_ymd(2038, 1, 19).and_hms(3, 14, 08);
let tz_aware = Ho_Chi_Minh.from_local_datetime(&amp;naive_dt).unwrap();
println!("{}", tz_aware.to_string());
<span class="boring">}</span></code></pre></pre>
<h2 id="parse-datetime"><a class="header" href="#parse-datetime">Parse datetime</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::prelude::*;

// method 1
let dt = "2014-11-28T12:00:09Z".parse::&lt;DateTime&lt;Utc&gt;&gt;();

println!("{:?}", dt);
<span class="boring">}</span></code></pre></pre>
<p><code>DateTime::parse_from_str</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::prelude::*;

let dt = DateTime::parse_from_str("2014-11-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z");
println!("{:?}", dt);
<span class="boring">}</span></code></pre></pre>
<p><code>DateTime::parse_from_rfc2822</code>, <code>DateTime::parse_from_rfc3339</code>, etc:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::prelude::*;

let dt = DateTime::parse_from_rfc2822("Tue, 1 Jul 2003 10:52:37 +0200");
println!("{:?}", dt);
<span class="boring">}</span></code></pre></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Xem <a href="https://docs.rs/chrono/latest/chrono/">docs.rs</a> nhiều ví dụ hơn và API reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async_trait"><a class="header" href="#async_trait"><a href="https://docs.rs/async-trait"><code>async_trait</code></a></a></h1>
<p>Rust chưa hỗ trợ <code>async</code> cho trait. Trait dưới đây sẽ báo lỗi:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    async fn f() {}
}
<span class="boring">}</span></code></pre></pre>
<pre><code>error[E0706]: trait fns cannot be declared `async`
 --&gt; src/main.rs:4:5
  |
4 |     async fn f() {}
  |     ^^^^^^^^^^^^^^^
</code></pre>
<p><a href="https://docs.rs/async-trait"><code>async_trait</code></a> cung cấp attribute macro để giúp async có thể hoạt động với trait.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
async_trait = "0.1"
</code></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;

#[async_trait]
trait Advertisement {
    async fn run(&amp;self);
}

struct Modal;

#[async_trait]
impl Advertisement for Modal {
    async fn run(&amp;self) {
        self.render_fullscreen().await;
        for _ in 0..4u16 {
            remind_user_to_join_mailing_list().await;
        }
        self.hide_for_now().await;
    }
}

struct AutoplayingVideo {
    media_url: String,
}

#[async_trait]
impl Advertisement for AutoplayingVideo {
    async fn run(&amp;self) {
        let stream = connect(&amp;self.media_url).await;
        stream.play().await;

        // Video probably persuaded user to join our mailing list!
        Modal.run().await;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="references-27"><a class="header" href="#references-27">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/anyhow">https://docs.rs/anyhow</a></li>
<li>Github: <a href="https://github.com/dtolnay/anyhow">https://github.com/dtolnay/anyhow</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">why async fn in traits are hard</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy_static"><a class="header" href="#lazy_static"><a href="https://docs.rs/lazy_static"><code>lazy_static</code></a></a></h1>
<p><a href="https://docs.rs/lazy_static"><code>lazy_static</code></a> là một macro cho phép khởi tạo biến <code>static</code> nhưng chứa giá trị
được thực thi lúc runtime. Các giá trị này có thể là bất kỳ cái gì cần heap allocations,
ví dụ như <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> hoặc function call.</p>
<h2 id="cài-đặt-1"><a class="header" href="#cài-đặt-1">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add lazy_static
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
lazy_static = "1"
</code></pre>
<h2 id="ví-dụ-2"><a class="header" href="#ví-dụ-2">Ví dụ</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use lazy_static::lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref HASHMAP: HashMap&lt;u32, &amp;'static str&gt; = {
        let mut m = HashMap::new();
        m.insert(0, "foo");
        m.insert(1, "bar");
        m.insert(2, "baz");
        m
    };
    static ref COUNT: usize = HASHMAP.len();
    static ref NUMBER: u32 = times_two(21);
}

fn times_two(n: u32) -&gt; u32 { n * 2 }

fn main() {
    println!("The map has {} entries.", *COUNT);
    println!("The entry for `0` is \"{}\".", HASHMAP.get(&amp;0).unwrap());
    println!("A expensive calculation on a static results in: {}.", *NUMBER);
}</code></pre></pre>
<h2 id="references-28"><a class="header" href="#references-28">References</a></h2>
<ul>
<li>Doc: <a href="https://docs.rs/lazy_static">https://docs.rs/lazy_static</a></li>
<li>Github: <a href="https://github.com/rust-lang-nursery/lazy-static.rs">https://github.com/rust-lang-nursery/lazy-static.rs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde"><a class="header" href="#serde"><a href="http://serde.rs"><code>serde</code></a></a></h1>
<p>A generic serialization/deserialization framework</p>
<h2 id="cài-đặt-2"><a class="header" href="#cài-đặt-2">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add serde
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
serde = "*"
</code></pre>
<h2 id="sử-dụng-1"><a class="header" href="#sử-dụng-1">Sử dụng</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // Convert the Point to a JSON string.
    let serialized = serde_json::to_string(&amp;point).unwrap();

    // Prints serialized = {"x":1,"y":2}
    println!("serialized = {}", serialized);

    // Convert the JSON string back to a Point.
    let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();

    // Prints deserialized = Point { x: 1, y: 2 }
    println!("deserialized = {:?}", deserialized);
}</code></pre></pre>
<h2 id="data-formats"><a class="header" href="#data-formats">Data formats</a></h2>
<ul>
<li><a href="crates/./serde/serde_json.html">serde_json</a></li>
<li><a href="crates/./serde/serde_yaml.html">serde_yaml</a></li>
<li><a href="crates/./serde/serde_toml.html">serde_toml</a></li>
<li><a href="crates/./serde/serde_csv.html">serde_csv</a></li>
</ul>
<h2 id="references-29"><a class="header" href="#references-29">References</a></h2>
<ul>
<li>http://serde.rs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde_json"><a class="header" href="#serde_json">serde_json</a></h1>
<p>JSON đã trở thành một trong những định dạng trao đổi dữ liệu phổ biến, đa số các ngữ lập trình server-side đều có thể xử lý chúng.
Nhờ vào <a href="https://crates.io/crates/serde">serde</a> và <a href="https://crates.io/crates/serde_json">serde_json</a> việc xử lý JSON cũng vô cùng dễ dàng với Rust.
Các crate này cũng đã được test một cách kỹ càng và nhiều examples vô cùng phong phú dễ sử dụng.</p>
<pre><code class="language-toml">[dependencies]
serde = "1"
serde_json = "1"
</code></pre>
<h1 id="parse-chuỗi-json-thành-rust"><a class="header" href="#parse-chuỗi-json-thành-rust">Parse chuỗi JSON thành Rust</a></h1>
<p>Giả sử chúng ta có đoạn JSON như sau:</p>
<pre><code class="language-json">{
	"name": "Duyet Le",
	"age": 27,
	"phones": [
		"+60 1234567",
		"+84 2345678"
	]
}
</code></pre>
<p>Chúng ta sẽ parse thành một giá trị trong Rust:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::{Result, Value};

fn untyped_example() -&gt; Result&lt;()&gt; {
    // Some JSON input data as a &amp;str. Maybe this comes from the user.
    let data = r#"
        {
			"name": "Duyet Le",
			"age": 27,
			"phones": [
				"+60 1234567",
				"+84 2345678"
			]
        }"#;

    // Parse the string of data into serde_json::Value.
    let v: Value = serde_json::from_str(data)?;

    // Access parts of the data by indexing with square brackets.
    println!("Please call {} at the number {}", v["name"], v["phones"][0]);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p><code>v</code> được parse từ JSON là một enum <a href="https://docs.rs/serde_json/1/serde_json/value/enum.Value.html"><code>serde_json::Value</code></a> cho phép biểu diễn mọi thuộc tính của JSON.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Value {
    Null,
    Bool(bool),
    Number(Number),
    String(String),
    Array(Vec&lt;Value&gt;),
    Object(Map&lt;String, Value&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>Để truy xuất đến từng thuộc tính:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>v["name"]
v["phones"]
v["phones"][0 ]
<span class="boring">}</span></code></pre></pre>
<h1 id="parse-json-into-strongly-typed"><a class="header" href="#parse-json-into-strongly-typed">Parse JSON into Strongly Typed</a></h1>
<p>Serde cho phép chúng ta map một JSON data vào một kiểu dữ liệu của Rust và có thể do chúng ta tự định nghĩa, một cách tự động:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Person {
    name: String,
    age: u8,
    phones: Vec&lt;String&gt;,
}

fn typed_example() -&gt; Result&lt;()&gt; {
    let data = r#"
        {
			"name": "Duyet Le",
			"age": 27,
			"phones": [
				"+60 1234567",
				"+84 2345678"
			]
        }"#;

    // Parse the string of data into a Person object. This is exactly the
    // same function as the one that produced serde_json::Value above, but
    // now we are asking it for a Person as output.
    let p: Person = serde_json::from_str(data)?;

    // Do things just like with any other Rust data structure.
    println!("Please call {} at the number {}", p.name, p.phones[0]);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h1 id="constructing-json-values"><a class="header" href="#constructing-json-values">Constructing JSON values</a></h1>
<p><code>json!</code> macro giúp chúng ta khởi tạo <code>serde_json::Value</code> objects với cú pháp giống hệt JSON string:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use serde_json::json;

fn main() {
    // The type of `john` is `serde_json::Value`
    let duyet = json!({
        "name": "Duyet Le",
		"age": 27,
		"phones": [
			"+60 1234567",
			"+84 2345678"
		]
    });

    println!("first phone number: {}", duyet["phones"][0]);

    // Convert to a string of JSON and print it out
    println!("{}", duyet.to_string());
}</code></pre></pre>
<h1 id="convert-a-struct-to-json"><a class="header" href="#convert-a-struct-to-json">Convert a Struct to JSON</a></h1>
<p>Một kiểu dữ liệu có thể được convert thành JSON string bởi <a href="https://docs.rs/serde_json/1/serde_json/ser/fn.to_string.html"><code>serde_json::to_string</code></a>. Kiểu dữ liệu này có thể là Struct hoặc Enum có có implement <code>#[derive(Serialize)]</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use serde_json::Result;

#[derive(Serialize, Deserialize)]
struct Address {
    street: String,
    city: String,
}

fn print_an_address() -&gt; Result&lt;()&gt; {
    // Some data structure.
    let address = Address {
        street: "Dist 1 Street".to_owned(),
        city: "Ho Chi Minh".to_owned(),
    };

    // Serialize it to a JSON string.
    let j = serde_json::to_string(&amp;address)?;

    // Print, write to a file, or send to an HTTP server.
    println!("{}", j);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="references-30"><a class="header" href="#references-30">References</a></h2>
<ul>
<li><a href="crates/serde/../serde.html"><code>serde</code></a></li>
<li><a href="https://docs.rs/serde_json">JSON API documentation</a></li>
<li><a href="https://docs.rs/serde">Serde API documentation</a></li>
<li><a href="https://serde.rs/">Detailed documentation about Serde</a></li>
<li><a href="https://serde.rs/derive.html">Setting up <code>#[derive(Serialize, Deserialize)]</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde_toml"><a class="header" href="#serde_toml">serde_toml</a></h1>
<p><a href="crates/serde/../serde.html"><code>serde</code></a> đọc và xử lý TOML file.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
serde = "1"
toml = "1"
</code></pre>
<p>Ví dụ deserialize từ TOML file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;

#[derive(Deserialize)]
struct Config {
   ip: String,
   port: Option&lt;u16&gt;,
   keys: Keys,
}

#[derive(Deserialize)]
struct Keys {
   github: String,
   travis: Option&lt;String&gt;,
}

let config: Config = toml::from_str(r#"
   ip = '127.0.0.1'

   [keys]
   github = 'xxxxxxxxxxxxxxxxx'
   travis = 'yyyyyyyyyyyyyyyyy'
"#).unwrap();

assert_eq!(config.ip, "127.0.0.1");
assert_eq!(config.port, None);
assert_eq!(config.keys.github, "xxxxxxxxxxxxxxxxx");
assert_eq!(config.keys.travis.as_ref().unwrap(), "yyyyyyyyyyyyyyyyy");
<span class="boring">}</span></code></pre></pre>
<p>Ví dụ serialize sang TOML file:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Serialize;

#[derive(Serialize)]
struct Config {
   ip: String,
   port: Option&lt;u16&gt;,
   keys: Keys,
}

#[derive(Serialize)]
struct Keys {
   github: String,
   travis: Option&lt;String&gt;,
}

let config = Config {
   ip: "127.0.0.1".to_string(),
   port: None,
   keys: Keys {
       github: "xxxxxxxxxxxxxxxxx".to_string(),
       travis: Some("yyyyyyyyyyyyyyyyy".to_string()),
   },
};

let toml = toml::to_string(&amp;config).unwrap();
println!("{}", toml);
<span class="boring">}</span></code></pre></pre>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ul>
<li><a href="crates/serde/../serde.html"><code>serde</code></a></li>
<li><a href="https://docs.rs/toml">https://docs.rs/toml</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde_toml-1"><a class="header" href="#serde_toml-1">serde_toml</a></h1>
<p><a href="crates/serde/../serde.html"><code>serde</code></a> đọc và xử lý CSV file.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
serde = "1"
csv = "1"
</code></pre>
<p>Ví dụ parse file CSV:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;

let mut rdr = csv::Reader::from_reader(io::stdin());

for result in rdr.records() {
   // An error may occur, so abort the program in an unfriendly way.
   // We will make this more friendly later!
   let record = result.expect("a CSV record");
   // Print a debug version of the record.
   println!("{:?}", record);
}
<span class="boring">}</span></code></pre></pre>
<p>Ví dụ:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::{error::Error, io, process};

#[derive(Debug, serde::Deserialize)]
struct Record {
    city: String,
    region: String,
    country: String,
    population: Option&lt;u64&gt;,
}

fn example() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.deserialize() {
        // Notice that we need to provide a type hint for automatic
        // deserialization.
        let record: Record = result?;
        println!("{:?}", record);
    }
    Ok(())
}

fn main() {
    if let Err(err) = example() {
        println!("error running example: {}", err);
        process::exit(1);
    }
}</code></pre></pre>
<h1 id="reference-1"><a class="header" href="#reference-1">Reference</a></h1>
<ul>
<li><a href="crates/serde/../serde.html"><code>serde</code></a></li>
<li><a href="https://docs.rs/csv">https://docs.rs/csv</a></li>
<li><a href="https://docs.rs/csv/latest/csv/tutorial/index.html">https://docs.rs/csv/latest/csv/tutorial</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde_yaml"><a class="header" href="#serde_yaml"><a href="https://github.com/dtolnay/serde-yaml"><code>serde_yaml</code></a></a></h1>
<p><a href="crates/serde/../serde.html"><code>serde</code></a> đọc và xử lý file YAML.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1", features = ["derive"] }
serde_yaml = "*"
</code></pre>
<p>Ví dụ</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::collections::BTreeMap;

fn main() -&gt; Result&lt;(), serde_yaml::Error&gt; {
    // You have some type.
    let mut map = BTreeMap::new();
    map.insert("x".to_string(), 1.0);
    map.insert("y".to_string(), 2.0);

    // Serialize it to a YAML string.
    let yaml = serde_yaml::to_string(&amp;map)?;
    assert_eq!(yaml, "x: 1.0\ny: 2.0\n");

    // Deserialize it back to a Rust type.
    let deserialized_map: BTreeMap&lt;String, f64&gt; = serde_yaml::from_str(&amp;yaml)?;
    assert_eq!(map, deserialized_map);

    println!("BTreeMap:\n{}", yaml);

    Ok(())
}</code></pre></pre>
<p>Structs serialize in the obvious way:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use serde::{Serialize, Deserialize};

#[derive(Debug, PartialEq, Serialize, Deserialize)]
struct Point {
    x: f64,
    y: f64,
}

fn main() -&gt; Result&lt;(), serde_yaml::Error&gt; {
    let point = Point { x: 1.0, y: 2.0 };

    let yaml = serde_yaml::to_string(&amp;point)?;
    assert_eq!(yaml, "x: 1.0\ny: 2.0\n");

    let deserialized_point: Point = serde_yaml::from_str(&amp;yaml)?;
    assert_eq!(point, deserialized_point);
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokio"><a class="header" href="#tokio"><a href="https://tokio.rs"><code>tokio</code></a></a></h1>
<p><a href="https://tokio.rs"><code>tokio</code></a> là một asynchronous runtime, giúp viết ứng dụng async trong Rust.</p>
<h2 id="cài-đặt-3"><a class="header" href="#cài-đặt-3">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add tokio --features full
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
tokio = { version = "1", features = ["full"] }
</code></pre>
<h2 id="ví-dụ-3"><a class="header" href="#ví-dụ-3">Ví dụ</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">#[tokio::main]
async fn main() {
    // This is running on a core thread.

    let blocking_task = tokio::task::spawn_blocking(|| {
        // This is running on a blocking thread.
        // Blocking here is ok.
    });

    // We can wait for the blocking task like this:
    // If the blocking task panics, the unwrap below will propagate the
    // panic.
    blocking_task.await.unwrap();
}</code></pre></pre>
<h2 id="ví-dụ-socket-server"><a class="header" href="#ví-dụ-socket-server">Ví dụ: Socket server</a></h2>
<p>Ví dụ sau lấy từ document của <a href="https://tokio.rs"><code>tokio</code></a>, một server đơn giản nhận kết nối từ client và trả về một thông báo.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::net::{TcpListener, TcpStream};
use mini_redis::{Connection, Frame};

#[tokio::main]
async fn main() {
    // Bind the listener to the address
    let listener = TcpListener::bind("127.0.0.1:6379").await.unwrap();

    loop {
        // The second item contains the IP and port of the new connection.
        let (socket, _) = listener.accept().await.unwrap();
        process(socket).await;
    }
}

async fn process(socket: TcpStream) {
    // The `Connection` lets us read/write redis **frames** instead of
    // byte streams. The `Connection` type is defined by mini-redis.
    let mut connection = Connection::new(socket);

    if let Some(frame) = connection.read_frame().await.unwrap() {
        println!("GOT: {:?}", frame);

        // Respond with an error
        let response = Frame::Error("unimplemented".to_string());
        connection.write_frame(&amp;response).await.unwrap();
    }
}</code></pre></pre>
<p>Trên terminal:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Trên một terminal khác:</p>
<pre><code class="language-bash">(printf "PING\r\n";) | nc localhost 6379
</code></pre>
<h2 id="references-31"><a class="header" href="#references-31">References</a></h2>
<ul>
<li><a href="https://tokio.rs/tokio/tutorial">Tokio Tutorial</a></li>
<li><a href="https://tokio.rs/tokio/tutorial/setup">Tokio Mini-Redis</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anyhow"><a class="header" href="#anyhow"><a href="https://docs.rs/anyhow"><code>anyhow</code></a></a></h1>
<p><a href="https://docs.rs/anyhow"><code>anyhow</code></a> là thư viện giúp đơn giản hóa việc handle lỗi trong Rust application.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
anyhow = "1"
</code></pre>
<p>Cách sử dụng</p>
<ul>
<li>
<p>Sử dụng <code>anyhow::Result&lt;T&gt;</code> thay cho <code>Result</code> của <code>std</code>. Ta không cần định nghĩa Error trả về. Trong function sử dụng <code>?</code> để trả mọi error đã được impl <code>std::error::Error</code> lên level cao hơn.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;

fn get_cluster_info() -&gt; Result&lt;ClusterMap&gt; {
    let config = std::fs::read_to_string("cluster.json")?;
    let map: ClusterMap = serde_json::from_str(&amp;config)?;
    Ok(map)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Thêm context để debug dễ hơn:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use anyhow::{Context, Result};

fn main() -&gt; Result&lt;()&gt; {
    ...
    it.detach().context("Failed to detach the important thing")?;

    let content = std::fs::read(path)
        .with_context(|| format!("Failed to read instrs from {}", path))?;
    ...
}</code></pre></pre>
<pre><code>Error: Failed to read instrs from ./path/to/instrs.json

Caused by:
    No such file or directory (os error 2)
</code></pre>
</li>
<li>
<p>Return lỗi nhanh hơn với macros <a href="https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html"><code>anyhow!</code></a>, <a href="https://docs.rs/anyhow/latest/anyhow/macro.bail.html"><code>bail!</code></a>, <a href="https://docs.rs/anyhow/latest/anyhow/macro.ensure.html"><code>ensure!</code></a></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return Err(anyhow!("Missing attribute: {}", missing));
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bail!("Missing attribute: {}", missing);    
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ensure!(user == 0, "only user 0 is allowed");
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="references-32"><a class="header" href="#references-32">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/anyhow">https://docs.rs/anyhow</a></li>
<li>Github: <a href="https://github.com/dtolnay/anyhow">https://github.com/dtolnay/anyhow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log"><a class="header" href="#log">log</a></h1>
<p><a href="https://docs.rs/log"><code>log</code></a> là thư viện logging lightweight cho Rust application.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
log = "0.4"
</code></pre>
<p>Cách sử dụng</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use log::{info, trace, warn};

pub fn shave_the_yak(yak: &amp;mut Yak) {
    trace!("Commencing yak shaving");

    loop {
        match find_a_razor() {
            Ok(razor) =&gt; {
                info!("Razor located: {}", razor);
                yak.shave(razor);
                break;
            }
            Err(err) =&gt; {
                warn!("Unable to locate a razor: {}, retrying", err);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="env_logger"><a class="header" href="#env_logger"><a href="https://docs.rs/env_logger"><code>env_logger</code></a></a></h2>
<p><a href="https://docs.rs/log"><code>log</code></a> thường được sử dụng với <a href="https://docs.rs/env_logger"><code>env_logger</code></a> để cấu hình logging
thông qua biến môi trường.</p>
<p>Mặc định, <code>env_logger</code> ghi log ra <code>stderr</code>.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
log = "0.4.0"
env_logger = "0.8.4"
</code></pre>
<p>Ví dụ:</p>
<p>File: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  env_logger::init();

  info!("starting up");
  error!("this is error!");
  debug!("this is debug {}!", "message");
}</code></pre></pre>
<pre><code>$ RUST_LOG=error cargo run
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=debug cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<p>Filter log theo module name:</p>
<pre><code>$ RUST_LOG=main=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<p>Hiện mọi log level cho module <code>main</code>:</p>
<pre><code>$ RUST_LOG=main cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<h3 id="references-33"><a class="header" href="#references-33">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/env_logger">https://docs.rs/env_logger</a></li>
<li>Github: <a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></li>
<li><a href="https://docs.rs/env_logger/">https://docs.rs/env_logger/</a></li>
</ul>
<h3 id="references-34"><a class="header" href="#references-34">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/log">https://docs.rs/log</a></li>
<li>Github: <a href="https://github.com/rust-lang/log">https://github.com/rust-lang/log</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="env_logger-1"><a class="header" href="#env_logger-1"><a href="https://docs.rs/env_logger"><code>env_logger</code></a></a></h2>
<p><a href="https://docs.rs/log"><code>log</code></a> thường được sử dụng với <a href="https://docs.rs/env_logger"><code>env_logger</code></a> để cấu hình logging
thông qua biến môi trường.</p>
<p>Mặc định, <code>env_logger</code> ghi log ra <code>stderr</code>.</p>
<p>File: Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
log = "0.4.0"
env_logger = "0.8.4"
</code></pre>
<p>Ví dụ:</p>
<p>File: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
  env_logger::init();

  info!("starting up");
  error!("this is error!");
  debug!("this is debug {}!", "message");
}</code></pre></pre>
<pre><code>$ RUST_LOG=error cargo run
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<pre><code>$ RUST_LOG=debug cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<p>Filter log theo module name:</p>
<pre><code>$ RUST_LOG=main=info cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
</code></pre>
<p>Hiện mọi log level cho module <code>main</code>:</p>
<pre><code>$ RUST_LOG=main cargo run
[2022-07-11T02:12:24Z INFO main] starting up
[2022-07-11T02:12:24Z ERROR main] this is error
[2022-07-11T02:12:24Z DEBUG main] this is debug message!
</code></pre>
<h3 id="references-35"><a class="header" href="#references-35">References</a></h3>
<ul>
<li>Doc: <a href="https://docs.rs/env_logger">https://docs.rs/env_logger</a></li>
<li>Github: <a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></li>
<li><a href="https://docs.rs/env_logger/">https://docs.rs/env_logger/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indoc"><a class="header" href="#indoc"><a href="https://github.com/dtolnay/indoc"><code>indoc</code></a></a></h1>
<p><a href="https://github.com/dtolnay/indoc"><code>indoc</code></a> là một crate nhỏ nhưng hữu ích giúp canh lề (indented documents).
<code>indoc!()</code> macro nhận multiline string và un-indents lúc compile time,
xoá tất cả khoảng trắng đầu tiên trên cách dòng dựa theo dòng đầu tiên.</p>
<h2 id="cài-đặt-4"><a class="header" href="#cài-đặt-4">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add indoc
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
indoc = "1"
</code></pre>
<h2 id="ví-dụ-4"><a class="header" href="#ví-dụ-4">Ví dụ</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use indoc::indoc;

fn main() {
    let testing = indoc! {"
        def hello():
            print('Hello, world!')

        hello()
    "};

    let expected = "def hello():\n    print('Hello, world!')\n\nhello()\n";
    assert_eq!(testing, expected);
}</code></pre></pre>
<p><a href="https://github.com/dtolnay/indoc"><code>indoc</code></a> cũng hoạt động với raw string <code>r# ... #</code> và byte string <code>b" ... "</code>.</p>
<h2 id="references-36"><a class="header" href="#references-36">References</a></h2>
<ul>
<li><a href="https://docs.rs/indoc/latest/indoc/">https://docs.rs/indoc/latest/indoc/</a></li>
<li><a href="https://github.com/dtolnay/indoc">https://github.com/dtolnay/indoc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rayon"><a class="header" href="#rayon"><a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a></a></h1>
<p><a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a> là thư viện data-parallelism cho Rust, gọn nhẹ và dễ dàng convert từ
code tính toán tuần tự sang song song mà vẫn đảm bảo không lỗi data-race.</p>
<h2 id="cài-đặt-5"><a class="header" href="#cài-đặt-5">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add rayon
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
rayon = "1.5"
</code></pre>
<h2 id="ví-dụ-5"><a class="header" href="#ví-dụ-5">Ví dụ</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;

fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.par_iter() // &lt;-- chỉ cần sử dụng `par_iter()` thay vì `iter()`!
         .map(|&amp;i| i * i)
         .sum()
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://docs.rs/rayon/*/rayon/iter/index.html">Parallel iterators</a>
sẽ phụ trách việc chia data thành nhiều tasks nhỏ như thế nào và sẽ
đáp ứng linh hoạt để đạt maximum performance.
Ngoài ra, Rayon cũng cung cấp 2 function <a href="https://docs.rs/rayon/*/rayon/fn.join.html"><code>join</code></a> và <a href="https://docs.rs/rayon/*/rayon/fn.scope.html"><code>scope</code></a> để bạn
có thể chủ động điều khiển việc parallel tasks.</p>
<p>Để tìm hiểu thêm về cách <a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a> hoạt động bạn có thể đọc thêm bài blog từ tác giả:
<a href="https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/">https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/</a></p>
<h2 id="demo--bench"><a class="header" href="#demo--bench">demo &amp; bench</a></h2>
<p>Trong repo của <a href="https://github.com/rayon-rs/rayon"><code>rayon</code></a> có rất nhiều demo và bench, để xem danh sách demo hoặc bench:</p>
<pre><code class="language-bash">$ git clone https://github.com/rayon-rs/rayon &amp;&amp; cd rayon/rayon-demo 
$ cargo run --release -- --help

Usage: rayon-demo bench
       rayon-demo &lt;demo-name&gt; [ options ]
       rayon-demo --help

A collection of different benchmarks of Rayon. You can run the full
benchmark suite by executing `cargo bench` or `rayon-demo bench`.

Alternatively, you can run individual benchmarks by running
`rayon-demo foo`, where `foo` is the name of a benchmark. Each
benchmark has its own options and modes, so try `rayon-demo foo
--help`.

Benchmarks:

  - life : Conway's Game of Life.
  - nbody: A physics simulation of multiple bodies attracting and repelling
           one another.
  - sieve: Finding primes using a Sieve of Eratosthenes.
  - matmul: Parallel matrix multiplication.
  - mergesort: Parallel mergesort.
  - noop: Launch empty tasks to measure CPU usage.
  - quicksort: Parallel quicksort.
  - tsp: Traveling salesman problem solver (sample data sets in `data/tsp`).
</code></pre>
<p><strong>Quicksort</strong> benchmark:</p>
<pre><code class="language-bash">$ cargo run --release quicksort bench

seq: sorted 250000000 ints: 22.268583 s
par: sorted 250000000 ints: 4.172599 s
speedup: 5.34x
</code></pre>
<p><strong>Demo nbody visualize</strong>: gõ <code>s</code> để chạy tuần tự và <code>p</code> để parallel</p>
<pre><code class="language-bash">cargo run --release -- nbody visualize
</code></pre>
<p><img src="https://i.imgur.com/cF6Euyf.png" alt="" /></p>
<h2 id="references-37"><a class="header" href="#references-37">References</a></h2>
<ul>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/">Rayon: data parallelism in Rust</a></li>
<li><a href="https://www.youtube.com/watch?v=gof_OEv71Aw">https://www.youtube.com/watch?v=gof_OEv71Aw</a></li>
<li><a href="https://github.com/rayon-rs/rayon">https://github.com/rayon-rs/rayon</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polars"><a class="header" href="#polars"><a href="ttps://pola.rs"><code>polars</code></a></a></h1>
<p>Xử lý DataFrame lớn, dễ sử dụng, hiệu năng cao và có nhiều ưu điểm giống với Pandas nổi tiếng. Polars cũng được hỗ trợ trên Python.</p>
<p><img src="crates/./polars.png" alt="" /></p>
<h2 id="cài-đặt-6"><a class="header" href="#cài-đặt-6">Cài đặt</a></h2>
<pre><code class="language-bash">cargo add polars
</code></pre>
<p>Hoặc</p>
<pre><code class="language-toml"># File: Cargo.toml

[dependencies]
polars = { version = "x", features = ["lazy", ...]}
</code></pre>
<h2 id="ví-dụ-6"><a class="header" href="#ví-dụ-6">Ví dụ</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

use chrono::prelude::*;
use polars::prelude::*;

let mut df: DataFrame = df!(
    "integer" =&gt; &amp;[1, 2, 3],
    "date" =&gt; &amp;[
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap().and_hms_opt(0, 0, 0).unwrap(),
            NaiveDate::from_ymd_opt(2025, 1, 2).unwrap().and_hms_opt(0, 0, 0).unwrap(),
            NaiveDate::from_ymd_opt(2025, 1, 3).unwrap().and_hms_opt(0, 0, 0).unwrap(),
    ],
    "float" =&gt; &amp;[4.0, 5.0, 6.0],
    "string" =&gt; &amp;["a", "b", "c"],
)
.unwrap();
println!("{}", df);
<span class="boring">}</span></code></pre></pre>
<h2 id="references-38"><a class="header" href="#references-38">References</a></h2>
<ul>
<li>https://pola.rs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-rust-for-efficient-data-processing-and-analysis"><a class="header" href="#using-rust-for-efficient-data-processing-and-analysis">Using Rust for efficient data processing and analysis</a></h1>
<h2 id="data-format"><a class="header" href="#data-format">Data format</a></h2>
<ul>
<li><a href="https://github.com/apache/arrow-rs">arrow</a>: Native Rust implementation of Apache Arrow and Apache Parquet</li>
</ul>
<h2 id="data-processing"><a class="header" href="#data-processing">Data Processing</a></h2>
<ul>
<li><a href="https://github.com/pola-rs/polars">polars</a>: xử lý Dataframe với hiệu năng cao, khá tương đồng và có thể thay thế Pandas.</li>
<li><a href="https://github.com/serde-rs/serde">serde</a>: Serializing và Deserializing nhiều loại data (JSON, CSV, ...) thành các kiểu dữ liệu trong Rust.</li>
<li><a href="https://github.com/rayon-rs/rayon">rayon</a>: Framework xử lý dữ liệu parallel.</li>
<li><a href="https://github.com/apache/arrow-datafusion">datafusion</a>: query execution framework, sử dụng Apache Arrow.</li>
<li><a href="https://github.com/apache/datafusion-ballista">ballista</a>: Distributed SQL Query Engine, sử dụng Apache Arrow</li>
</ul>
<h2 id="data-ingestion"><a class="header" href="#data-ingestion">Data Ingestion</a></h2>
<ul>
<li><a href="https://github.com/seanmonstar/reqwest">reqwest</a>: Rust HTTP client.</li>
<li><a href="https://vector.dev">vector.dev</a>: ultra-fast tool for building observability pipelines.</li>
</ul>
<h1 id="references-39"><a class="header" href="#references-39">References</a></h1>
<ul>
<li>https://blog.duyet.net/2023/01/data-engineering-rust-tools.html</li>
<li>https://arewedatayet.com</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-high-performance-data-pipelines-in-rust"><a class="header" href="#first-high-performance-data-pipelines-in-rust">First high-performance data pipelines in Rust</a></h1>
<p>Xây dựng data pipeline hiệu năng cao là một trong những use case phổ biến của Rust trong lĩnh vực data engineering. Với tốc độ gần như C/C++, memory safety, và hệ sinh thái phong phú, Rust là lựa chọn tuyệt vời để xây dựng các data pipeline xử lý lượng lớn dữ liệu.</p>
<p>Trong bài này, chúng ta sẽ xây dựng một data pipeline đơn giản nhưng mạnh mẽ để:</p>
<ol>
<li>Đọc dữ liệu từ CSV file</li>
<li>Xử lý và transform dữ liệu</li>
<li>Ghi kết quả ra Parquet format (columnar storage hiệu năng cao)</li>
</ol>
<h2 id="cài-đặt-dependencies"><a class="header" href="#cài-đặt-dependencies">Cài đặt dependencies</a></h2>
<p>Tạo project mới:</p>
<pre><code class="language-bash">cargo new data-pipeline
cd data-pipeline
</code></pre>
<p>Thêm dependencies vào <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
polars = { version = "0.43", features = ["lazy", "parquet", "csv"] }
anyhow = "1.0"
</code></pre>
<ul>
<li><a href="data-engineering/../crates/polars.html"><code>polars</code></a>: DataFrame library hiệu năng cao, tương tự như Pandas</li>
<li><code>anyhow</code>: Error handling đơn giản và tiện lợi</li>
</ul>
<h2 id="ví-dụ-1-pipeline-cơ-bản"><a class="header" href="#ví-dụ-1-pipeline-cơ-bản">Ví dụ 1: Pipeline cơ bản</a></h2>
<p>Tạo file <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use anyhow::Result;

fn main() -&gt; Result&lt;()&gt; {
    // Đọc CSV file
    let df = CsvReader::from_path("sales_data.csv")?
        .has_header(true)
        .finish()?;

    println!("Dữ liệu gốc:");
    println!("{:?}", df);

    // Transform: tính tổng revenue theo category
    let result = df
        .lazy()
        .group_by([col("category")])
        .agg([
            col("revenue").sum().alias("total_revenue"),
            col("quantity").sum().alias("total_quantity"),
            col("revenue").mean().alias("avg_revenue"),
        ])
        .sort("total_revenue", Default::default())
        .collect()?;

    println!("\nKết quả sau khi xử lý:");
    println!("{:?}", result);

    // Ghi ra Parquet file
    let mut file = std::fs::File::create("output.parquet")?;
    ParquetWriter::new(&amp;mut file).finish(&amp;mut result.clone())?;

    println!("\n✅ Đã ghi kết quả vào output.parquet");

    Ok(())
}</code></pre></pre>
<p>Tạo file dữ liệu mẫu <code>sales_data.csv</code>:</p>
<pre><code class="language-csv">category,product,revenue,quantity
Electronics,Laptop,1200,2
Electronics,Mouse,25,10
Books,Novel,15,5
Books,Textbook,80,3
Electronics,Keyboard,75,4
Books,Magazine,5,20
</code></pre>
<p>Chạy pipeline:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<h2 id="ví-dụ-2-pipeline-với-lazy-evaluation"><a class="header" href="#ví-dụ-2-pipeline-với-lazy-evaluation">Ví dụ 2: Pipeline với Lazy Evaluation</a></h2>
<p>Lazy evaluation giúp tối ưu performance bằng cách chỉ thực hiện computation khi cần thiết:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use anyhow::Result;

fn process_large_dataset() -&gt; Result&lt;()&gt; {
    let lazy_df = LazyCsvReader::new("large_dataset.csv")
        .has_header(true)
        .finish()?;

    // Định nghĩa pipeline (chưa thực thi)
    let result = lazy_df
        .filter(col("revenue").gt(100))  // Lọc revenue &gt; 100
        .select([
            col("date"),
            col("category"),
            col("revenue"),
            (col("revenue") * lit(0.1)).alias("tax"),  // Tính 10% tax
            (col("revenue") * lit(0.9)).alias("net_revenue"),
        ])
        .group_by([col("category")])
        .agg([
            col("net_revenue").sum().alias("total_net_revenue"),
            col("revenue").count().alias("transaction_count"),
        ])
        .sort("total_net_revenue", SortOptions::default().with_order_descending(true))
        .collect()?;  // Thực thi tại đây

    println!("{:?}", result);
    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    process_large_dataset()?;
    Ok(())
}</code></pre></pre>
<p><strong>Ưu điểm của lazy evaluation:</strong></p>
<ul>
<li>Polars tự động tối ưu query plan</li>
<li>Chỉ đọc columns cần thiết</li>
<li>Có thể parallel processing tự động</li>
<li>Giảm memory usage</li>
</ul>
<h2 id="ví-dụ-3-pipeline-với-error-handling"><a class="header" href="#ví-dụ-3-pipeline-với-error-handling">Ví dụ 3: Pipeline với Error Handling</a></h2>
<p>Trong production, error handling rất quan trọng:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use anyhow::{Context, Result};

fn read_and_validate_data(path: &amp;str) -&gt; Result&lt;DataFrame&gt; {
    let df = CsvReader::from_path(path)
        .context(format!("Không thể đọc file: {}", path))?
        .has_header(true)
        .finish()
        .context("Lỗi parse CSV")?;

    // Validate schema
    if !df.get_column_names().contains(&amp;"revenue") {
        anyhow::bail!("Thiếu column 'revenue'");
    }

    Ok(df)
}

fn transform_data(df: DataFrame) -&gt; Result&lt;DataFrame&gt; {
    df.lazy()
        .select([
            col("category"),
            col("revenue"),
            col("quantity"),
        ])
        .filter(col("revenue").gt(0))  // Lọc bỏ invalid data
        .filter(col("quantity").gt(0))
        .collect()
        .context("Lỗi transform data")
}

fn save_to_parquet(df: &amp;mut DataFrame, path: &amp;str) -&gt; Result&lt;()&gt; {
    let file = std::fs::File::create(path)
        .context(format!("Không thể tạo file: {}", path))?;

    ParquetWriter::new(&amp;file)
        .finish(df)
        .context("Lỗi ghi Parquet file")?;

    Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
    println!("🚀 Bắt đầu data pipeline...");

    let df = read_and_validate_data("sales_data.csv")?;
    println!("✅ Đọc dữ liệu thành công: {} rows", df.height());

    let mut result = transform_data(df)?;
    println!("✅ Transform thành công: {} rows", result.height());

    save_to_parquet(&amp;mut result, "output.parquet")?;
    println!("✅ Đã lưu vào output.parquet");

    Ok(())
}</code></pre></pre>
<h2 id="ví-dụ-4-parallel-processing-với-rayon"><a class="header" href="#ví-dụ-4-parallel-processing-với-rayon">Ví dụ 4: Parallel Processing với Rayon</a></h2>
<p>Xử lý nhiều files cùng lúc:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use rayon::prelude::*;
use anyhow::Result;
use std::path::PathBuf;

fn process_file(path: PathBuf) -&gt; Result&lt;DataFrame&gt; {
    let df = CsvReader::from_path(&amp;path)?
        .has_header(true)
        .finish()?;

    let result = df
        .lazy()
        .group_by([col("category")])
        .agg([col("revenue").sum()])
        .collect()?;

    Ok(result)
}

fn main() -&gt; Result&lt;()&gt; {
    let files = vec![
        PathBuf::from("data1.csv"),
        PathBuf::from("data2.csv"),
        PathBuf::from("data3.csv"),
    ];

    // Xử lý parallel
    let results: Vec&lt;Result&lt;DataFrame&gt;&gt; = files
        .into_par_iter()
        .map(process_file)
        .collect();

    // Kết hợp kết quả
    let mut combined = DataFrame::default();
    for result in results {
        match result {
            Ok(df) =&gt; {
                if combined.is_empty() {
                    combined = df;
                } else {
                    combined = combined.vstack(&amp;df)?;
                }
            }
            Err(e) =&gt; eprintln!("Lỗi xử lý file: {}", e),
        }
    }

    println!("Tổng hợp: {:?}", combined);
    Ok(())
}</code></pre></pre>
<h2 id="so-sánh-với-python"><a class="header" href="#so-sánh-với-python">So sánh với Python</a></h2>
<p>Pipeline tương tự trong Python với Pandas:</p>
<pre><code class="language-python">import pandas as pd

# Đọc CSV
df = pd.read_csv('sales_data.csv')

# Transform
result = df.groupby('category').agg({
    'revenue': ['sum', 'mean'],
    'quantity': 'sum'
}).reset_index()

# Ghi Parquet
result.to_parquet('output.parquet')
</code></pre>
<p><strong>Ưu điểm của Rust + Polars:</strong></p>
<ul>
<li>Nhanh hơn 5-10x so với Pandas</li>
<li>Memory efficient hơn nhiều</li>
<li>Type safety tại compile time</li>
<li>Không cần GIL (Global Interpreter Lock) như Python</li>
<li>Binary nhỏ gọn, dễ deploy</li>
</ul>
<p><strong>Nhược điểm:</strong></p>
<ul>
<li>Compile time lâu hơn</li>
<li>Ecosystem nhỏ hơn Python (nhưng đang phát triển nhanh)</li>
<li>Learning curve cao hơn</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Sử dụng Lazy Evaluation khi làm việc với large datasets:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = LazyCsvReader::new("large.csv")
    .finish()?
    .filter(...)
    .select(...)
    .collect()?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Streaming cho data quá lớn:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader = CsvReader::from_path("huge.csv")?
    .has_header(true)
    .with_chunk_size(10_000);  // Đọc từng chunk
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Sử dụng Parquet thay vì CSV cho storage:</strong></p>
<ul>
<li>Nhanh hơn nhiều khi đọc</li>
<li>Tiết kiệm storage (compressed)</li>
<li>Preserve data types</li>
</ul>
</li>
<li>
<p><strong>Error handling với <code>anyhow</code> hoặc <code>thiserror</code>:</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process() -&gt; Result&lt;()&gt; {
    let df = read_csv("data.csv")
        .context("Failed to read CSV")?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="monitoring-và-logging"><a class="header" href="#monitoring-và-logging">Monitoring và Logging</a></h2>
<p>Thêm logging để theo dõi pipeline:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use anyhow::Result;

fn main() -&gt; Result&lt;()&gt; {
    let start = std::time::Instant::now();

    let df = CsvReader::from_path("data.csv")?
        .has_header(true)
        .finish()?;

    println!("⏱️  Đọc CSV: {:?}", start.elapsed());

    let transform_start = std::time::Instant::now();
    let result = df.lazy()
        .group_by([col("category")])
        .agg([col("revenue").sum()])
        .collect()?;

    println!("⏱️  Transform: {:?}", transform_start.elapsed());
    println!("📊 Số rows: {}", result.height());

    Ok(())
}</code></pre></pre>
<h2 id="tổng-kết"><a class="header" href="#tổng-kết">Tổng kết</a></h2>
<p>Rust + Polars là một stack mạnh mẽ để xây dựng data pipeline:</p>
<ul>
<li>✅ Performance cao</li>
<li>✅ Memory safe</li>
<li>✅ Dễ deploy (single binary)</li>
<li>✅ Ecosystem đang phát triển mạnh</li>
</ul>
<p>Bắt đầu với các pipeline đơn giản, sau đó mở rộng với streaming, parallel processing, và distributed computing với các tools như DataFusion và Ballista.</p>
<h2 id="references-40"><a class="header" href="#references-40">References</a></h2>
<ul>
<li><a href="https://docs.pola.rs/">Polars Documentation</a></li>
<li><a href="https://docs.pola.rs/user-guide/">Polars User Guide</a></li>
<li><a href="https://arewedatayet.com">Are We Data Yet?</a></li>
<li><a href="https://arrow.apache.org/">Apache Arrow</a></li>
<li><a href="https://datafusion.apache.org/">DataFusion</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-scalable-data-driven-applications-using-rust"><a class="header" href="#building-scalable-data-driven-applications-using-rust">Building scalable data-driven applications using Rust</a></h1>
<p>Data-driven applications cần xử lý, phân tích và serve dữ liệu một cách nhanh chóng và đáng tin cậy. Rust với performance cao, memory safety và concurrency mạnh mẽ là lựa chọn tuyệt vời để xây dựng các ứng dụng data-driven có khả năng scale.</p>
<p>Trong bài này, chúng ta sẽ tìm hiểu cách xây dựng một ứng dụng data-driven hoàn chỉnh với các thành phần:</p>
<ul>
<li>Data ingestion và processing</li>
<li>Storage và indexing</li>
<li>Query engine</li>
<li>API để serve data</li>
</ul>
<h2 id="kiến-trúc-ứng-dụng-data-driven"><a class="header" href="#kiến-trúc-ứng-dụng-data-driven">Kiến trúc ứng dụng Data-Driven</a></h2>
<pre><code>┌─────────────┐
│ Data Sources│ (CSV, JSON, API, Database)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  Ingestion  │ (tokio, reqwest, async-std)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Processing  │ (polars, arrow, datafusion)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Storage   │ (parquet, sled, rocksdb)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Query Engine│ (datafusion, tantivy)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  API Server │ (actix-web, axum, rocket)
└─────────────┘
</code></pre>
<h2 id="ví-dụ-1-data-ingestion-với-tokio"><a class="header" href="#ví-dụ-1-data-ingestion-với-tokio">Ví dụ 1: Data Ingestion với Tokio</a></h2>
<p>Xây dựng service để ingest data từ nhiều nguồn:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::fs::File;
use tokio::io::AsyncReadExt;
use reqwest;
use anyhow::Result;

/// Đọc data từ file
async fn ingest_from_file(path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path).await?;
    let mut contents = Vec::new();
    file.read_to_end(&amp;mut contents).await?;
    Ok(contents)
}

/// Fetch data từ HTTP API
async fn ingest_from_api(url: &amp;str) -&gt; Result&lt;String&gt; {
    let response = reqwest::get(url).await?;
    let body = response.text().await?;
    Ok(body)
}

/// Ingest data từ nhiều nguồn đồng thời
async fn ingest_all() -&gt; Result&lt;()&gt; {
    // Chạy parallel
    let (file_data, api_data) = tokio::join!(
        ingest_from_file("data.csv"),
        ingest_from_api("https://api.example.com/data")
    );

    println!("File data size: {}", file_data?.len());
    println!("API data: {}", api_data?);

    Ok(())
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    ingest_all().await?;
    Ok(())
}</code></pre></pre>
<h2 id="ví-dụ-2-processing-với-datafusion"><a class="header" href="#ví-dụ-2-processing-với-datafusion">Ví dụ 2: Processing với DataFusion</a></h2>
<p>DataFusion là SQL query engine sử dụng Apache Arrow, cực kỳ nhanh:</p>
<pre><code class="language-toml">[dependencies]
datafusion = "43.0"
tokio = { version = "1.48", features = ["full"] }
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use datafusion::prelude::*;
use anyhow::Result;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Tạo SessionContext
    let ctx = SessionContext::new();

    // Đăng ký Parquet file như một table
    ctx.register_parquet("sales", "sales_data.parquet", ParquetReadOptions::default())
        .await?;

    // Chạy SQL query
    let df = ctx.sql(
        "SELECT
            category,
            SUM(revenue) as total_revenue,
            AVG(revenue) as avg_revenue,
            COUNT(*) as num_transactions
        FROM sales
        WHERE revenue &gt; 100
        GROUP BY category
        ORDER BY total_revenue DESC"
    ).await?;

    // Hiển thị kết quả
    df.show().await?;

    // Hoặc lưu lại thành Parquet
    df.write_parquet("output.parquet", None, None).await?;

    Ok(())
}</code></pre></pre>
<p><strong>Ưu điểm của DataFusion:</strong></p>
<ul>
<li>Tốc độ cực nhanh (columnar processing)</li>
<li>Hỗ trợ SQL standard</li>
<li>Có thể scale đến hàng TB dữ liệu</li>
<li>Zero-copy reads với Arrow</li>
</ul>
<h2 id="ví-dụ-3-storage-với-parquet"><a class="header" href="#ví-dụ-3-storage-với-parquet">Ví dụ 3: Storage với Parquet</a></h2>
<p>Parquet là format columnar storage rất hiệu quả:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use anyhow::Result;

fn save_to_parquet(df: &amp;mut DataFrame, path: &amp;str) -&gt; Result&lt;()&gt; {
    let file = std::fs::File::create(path)?;

    ParquetWriter::new(&amp;file)
        .with_compression(ParquetCompression::Snappy)  // Nén data
        .finish(df)?;

    Ok(())
}

fn read_from_parquet(path: &amp;str) -&gt; Result&lt;DataFrame&gt; {
    let df = ParquetReader::new(std::fs::File::open(path)?)
        .finish()?;
    Ok(df)
}

fn main() -&gt; Result&lt;()&gt; {
    // Tạo sample data
    let mut df = df! {
        "id" =&gt; &amp;[1, 2, 3, 4, 5],
        "name" =&gt; &amp;["Alice", "Bob", "Charlie", "David", "Eve"],
        "revenue" =&gt; &amp;[1200.50, 800.30, 1500.75, 950.20, 1100.00],
    }?;

    // Lưu
    save_to_parquet(&amp;mut df, "users.parquet")?;
    println!("✅ Đã lưu data");

    // Đọc lại
    let loaded = read_from_parquet("users.parquet")?;
    println!("{:?}", loaded);

    Ok(())
}</code></pre></pre>
<h2 id="ví-dụ-4-full-text-search-với-tantivy"><a class="header" href="#ví-dụ-4-full-text-search-với-tantivy">Ví dụ 4: Full-text Search với Tantivy</a></h2>
<p>Tantivy là full-text search engine tương tự Lucene/Elasticsearch:</p>
<pre><code class="language-toml">[dependencies]
tantivy = "0.22"
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use tantivy::schema::*;
use tantivy::{doc, Index, IndexWriter, ReloadPolicy};
use tantivy::collector::TopDocs;
use tantivy::query::QueryParser;
use anyhow::Result;

fn main() -&gt; Result&lt;()&gt; {
    // Định nghĩa schema
    let mut schema_builder = Schema::builder();
    schema_builder.add_text_field("title", TEXT | STORED);
    schema_builder.add_text_field("body", TEXT);
    let schema = schema_builder.build();

    // Tạo index
    let index = Index::create_in_ram(schema.clone());
    let mut index_writer: IndexWriter = index.writer(50_000_000)?;

    // Index documents
    let title = schema.get_field("title").unwrap();
    let body = schema.get_field("body").unwrap();

    index_writer.add_document(doc!(
        title =&gt; "Rust Programming",
        body =&gt; "Rust is a systems programming language that runs blazingly fast"
    ))?;

    index_writer.add_document(doc!(
        title =&gt; "Data Engineering",
        body =&gt; "Building scalable data pipelines with Rust and Polars"
    ))?;

    index_writer.commit()?;

    // Search
    let reader = index
        .reader_builder()
        .reload_policy(ReloadPolicy::OnCommitWithDelay)
        .try_into()?;

    let searcher = reader.searcher();

    let query_parser = QueryParser::for_index(&amp;index, vec![title, body]);
    let query = query_parser.parse_query("Rust")?;

    let top_docs = searcher.search(&amp;query, &amp;TopDocs::with_limit(10))?;

    println!("Tìm thấy {} kết quả:", top_docs.len());
    for (_score, doc_address) in top_docs {
        let retrieved_doc = searcher.doc(doc_address)?;
        println!("{}", schema.to_json(&amp;retrieved_doc));
    }

    Ok(())
}</code></pre></pre>
<h2 id="ví-dụ-5-api-server-với-axum"><a class="header" href="#ví-dụ-5-api-server-với-axum">Ví dụ 5: API Server với Axum</a></h2>
<p>Xây dựng REST API để serve data:</p>
<pre><code class="language-toml">[dependencies]
axum = "0.7"
tokio = { version = "1.48", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
datafusion = "43.0"
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use axum::{
    extract::{Query, State},
    http::StatusCode,
    routing::get,
    Json, Router,
};
use datafusion::prelude::*;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use anyhow::Result;

#[derive(Clone)]
struct AppState {
    ctx: Arc&lt;SessionContext&gt;,
}

#[derive(Deserialize)]
struct QueryParams {
    category: Option&lt;String&gt;,
    min_revenue: Option&lt;f64&gt;,
}

#[derive(Serialize)]
struct SalesRecord {
    category: String,
    total_revenue: f64,
    num_transactions: i64,
}

async fn query_sales(
    State(state): State&lt;AppState&gt;,
    Query(params): Query&lt;QueryParams&gt;,
) -&gt; Result&lt;Json&lt;Vec&lt;SalesRecord&gt;&gt;, StatusCode&gt; {
    // Build SQL query dựa trên params
    let mut sql = String::from(
        "SELECT category,
         SUM(revenue) as total_revenue,
         COUNT(*) as num_transactions
         FROM sales WHERE 1=1"
    );

    if let Some(cat) = params.category {
        sql.push_str(&amp;format!(" AND category = '{}'", cat));
    }

    if let Some(min_rev) = params.min_revenue {
        sql.push_str(&amp;format!(" AND revenue &gt;= {}", min_rev));
    }

    sql.push_str(" GROUP BY category");

    // Execute query
    let df = state.ctx.sql(&amp;sql)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Convert to JSON (simplified)
    let records = vec![
        SalesRecord {
            category: "Electronics".to_string(),
            total_revenue: 5000.0,
            num_transactions: 100,
        }
    ];

    Ok(Json(records))
}

async fn health_check() -&gt; &amp;'static str {
    "OK"
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Setup DataFusion
    let ctx = SessionContext::new();
    ctx.register_parquet("sales", "sales_data.parquet", ParquetReadOptions::default())
        .await?;

    let state = AppState {
        ctx: Arc::new(ctx),
    };

    // Build router
    let app = Router::new()
        .route("/health", get(health_check))
        .route("/api/sales", get(query_sales))
        .with_state(state);

    // Run server
    println!("🚀 Server chạy tại http://localhost:3000");
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;

    Ok(())
}</code></pre></pre>
<p>Test API:</p>
<pre><code class="language-bash"># Health check
curl http://localhost:3000/health

# Query với params
curl "http://localhost:3000/api/sales?category=Electronics&amp;min_revenue=100"
</code></pre>
<h2 id="ví-dụ-6-real-time-processing-với-channels"><a class="header" href="#ví-dụ-6-real-time-processing-với-channels">Ví dụ 6: Real-time Processing với Channels</a></h2>
<p>Xử lý data streaming real-time:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use tokio::sync::mpsc;
use tokio::time::{Duration, sleep};
use anyhow::Result;

#[derive(Debug, Clone)]
struct DataPoint {
    timestamp: i64,
    value: f64,
}

async fn producer(tx: mpsc::Sender&lt;DataPoint&gt;) {
    let mut counter = 0;
    loop {
        let data = DataPoint {
            timestamp: counter,
            value: (counter as f64) * 1.5,
        };

        if tx.send(data).await.is_err() {
            println!("Receiver dropped");
            break;
        }

        counter += 1;
        sleep(Duration::from_millis(100)).await;
    }
}

async fn processor(mut rx: mpsc::Receiver&lt;DataPoint&gt;) {
    let mut buffer = Vec::new();
    let batch_size = 10;

    while let Some(data) = rx.recv().await {
        buffer.push(data);

        if buffer.len() &gt;= batch_size {
            // Process batch
            let sum: f64 = buffer.iter().map(|d| d.value).sum();
            let avg = sum / buffer.len() as f64;

            println!("📊 Batch processed: {} records, avg = {:.2}", buffer.len(), avg);

            buffer.clear();
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let (tx, rx) = mpsc::channel(100);

    // Spawn producer và processor
    let producer_handle = tokio::spawn(producer(tx));
    let processor_handle = tokio::spawn(processor(rx));

    // Chạy 5 giây
    sleep(Duration::from_secs(5)).await;
    producer_handle.abort();

    processor_handle.await?;

    Ok(())
}</code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-sử-dụng-columnar-format"><a class="header" href="#1-sử-dụng-columnar-format">1. Sử dụng Columnar Format</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Tốt: Parquet (columnar)
ParquetWriter::new(&amp;file).finish(&amp;mut df)?;

// ❌ Tránh: CSV cho large datasets
// CSV rất chậm và tốn memory
<span class="boring">}</span></code></pre></pre>
<h3 id="2-lazy-evaluation"><a class="header" href="#2-lazy-evaluation">2. Lazy Evaluation</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Tốt: Lazy evaluation
let result = df.lazy()
    .filter(...)
    .select(...)
    .collect()?;  // Chỉ execute 1 lần

// ❌ Tránh: Eager evaluation
let df = df.filter(...)?;  // Execute ngay
let df = df.select(...)?;  // Execute lại
<span class="boring">}</span></code></pre></pre>
<h3 id="3-batch-processing"><a class="header" href="#3-batch-processing">3. Batch Processing</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Tốt: Process theo batch
for chunk in data.chunks(10_000) {
    process_chunk(chunk);
}

// ❌ Tránh: Process từng item
for item in data {
    process_item(item);  // Chậm!
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-connection-pooling"><a class="header" href="#4-connection-pooling">4. Connection Pooling</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deadpool_postgres::{Config, Pool};

// ✅ Tốt: Dùng connection pool
let pool = config.create_pool(None, NoTls)?;
let client = pool.get().await?;

// ❌ Tránh: Tạo connection mỗi lần query
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-và-observability"><a class="header" href="#monitoring-và-observability">Monitoring và Observability</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use std::time::Instant;

fn main() -&gt; Result&lt;()&gt; {
    let start = Instant::now();

    // Process data
    let df = process_data()?;

    println!("⏱️  Processing time: {:?}", start.elapsed());
    println!("📊 Records processed: {}", df.height());
    println!("💾 Memory used: {} MB", df.estimated_size() / 1_000_000);

    Ok(())
}</code></pre></pre>
<h2 id="so-sánh-performance"><a class="header" href="#so-sánh-performance">So sánh Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Python/Pandas</th><th>Rust/Polars</th><th>Speedup</th></tr></thead><tbody>
<tr><td>Read CSV (1GB)</td><td>5.2s</td><td>0.8s</td><td>6.5x</td></tr>
<tr><td>GroupBy + Agg</td><td>3.1s</td><td>0.4s</td><td>7.8x</td></tr>
<tr><td>Join (10M rows)</td><td>12.5s</td><td>1.2s</td><td>10.4x</td></tr>
<tr><td>Write Parquet</td><td>2.8s</td><td>0.5s</td><td>5.6x</td></tr>
</tbody></table>
</div>
<h2 id="tổng-kết-1"><a class="header" href="#tổng-kết-1">Tổng kết</a></h2>
<p>Rust cung cấp ecosystem mạnh mẽ để xây dựng data-driven applications:</p>
<ul>
<li>✅ <strong>DataFusion</strong>: SQL query engine cực nhanh</li>
<li>✅ <strong>Polars</strong>: DataFrame library như Pandas nhưng nhanh hơn nhiều</li>
<li>✅ <strong>Tantivy</strong>: Full-text search engine</li>
<li>✅ <strong>Arrow</strong>: Columnar format chuẩn công nghiệp</li>
<li>✅ <strong>Tokio</strong>: Async runtime cho concurrent processing</li>
<li>✅ <strong>Axum/Actix</strong>: Web frameworks để serve data</li>
</ul>
<p>Với Rust, bạn có thể xây dựng ứng dụng vừa nhanh, vừa safe, vừa dễ maintain và scale.</p>
<h2 id="references-41"><a class="header" href="#references-41">References</a></h2>
<ul>
<li><a href="https://datafusion.apache.org/">DataFusion Documentation</a></li>
<li><a href="https://docs.pola.rs/">Polars Documentation</a></li>
<li><a href="https://docs.rs/tantivy/">Tantivy Documentation</a></li>
<li><a href="https://arrow.apache.org/">Apache Arrow</a></li>
<li><a href="https://arewedatayet.com">Are We Data Yet?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-as-an-alternative-to-python-for-data-engineering-tasks"><a class="header" href="#rust-as-an-alternative-to-python-for-data-engineering-tasks">Rust as an alternative to Python for data engineering tasks</a></h1>
<p>Python đã thống trị lĩnh vực data engineering trong nhiều năm với các tools như Pandas, Spark, và Airflow. Tuy nhiên, Rust đang nổi lên như một lựa chọn thay thế hấp dẫn với performance vượt trội, memory safety, và khả năng concurrent processing mạnh mẽ.</p>
<p>Bài này sẽ so sánh chi tiết giữa Python và Rust trong các use case phổ biến của data engineering, giúp bạn quyết định khi nào nên dùng Rust thay vì Python.</p>
<h2 id="so-sánh-tổng-quan"><a class="header" href="#so-sánh-tổng-quan">So sánh tổng quan</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Tiêu chí</th><th>Python</th><th>Rust</th></tr></thead><tbody>
<tr><td><strong>Performance</strong></td><td>Chậm (interpreted)</td><td>Rất nhanh (compiled, gần C++)</td></tr>
<tr><td><strong>Memory Usage</strong></td><td>Cao (GIL, GC overhead)</td><td>Thấp (no GC, zero-cost abstractions)</td></tr>
<tr><td><strong>Type Safety</strong></td><td>Dynamic typing (runtime errors)</td><td>Static typing (compile-time checks)</td></tr>
<tr><td><strong>Concurrency</strong></td><td>Hạn chế (GIL)</td><td>Excellent (no GIL, fearless concurrency)</td></tr>
<tr><td><strong>Ecosystem</strong></td><td>Rất lớn (mature)</td><td>Đang phát triển nhanh</td></tr>
<tr><td><strong>Learning Curve</strong></td><td>Dễ học</td><td>Khó hơn (ownership, lifetimes)</td></tr>
<tr><td><strong>Development Speed</strong></td><td>Nhanh (scripting)</td><td>Chậm hơn (compile time)</td></tr>
</tbody></table>
</div>
<h2 id="1-datafusion-vs-apache-spark"><a class="header" href="#1-datafusion-vs-apache-spark">1. DataFusion vs Apache Spark</a></h2>
<h3 id="apache-spark-pythonscala"><a class="header" href="#apache-spark-pythonscala">Apache Spark (Python/Scala)</a></h3>
<pre><code class="language-python">from pyspark.sql import SparkSession

spark = SparkSession.builder.appName("example").getOrCreate()

# Đọc data
df = spark.read.parquet("sales.parquet")

# Transform
result = df.groupBy("category") \
    .agg({"revenue": "sum", "quantity": "count"}) \
    .orderBy("sum(revenue)", ascending=False)

result.show()
</code></pre>
<p><strong>Nhược điểm:</strong></p>
<ul>
<li>Overhead của JVM</li>
<li>GC pauses</li>
<li>Slow startup time</li>
<li>Resource hungry (cần nhiều RAM)</li>
</ul>
<h3 id="datafusion-rust"><a class="header" href="#datafusion-rust">DataFusion (Rust)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use datafusion::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let ctx = SessionContext::new();

    // Đọc data
    ctx.register_parquet("sales", "sales.parquet", ParquetReadOptions::default())
        .await?;

    // Transform với SQL
    let df = ctx.sql(
        "SELECT category,
         SUM(revenue) as total_revenue,
         COUNT(quantity) as num_transactions
         FROM sales
         GROUP BY category
         ORDER BY total_revenue DESC"
    ).await?;

    df.show().await?;
    Ok(())
}</code></pre></pre>
<p><strong>Ưu điểm:</strong></p>
<ul>
<li>Nhanh hơn Spark 2-10x (tùy workload)</li>
<li>Memory efficient hơn nhiều</li>
<li>Không cần JVM</li>
<li>Startup gần như instant</li>
<li>Single binary, dễ deploy</li>
</ul>
<p><strong>Benchmark:</strong></p>
<ul>
<li>Query 1GB Parquet: DataFusion ~0.8s vs Spark ~5s</li>
<li>GroupBy + Aggregation: DataFusion ~0.4s vs Spark ~3s</li>
</ul>
<h2 id="2-polars-vs-pandas"><a class="header" href="#2-polars-vs-pandas">2. Polars vs Pandas</a></h2>
<h3 id="pandas-python"><a class="header" href="#pandas-python">Pandas (Python)</a></h3>
<pre><code class="language-python">import pandas as pd

# Đọc CSV
df = pd.read_csv('sales.csv')

# Transform
result = df.groupby('category').agg({
    'revenue': ['sum', 'mean', 'count'],
    'quantity': 'sum'
})

# Filter
filtered = df[df['revenue'] &gt; 100]

# Save
result.to_parquet('output.parquet')
</code></pre>
<p><strong>Vấn đề của Pandas:</strong></p>
<ul>
<li>Chậm với large datasets (&gt;1GB)</li>
<li>Single-threaded (không tận dụng multi-core)</li>
<li>High memory usage</li>
<li>Chained operations không được optimize</li>
</ul>
<h3 id="polars-rust"><a class="header" href="#polars-rust">Polars (Rust)</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;

fn main() -&gt; Result&lt;()&gt; {
    // Đọc CSV với lazy evaluation
    let df = LazyCsvReader::new("sales.csv")
        .has_header(true)
        .finish()?
        .filter(col("revenue").gt(100))
        .group_by([col("category")])
        .agg([
            col("revenue").sum().alias("sum_revenue"),
            col("revenue").mean().alias("avg_revenue"),
            col("revenue").count().alias("count"),
            col("quantity").sum().alias("sum_quantity"),
        ])
        .collect()?;

    // Save
    let mut file = std::fs::File::create("output.parquet")?;
    ParquetWriter::new(&amp;mut file).finish(&amp;mut df.clone())?;

    Ok(())
}</code></pre></pre>
<p><strong>Ưu điểm Polars:</strong></p>
<ul>
<li>Nhanh hơn Pandas 5-15x</li>
<li>Multi-threaded by default</li>
<li>Lazy evaluation (query optimization)</li>
<li>Memory efficient (zero-copy operations)</li>
<li>Syntax gần giống Pandas</li>
</ul>
<p><strong>Benchmark (1GB CSV):</strong></p>
<pre><code>Read CSV:       Pandas 5.2s  | Polars 0.8s  (6.5x faster)
GroupBy + Agg:  Pandas 3.1s  | Polars 0.4s  (7.8x faster)
Filter + Sort:  Pandas 2.5s  | Polars 0.3s  (8.3x faster)
Write Parquet:  Pandas 2.8s  | Polars 0.5s  (5.6x faster)
</code></pre>
<h2 id="3-search-meilisearch-vs-elasticsearch"><a class="header" href="#3-search-meilisearch-vs-elasticsearch">3. Search: Meilisearch vs Elasticsearch</a></h2>
<h3 id="elasticsearch-javapython-client"><a class="header" href="#elasticsearch-javapython-client">Elasticsearch (Java/Python client)</a></h3>
<pre><code class="language-python">from elasticsearch import Elasticsearch

es = Elasticsearch(['localhost:9200'])

# Index document
es.index(index='products', body={
    'name': 'Laptop',
    'category': 'Electronics',
    'price': 1200
})

# Search
results = es.search(index='products', body={
    'query': {
        'match': {'category': 'Electronics'}
    }
})
</code></pre>
<p><strong>Nhược điểm:</strong></p>
<ul>
<li>Heavy (JVM, nhiều memory)</li>
<li>Complex configuration</li>
<li>Slow startup</li>
<li>Resource intensive</li>
</ul>
<h3 id="meilisearch-rust"><a class="header" href="#meilisearch-rust">Meilisearch (Rust)</a></h3>
<p>Meilisearch là full-text search engine viết bằng Rust, cực kỳ nhanh và dễ sử dụng:</p>
<pre><code class="language-bash"># Cài đặt và chạy
curl -L https://install.meilisearch.com | sh
./meilisearch

# Hoặc dùng Docker
docker run -p 7700:7700 getmeili/meilisearch
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2021">use meilisearch_sdk::client::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct Product {
    id: usize,
    name: String,
    category: String,
    price: f64,
}

#[tokio::main]
async fn main() {
    let client = Client::new("http://localhost:7700", Some("masterKey"));

    // Index documents
    let products = vec![
        Product { id: 1, name: "Laptop".to_string(), category: "Electronics".to_string(), price: 1200.0 },
        Product { id: 2, name: "Mouse".to_string(), category: "Electronics".to_string(), price: 25.0 },
    ];

    let index = client.index("products");
    index.add_documents(&amp;products, Some("id")).await.unwrap();

    // Search
    let results = index.search()
        .with_query("Electronics")
        .execute::&lt;Product&gt;()
        .await
        .unwrap();

    println!("Found: {:?}", results.hits);
}</code></pre></pre>
<p><strong>Ưu điểm Meilisearch:</strong></p>
<ul>
<li>Cực nhanh (search &lt;50ms)</li>
<li>Low memory footprint</li>
<li>Instant startup</li>
<li>Typo-tolerant search</li>
<li>API đơn giản</li>
<li>Single binary</li>
</ul>
<h2 id="4-etl-pipelines"><a class="header" href="#4-etl-pipelines">4. ETL Pipelines</a></h2>
<h3 id="python-với-airflow"><a class="header" href="#python-với-airflow">Python với Airflow</a></h3>
<pre><code class="language-python">from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime
import pandas as pd

def extract():
    df = pd.read_csv('source.csv')
    df.to_pickle('/tmp/data.pkl')

def transform():
    df = pd.read_pickle('/tmp/data.pkl')
    result = df.groupby('category').sum()
    result.to_pickle('/tmp/transformed.pkl')

def load():
    df = pd.read_pickle('/tmp/transformed.pkl')
    df.to_parquet('output.parquet')

dag = DAG('etl_pipeline', start_date=datetime(2024, 1, 1))

extract_task = PythonOperator(task_id='extract', python_callable=extract, dag=dag)
transform_task = PythonOperator(task_id='transform', python_callable=transform, dag=dag)
load_task = PythonOperator(task_id='load', python_callable=load, dag=dag)

extract_task &gt;&gt; transform_task &gt;&gt; load_task
</code></pre>
<h3 id="rust-với-custom-pipeline"><a class="header" href="#rust-với-custom-pipeline">Rust với Custom Pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use polars::prelude::*;
use anyhow::Result;

struct Pipeline;

impl Pipeline {
    fn extract() -&gt; Result&lt;DataFrame&gt; {
        let df = CsvReader::from_path("source.csv")?
            .has_header(true)
            .finish()?;
        Ok(df)
    }

    fn transform(df: DataFrame) -&gt; Result&lt;DataFrame&gt; {
        let result = df.lazy()
            .group_by([col("category")])
            .agg([col("revenue").sum()])
            .collect()?;
        Ok(result)
    }

    fn load(df: &amp;mut DataFrame) -&gt; Result&lt;()&gt; {
        let file = std::fs::File::create("output.parquet")?;
        ParquetWriter::new(&amp;file).finish(df)?;
        Ok(())
    }

    fn run() -&gt; Result&lt;()&gt; {
        println!("🚀 Starting ETL pipeline...");

        let df = Self::extract()?;
        println!("✅ Extract: {} rows", df.height());

        let mut result = Self::transform(df)?;
        println!("✅ Transform: {} rows", result.height());

        Self::load(&amp;mut result)?;
        println!("✅ Load complete");

        Ok(())
    }
}

fn main() -&gt; Result&lt;()&gt; {
    Pipeline::run()
}</code></pre></pre>
<p><strong>Ưu điểm Rust ETL:</strong></p>
<ul>
<li>Nhanh hơn nhiều (5-10x)</li>
<li>Type-safe (catch errors at compile time)</li>
<li>Low resource usage</li>
<li>Dễ deploy (single binary)</li>
<li>No runtime dependencies</li>
</ul>
<p><strong>Khi nào dùng Rust thay vì Airflow:</strong></p>
<ul>
<li>Simple pipelines không cần UI</li>
<li>Performance critical</li>
<li>Resource constraints</li>
<li>Need for type safety</li>
</ul>
<h2 id="5-data-validation"><a class="header" href="#5-data-validation">5. Data Validation</a></h2>
<h3 id="pandera-python"><a class="header" href="#pandera-python">Pandera (Python)</a></h3>
<pre><code class="language-python">import pandas as pd
import pandera as pa

schema = pa.DataFrameSchema({
    "id": pa.Column(int, pa.Check.greater_than(0)),
    "revenue": pa.Column(float, pa.Check.in_range(0, 1000000)),
    "category": pa.Column(str, pa.Check.isin(["Electronics", "Books"]))
})

df = pd.read_csv("data.csv")
validated = schema.validate(df)  # Runtime check
</code></pre>
<h3 id="rust-với-type-system"><a class="header" href="#rust-với-type-system">Rust với Type System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct SalesRecord {
    id: u32,              // Always positive
    revenue: f64,
    category: Category,   // Only valid categories
}

#[derive(Deserialize, Debug)]
enum Category {
    Electronics,
    Books,
}

fn main() -&gt; Result&lt;()&gt; {
    let mut reader = csv::Reader::from_path("data.csv")?;

    for result in reader.deserialize() {
        let record: SalesRecord = result?;  // Compile-time + parse-time validation
        println!("{:?}", record);
    }

    Ok(())
}</code></pre></pre>
<p><strong>Ưu điểm Rust:</strong></p>
<ul>
<li>Validation at compile time</li>
<li>Zero runtime overhead</li>
<li>Impossible to have invalid data</li>
<li>Better IDE support (autocomplete, type hints)</li>
</ul>
<h2 id="khi-nào-nên-dùng-rust"><a class="header" href="#khi-nào-nên-dùng-rust">Khi nào nên dùng Rust?</a></h2>
<h3 id="-rust-phù-hợp-khi"><a class="header" href="#-rust-phù-hợp-khi">✅ Rust phù hợp khi:</a></h3>
<ol>
<li>
<p><strong>Performance critical:</strong></p>
<ul>
<li>Xử lý hàng TB data</li>
<li>Real-time processing</li>
<li>Low latency requirements</li>
</ul>
</li>
<li>
<p><strong>Long-running services:</strong></p>
<ul>
<li>Stream processing</li>
<li>Data ingestion services</li>
<li>API servers serving data</li>
</ul>
</li>
<li>
<p><strong>Resource constraints:</strong></p>
<ul>
<li>Limited memory</li>
<li>Cost optimization (cloud)</li>
<li>Edge computing</li>
</ul>
</li>
<li>
<p><strong>Type safety quan trọng:</strong></p>
<ul>
<li>Financial data</li>
<li>Healthcare data</li>
<li>Critical infrastructure</li>
</ul>
</li>
<li>
<p><strong>Deployment đơn giản:</strong></p>
<ul>
<li>Cần single binary</li>
<li>No Python runtime dependency</li>
<li>Container size nhỏ</li>
</ul>
</li>
</ol>
<h3 id="-python-vẫn-tốt-hơn-khi"><a class="header" href="#-python-vẫn-tốt-hơn-khi">❌ Python vẫn tốt hơn khi:</a></h3>
<ol>
<li>
<p><strong>Rapid prototyping:</strong></p>
<ul>
<li>POC, experiments</li>
<li>One-off scripts</li>
</ul>
</li>
<li>
<p><strong>Team không biết Rust:</strong></p>
<ul>
<li>Learning curve cao</li>
<li>Hiring khó hơn</li>
</ul>
</li>
<li>
<p><strong>Rich ecosystem needed:</strong></p>
<ul>
<li>Specialized ML libraries</li>
<li>Legacy integrations</li>
</ul>
</li>
<li>
<p><strong>Notebook-based workflows:</strong></p>
<ul>
<li>Jupyter notebooks</li>
<li>Interactive analysis</li>
</ul>
</li>
</ol>
<h2 id="migration-strategy"><a class="header" href="#migration-strategy">Migration Strategy</a></h2>
<p>Không cần migrate toàn bộ sang Rust cùng lúc:</p>
<h3 id="phase-1-hot-paths"><a class="header" href="#phase-1-hot-paths">Phase 1: Hot paths</a></h3>
<ul>
<li>Identify performance bottlenecks</li>
<li>Rewrite critical paths in Rust</li>
<li>Call from Python via PyO3</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyfunction]
fn process_large_dataset(data: Vec&lt;f64&gt;) -&gt; PyResult&lt;f64&gt; {
    // Rust implementation
    Ok(data.iter().sum())
}

#[pymodule]
fn my_module(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(process_large_dataset, m)?)?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-python"># Python code
import my_module

result = my_module.process_large_dataset(large_array)
</code></pre>
<h3 id="phase-2-new-services"><a class="header" href="#phase-2-new-services">Phase 2: New services</a></h3>
<ul>
<li>Xây dựng services mới bằng Rust</li>
<li>Integrate với existing Python code</li>
</ul>
<h3 id="phase-3-full-rewrite"><a class="header" href="#phase-3-full-rewrite">Phase 3: Full rewrite</a></h3>
<ul>
<li>Khi team đã quen với Rust</li>
<li>Khi performance gain rõ ràng</li>
</ul>
<h2 id="ecosystem-so-sánh"><a class="header" href="#ecosystem-so-sánh">Ecosystem so sánh</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Python</th><th>Rust</th></tr></thead><tbody>
<tr><td><strong>DataFrame</strong></td><td>Pandas</td><td>Polars</td></tr>
<tr><td><strong>SQL Engine</strong></td><td>DuckDB</td><td>DataFusion</td></tr>
<tr><td><strong>Distributed Computing</strong></td><td>Spark</td><td>Ballista</td></tr>
<tr><td><strong>Search</strong></td><td>Elasticsearch</td><td>Meilisearch, Tantivy</td></tr>
<tr><td><strong>Serialization</strong></td><td>pickle, json</td><td>Serde</td></tr>
<tr><td><strong>Async I/O</strong></td><td>asyncio</td><td>Tokio</td></tr>
<tr><td><strong>Workflow</strong></td><td>Airflow</td><td>Custom (tokio tasks)</td></tr>
<tr><td><strong>Web Framework</strong></td><td>Flask, FastAPI</td><td>Axum, Actix-web</td></tr>
</tbody></table>
</div>
<h2 id="tổng-kết-2"><a class="header" href="#tổng-kết-2">Tổng kết</a></h2>
<p>Rust không phải để thay thế hoàn toàn Python, mà là công cụ bổ sung:</p>
<p><strong>Python:</strong> Rapid development, prototyping, glue code, notebooks
<strong>Rust:</strong> Production systems, performance critical paths, long-running services</p>
<p>Chiến lược tốt nhất:</p>
<ol>
<li>Prototype trong Python</li>
<li>Identify bottlenecks</li>
<li>Rewrite critical parts trong Rust</li>
<li>Use PyO3 để integrate</li>
</ol>
<p>Trong 5-10 năm tới, Rust sẽ là lựa chọn phổ biến cho production data engineering workloads, tương tự như Go đã thay thế Python trong nhiều backend services.</p>
<h2 id="references-42"><a class="header" href="#references-42">References</a></h2>
<ul>
<li><a href="https://arewedatayet.com">Are We Data Yet?</a> - Rust data ecosystem tracker</li>
<li><a href="https://www.pola.rs/benchmarks.html">Polars Benchmarks</a></li>
<li><a href="https://arrow.apache.org/datafusion/">DataFusion vs Spark</a></li>
<li><a href="https://github.com/meilisearch/meilisearch">Meilisearch</a></li>
<li><a href="https://pyo3.rs/">PyO3 Documentation</a> - Rust bindings for Python</li>
<li><a href="https://github.com/apache/datafusion-ballista">Ballista</a> - Distributed DataFusion</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concatenating-strings-with-format"><a class="header" href="#concatenating-strings-with-format">Concatenating strings with <code>format!</code></a></h1>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = "Duyet";
let age = 18;
let message = format!("{} is {} years old", name, age);
println!("{}", message);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructor"><a class="header" href="#constructor">Constructor</a></h1>
<p>Rust không có constructors, thay vào đó có một convention là sử dụng <code>new</code> method (<a href="https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html#associated-functions">Associated Functions</a>) để tạo một instance mới của struct hoặc enum.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }
}

fn main() {
    let point = Point::new(1, 2);
    println!("({}, {})", point.x, point.y);
}</code></pre></pre>
<h1 id="the-default-trait-default-constructors"><a class="header" href="#the-default-trait-default-constructors">The Default Trait (Default Constructors)</a></h1>
<p>Rust hỗ trợ default constructor thông qua <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html">Default</a> trait.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

impl Default for Point {
    fn default() -&gt; Self {
        Point { x: 0, y: 0 }
    }
}

fn main() {
    let point = Point::default();
    println!("({}, {})", point.x, point.y);
}</code></pre></pre>
<p><code>Default</code> còn có thể sử dụng như một derive nếu tất cả các field của struct implement <code>Default</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point::default();
    println!("({}, {})", point.x, point.y);
}</code></pre></pre>
<p>Thường với một struct cơ bản chúng ta thường sẽ phải cần cả <code>new</code> và <code>Default</code> method.
Một ưu điểm của <code>Default</code> là struct hoặc enum của chúng ta có thể được sử dụng một cách
generic trong các trường hợp như dưới đây hoặc cho tất cả các <a href="https://doc.rust-lang.org/stable/std/?search=or_default"><code>*or_default()</code> functions</a>
trong standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create&lt;T: Default&gt;() -&gt; T {
    T::default()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-default-trait-default-constructors-1"><a class="header" href="#the-default-trait-default-constructors-1">The Default Trait (Default Constructors)</a></h1>
<p>Rust hỗ trợ default constructor thông qua <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html">Default</a> trait.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point {
    x: i32,
    y: i32,
}

impl Default for Point {
    fn default() -&gt; Self {
        Point { x: 0, y: 0 }
    }
}

fn main() {
    let point = Point::default();
    println!("({}, {})", point.x, point.y);
}</code></pre></pre>
<p><code>Default</code> còn có thể sử dụng như một derive nếu tất cả các field của struct implement <code>Default</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Default)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point::default();
    println!("({}, {})", point.x, point.y);
}</code></pre></pre>
<p>Thường với một struct cơ bản chúng ta thường sẽ phải cần cả <code>new</code> và <code>Default</code> method.
Một ưu điểm của <code>Default</code> là struct hoặc enum của chúng ta có thể được sử dụng một cách
generic trong các trường hợp như dưới đây hoặc cho tất cả các <a href="https://doc.rust-lang.org/stable/std/?search=or_default"><code>*or_default()</code> functions</a>
trong standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create&lt;T: Default&gt;() -&gt; T {
    T::default()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temporary-mutability"><a class="header" href="#temporary-mutability">Temporary mutability</a></h1>
<p>Thường chúng ta sẽ cần phải prepare hoặc process dữ liệu, nhưng sau đó chúng ta không cần tính mutable nữa, để tránh lỗi phát sinh ngoài ý muốn.</p>
<p>Temporary mutability giúp chúng ta tạo một biến mutable trong một phạm vi nhất định, sau đó biến đó sẽ trở thành immutable.</p>
<p>Nested block:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = {
    let mut data = get_vec();
    data.sort();
    data
};

// Here `data` is immutable.
<span class="boring">}</span></code></pre></pre>
<p>Variable rebinding:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = get_vec();
data.sort();
let data = data;

// Here `data` is immutable.
<span class="boring">}</span></code></pre></pre>
<h1 id="Ưu-điểm-2"><a class="header" href="#Ưu-điểm-2">Ưu điểm</a></h1>
<p>Giúp tránh side effect. Compiler sẽ báo lỗi nếu chúng ta vô tình thay đổi giá trị của biến immutable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aim-for-immutability-in-rust"><a class="header" href="#aim-for-immutability-in-rust">Aim For Immutability in Rust</a></h1>
<p>Immutable code giúp dễ test, parallelize, dễ refactor, và dễ đọc hơn. Chúng ta không cần lo lắng quá nhiều về side effect.</p>
<p>Rust ép chúng ta sử dụng immutable code mặc định, sử dụng từ khoá <code>mut</code> khi chúng ta cần mutable. Trong khi hầu hết các ngôn ngữ khác làm ngược lại.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let mut x = 42;
    black_box(&amp;mut x);
    println!("{}", x);
}

fn black_box(x: &amp;mut i32) {
    *x = 23;
}</code></pre></pre>
<h1 id="vì-sao-chúng-ta-cần-tránh-sử-dụng-mutable"><a class="header" href="#vì-sao-chúng-ta-cần-tránh-sử-dụng-mutable">Vì sao chúng ta cần tránh sử dụng mutable?</a></h1>
<p>Vì chúng ta hầu hết sử dụng state rất nhiều để xử lý logic.</p>
<p>Vấn đề là con người rất khó để theo dõi state khi chuyển từ giá trị này sang giá trị khác,
dẫn đến nhầm lẫn hoặc sai sót.</p>
<p>Immutable code giúp chúng ta giảm thiểu lỗi, giúp chúng ta dễ dàng theo dõi logic.</p>
<p>Trong Rust, variable mặc định là immutable, chúng ta cần sử dụng từ khoá <code>mut</code> để khai báo mutable.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 100;
x = 200; // error: re-assignment of immutable variable `x`
<span class="boring">}</span></code></pre></pre>
<h1 id="move-thay-về-mut"><a class="header" href="#move-thay-về-mut">Move thay về <code>mut</code></a></h1>
<p>Vẫn sẽ an toàn nếu chúng ta chọn "move" variable vào function hoặc struct để lý. Bằng cách này chúng ta có thể tránh việc sử dụng <code>mut</code> và copy giá trị, nhất là với các struct lớn.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn black_box(x: i32) {
    println!("{}", x);
}

fn main() {
    let x = 42;
    black_box(x);
}</code></pre></pre>
<h1 id="Đừng-ngại-copy"><a class="header" href="#Đừng-ngại-copy">Đừng ngại <code>.copy()</code></a></h1>
<p>Nếu bạn có sự lựa chọn giữa <code>mut</code> và <code>.copy()</code>, đôi khi copy không quá tệ như bạn nghĩ.</p>
<p>Chương trình có thể chậm đi một chút, tuy nhiên immutability có thể giúp bạn tránh khỏi vài ngày debug và nhức đầu.</p>
<p><a href="http://xion.io/post/code/rust-borrowchk-tricks.html">Tricks with ownership in Rust</a></p>
<h1 id="references-43"><a class="header" href="#references-43">References</a></h1>
<ul>
<li>https://corrode.dev/blog/immutability/</li>
<li>http://xion.io/post/code/rust-borrowchk-tricks.html</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
